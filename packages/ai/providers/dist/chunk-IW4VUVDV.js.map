{"version":3,"sources":["../src/openai.ts"],"names":[],"mappings":";;;;;;AAMO,IAAM,cAAA,GAAN,cAA6B,YAAA,CAAa;AAAA,EACpC,IAAA,GAAO,QAAA;AAAA,EACP,OAAA;AAAA,EACD,MAAA;AAAA,EAER,YAAY,OAAA,EAAiD;AACzD,IAAA,KAAA,EAAM;AACN,IAAA,MAAM,SAAS,SAAA,EAAU;AACzB,IAAA,MAAM,MAAA,GAAS,OAAA,EAAS,MAAA,IAAU,MAAA,CAAO,YAAA;AAEzC,IAAA,IAAI,CAAC,MAAA,EAAQ;AACT,MAAA,MAAM,IAAI,aAAA,CAAc,wBAAA,EAA0B,QAAQ,CAAA;AAAA,IAC9D;AAEA,IAAA,IAAA,CAAK,MAAA,GAAS,YAAA,CAAa,EAAE,MAAA,EAAQ,CAAA;AACrC,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA,EAAS,OAAA,IAAW,MAAA,CAAO,WAAA;AAAA,EAC9C;AAAA,EAEA,MAAM,QAAA,CAAS,QAAA,EAAqB,OAAA,EAAsD;AACtF,IAAA,IAAI;AACA,MAAA,MAAM,MAAA,GAAS,MAAM,YAAA,CAAa;AAAA,QAC9B,KAAA,EAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA;AAAA,QAC/B,QAAA,EAAU,IAAA,CAAK,cAAA,CAAe,QAAQ,CAAA;AAAA,QACtC,aAAa,OAAA,EAAS,WAAA;AAAA,QACtB,WAAW,OAAA,EAAS,SAAA;AAAA,QACpB,eAAe,OAAA,EAAS;AAAA,OAC3B,CAAA;AAED,MAAA,OAAO;AAAA,QACH,SAAS,MAAA,CAAO,IAAA;AAAA,QAChB,KAAA,EAAO,OAAO,KAAA,GAAQ;AAAA,UAClB,YAAA,EAAc,OAAO,KAAA,CAAM,YAAA;AAAA,UAC3B,gBAAA,EAAkB,OAAO,KAAA,CAAM,gBAAA;AAAA,UAC/B,WAAA,EAAa,OAAO,KAAA,CAAM;AAAA,SAC9B,GAAI,KAAA,CAAA;AAAA,QACJ,cAAc,MAAA,CAAO;AAAA,OACzB;AAAA,IACJ,SAAS,KAAA,EAAO;AACZ,MAAA,MAAM,IAAI,aAAA;AAAA,QACN,CAAA,0BAAA,EAA8B,MAAgB,OAAO,CAAA,CAAA;AAAA,QACrD,QAAA;AAAA,QACA,EAAE,KAAA;AAAM,OACZ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,OAAO,MAAA,CAAO,QAAA,EAAqB,OAAA,EAA4E;AAC3G,IAAA,IAAI;AACA,MAAA,MAAM,MAAA,GAAS,MAAM,UAAA,CAAW;AAAA,QAC5B,KAAA,EAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA;AAAA,QAC/B,QAAA,EAAU,IAAA,CAAK,cAAA,CAAe,QAAQ,CAAA;AAAA,QACtC,aAAa,OAAA,EAAS,WAAA;AAAA,QACtB,WAAW,OAAA,EAAS;AAAA,OACvB,CAAA;AAED,MAAA,WAAA,MAAiB,KAAA,IAAS,OAAO,UAAA,EAAY;AACzC,QAAA,OAAA,EAAS,UAAU,KAAK,CAAA;AACxB,QAAA,MAAM,EAAE,OAAA,EAAS,KAAA,EAAO,IAAA,EAAM,KAAA,EAAM;AAAA,MACxC;AAEA,MAAA,MAAM,EAAE,OAAA,EAAS,EAAA,EAAI,IAAA,EAAM,IAAA,EAAK;AAAA,IACpC,SAAS,KAAA,EAAO;AACZ,MAAA,MAAM,IAAI,aAAA;AAAA,QACN,CAAA,yBAAA,EAA6B,MAAgB,OAAO,CAAA,CAAA;AAAA,QACpD,QAAA;AAAA,QACA,EAAE,KAAA;AAAM,OACZ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAM,iBAAA,CACF,QAAA,EACA,KAAA,EACA,OAAA,EACyB;AACzB,IAAA,IAAI;AACA,MAAA,MAAM,OAAA,GAAU,IAAA,CAAK,YAAA,CAAa,KAAK,CAAA;AAEvC,MAAA,MAAM,MAAA,GAAS,MAAM,YAAA,CAAa;AAAA,QAC9B,KAAA,EAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA;AAAA,QAC/B,QAAA,EAAU,IAAA,CAAK,cAAA,CAAe,QAAQ,CAAA;AAAA,QACtC,KAAA,EAAO,OAAA;AAAA,QACP,aAAa,OAAA,EAAS,WAAA;AAAA,QACtB,WAAW,OAAA,EAAS;AAAA,OACvB,CAAA;AAED,MAAA,OAAO;AAAA,QACH,SAAS,MAAA,CAAO,IAAA;AAAA,QAChB,SAAA,EAAW,MAAA,CAAO,SAAA,EAAW,GAAA,CAAI,CAAC,EAAA,MAAQ;AAAA,UACtC,IAAI,EAAA,CAAG,UAAA;AAAA,UACP,MAAM,EAAA,CAAG,QAAA;AAAA,UACT,WAAW,EAAA,CAAG;AAAA,SAClB,CAAE,CAAA;AAAA,QACF,KAAA,EAAO,OAAO,KAAA,GAAQ;AAAA,UAClB,YAAA,EAAc,OAAO,KAAA,CAAM,YAAA;AAAA,UAC3B,gBAAA,EAAkB,OAAO,KAAA,CAAM,gBAAA;AAAA,UAC/B,WAAA,EAAa,OAAO,KAAA,CAAM;AAAA,SAC9B,GAAI,KAAA,CAAA;AAAA,QACJ,cAAc,MAAA,CAAO;AAAA,OACzB;AAAA,IACJ,SAAS,KAAA,EAAO;AACZ,MAAA,MAAM,IAAI,aAAA;AAAA,QACN,CAAA,+BAAA,EAAmC,MAAgB,OAAO,CAAA,CAAA;AAAA,QAC1D,QAAA;AAAA,QACA,EAAE,KAAA;AAAM,OACZ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEQ,eAAe,QAAA,EAAwF;AAC3G,IAAA,OAAO,QAAA,CAAS,GAAA,CAAI,CAAC,CAAA,MAAO;AAAA,MACxB,IAAA,EAAM,CAAA,CAAE,IAAA,KAAS,MAAA,GAAS,cAAc,CAAA,CAAE,IAAA;AAAA,MAC1C,SAAS,CAAA,CAAE;AAAA,KACf,CAAE,CAAA;AAAA,EACN;AAAA,EAEQ,aAAa,KAAA,EAA2D;AAC5E,IAAA,MAAM,SAAkD,EAAC;AAEzD,IAAA,KAAA,MAAW,KAAK,KAAA,EAAO;AACnB,MAAA,MAAA,CAAO,CAAA,CAAE,IAAI,CAAA,GAAI,IAAA,CAAK;AAAA,QAClB,aAAa,CAAA,CAAE,WAAA;AAAA,QACf,UAAA,EAAY,CAAA,CAAE,MAAA,CAAO,CAAA,CAAE,WAA2C;AAAA,OACrE,CAAA;AAAA,IACL;AAEA,IAAA,OAAO,MAAA;AAAA,EACX;AACJ","file":"chunk-IW4VUVDV.js","sourcesContent":["import { createOpenAI } from \"@ai-sdk/openai\";\r\nimport { generateText, streamText, tool } from \"ai\";\r\nimport { z } from \"zod\";\r\nimport { getConfig, type Message, type MCPTool, ProviderError } from \"@repo/shared\";\r\nimport { BaseProvider, type GenerateOptions, type StreamOptions, type ProviderResponse } from \"./base\";\r\n\r\nexport class OpenAIProvider extends BaseProvider {\r\n    readonly type = \"openai\" as const;\r\n    readonly modelId: string;\r\n    private client: ReturnType<typeof createOpenAI>;\r\n\r\n    constructor(options?: { apiKey?: string; modelId?: string }) {\r\n        super();\r\n        const config = getConfig();\r\n        const apiKey = options?.apiKey ?? config.openaiApiKey;\r\n\r\n        if (!apiKey) {\r\n            throw new ProviderError(\"Missing OpenAI API key\", \"openai\");\r\n        }\r\n\r\n        this.client = createOpenAI({ apiKey });\r\n        this.modelId = options?.modelId ?? config.openaiModel;\r\n    }\r\n\r\n    async generate(messages: Message[], options?: GenerateOptions): Promise<ProviderResponse> {\r\n        try {\r\n            const result = await generateText({\r\n                model: this.client(this.modelId),\r\n                messages: this.formatMessages(messages),\r\n                temperature: options?.temperature,\r\n                maxTokens: options?.maxTokens,\r\n                stopSequences: options?.stopSequences,\r\n            });\r\n\r\n            return {\r\n                content: result.text,\r\n                usage: result.usage ? {\r\n                    promptTokens: result.usage.promptTokens,\r\n                    completionTokens: result.usage.completionTokens,\r\n                    totalTokens: result.usage.totalTokens,\r\n                } : undefined,\r\n                finishReason: result.finishReason,\r\n            };\r\n        } catch (error) {\r\n            throw new ProviderError(\r\n                `OpenAI generation failed: ${(error as Error).message}`,\r\n                \"openai\",\r\n                { error }\r\n            );\r\n        }\r\n    }\r\n\r\n    async *stream(messages: Message[], options?: StreamOptions): AsyncIterable<{ content: string; done: boolean }> {\r\n        try {\r\n            const result = await streamText({\r\n                model: this.client(this.modelId),\r\n                messages: this.formatMessages(messages),\r\n                temperature: options?.temperature,\r\n                maxTokens: options?.maxTokens,\r\n            });\r\n\r\n            for await (const chunk of result.textStream) {\r\n                options?.onToken?.(chunk);\r\n                yield { content: chunk, done: false };\r\n            }\r\n\r\n            yield { content: \"\", done: true };\r\n        } catch (error) {\r\n            throw new ProviderError(\r\n                `OpenAI streaming failed: ${(error as Error).message}`,\r\n                \"openai\",\r\n                { error }\r\n            );\r\n        }\r\n    }\r\n\r\n    async generateWithTools(\r\n        messages: Message[],\r\n        tools: MCPTool[],\r\n        options?: GenerateOptions\r\n    ): Promise<ProviderResponse> {\r\n        try {\r\n            const aiTools = this.convertTools(tools);\r\n\r\n            const result = await generateText({\r\n                model: this.client(this.modelId),\r\n                messages: this.formatMessages(messages),\r\n                tools: aiTools,\r\n                temperature: options?.temperature,\r\n                maxTokens: options?.maxTokens,\r\n            });\r\n\r\n            return {\r\n                content: result.text,\r\n                toolCalls: result.toolCalls?.map((tc) => ({\r\n                    id: tc.toolCallId,\r\n                    name: tc.toolName,\r\n                    arguments: tc.args as Record<string, unknown>,\r\n                })),\r\n                usage: result.usage ? {\r\n                    promptTokens: result.usage.promptTokens,\r\n                    completionTokens: result.usage.completionTokens,\r\n                    totalTokens: result.usage.totalTokens,\r\n                } : undefined,\r\n                finishReason: result.finishReason,\r\n            };\r\n        } catch (error) {\r\n            throw new ProviderError(\r\n                `OpenAI tool generation failed: ${(error as Error).message}`,\r\n                \"openai\",\r\n                { error }\r\n            );\r\n        }\r\n    }\r\n\r\n    private formatMessages(messages: Message[]): Array<{ role: \"user\" | \"assistant\" | \"system\"; content: string }> {\r\n        return messages.map((m) => ({\r\n            role: m.role === \"tool\" ? \"assistant\" : m.role,\r\n            content: m.content,\r\n        }));\r\n    }\r\n\r\n    private convertTools(tools: MCPTool[]): Record<string, ReturnType<typeof tool>> {\r\n        const result: Record<string, ReturnType<typeof tool>> = {};\r\n\r\n        for (const t of tools) {\r\n            result[t.name] = tool({\r\n                description: t.description,\r\n                parameters: z.object(t.inputSchema as Record<string, z.ZodTypeAny>),\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]}