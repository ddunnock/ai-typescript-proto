{"version":3,"sources":["../src/base.ts"],"names":[],"mappings":"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","file":"chunk-3CXXBFFK.js","sourcesContent":["import { StateGraph, END, START } from \"@langchain/langgraph\";\r\nimport {\r\n    type AgentConfig,\r\n    type AgentTask,\r\n    type AgentResult,\r\n    type AgentEvent,\r\n    type Message,\r\n    generateId,\r\n    createMessage,\r\n    createAgentEvent,\r\n    AgentError,\r\n} from \"@repo/shared\";\r\nimport type { BaseProvider } from \"@repo/providers\";\r\nimport { getMCPRegistry } from \"@repo/mcp\";\r\nimport { AgentStateAnnotation, type AgentState } from \"./state\";\r\n\r\nexport abstract class BaseAgent {\r\n    protected provider: BaseProvider;\r\n    protected config: AgentConfig;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    protected graph: any;\r\n\r\n    constructor(provider: BaseProvider, config: Partial<AgentConfig>) {\r\n        this.provider = provider;\r\n        this.config = {\r\n            type: config.type ?? \"orchestrator\",\r\n            name: config.name ?? \"Agent\",\r\n            description: config.description,\r\n            mcpServers: config.mcpServers ?? [],\r\n            maxConcurrentTasks: config.maxConcurrentTasks ?? 5,\r\n            timeout: config.timeout ?? 30000,\r\n        };\r\n        this.graph = this.buildGraph();\r\n    }\r\n\r\n    /**\r\n     * Build the LangGraph state machine\r\n     */\r\n    protected buildGraph() {\r\n        const workflow = new StateGraph(AgentStateAnnotation)\r\n            .addNode(\"initialize\", this.initializeNode.bind(this))\r\n            .addNode(\"process\", this.processNode.bind(this))\r\n            .addNode(\"tool_call\", this.toolCallNode.bind(this))\r\n            .addNode(\"finalize\", this.finalizeNode.bind(this))\r\n            .addEdge(START, \"initialize\")\r\n            .addEdge(\"initialize\", \"process\")\r\n            .addConditionalEdges(\"process\", this.routeFromProcess.bind(this), {\r\n                tool_call: \"tool_call\",\r\n                finalize: \"finalize\",\r\n            })\r\n            .addEdge(\"tool_call\", \"process\")\r\n            .addEdge(\"finalize\", END);\r\n\r\n        return workflow.compile();\r\n    }\r\n\r\n    /**\r\n     * Initialize the agent state\r\n     */\r\n    protected async initializeNode(state: AgentState): Promise<Partial<AgentState>> {\r\n        return {\r\n            status: \"thinking\",\r\n            currentAgent: this.config.type,\r\n            context: {\r\n                ...state.context,\r\n                agentName: this.config.name,\r\n                startedAt: new Date().toISOString(),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Process the current state and generate a response\r\n     */\r\n    protected async processNode(state: AgentState): Promise<Partial<AgentState>> {\r\n        const tools = this.getTools();\r\n        const systemPrompt = this.getSystemPrompt();\r\n\r\n        const messages: Message[] = [\r\n            createMessage(\"system\", systemPrompt),\r\n            ...state.messages,\r\n        ];\r\n\r\n        try {\r\n            const response = await this.provider.generateWithTools(messages, tools, {\r\n                temperature: 0.7,\r\n                maxTokens: 4096,\r\n            });\r\n\r\n            if (response.toolCalls && response.toolCalls.length > 0) {\r\n                return {\r\n                    status: \"executing\",\r\n                    context: {\r\n                        ...state.context,\r\n                        pendingToolCalls: response.toolCalls,\r\n                    },\r\n                };\r\n            }\r\n\r\n            return {\r\n                messages: [createMessage(\"assistant\", response.content)],\r\n                status: \"complete\",\r\n            };\r\n        } catch (error) {\r\n            return {\r\n                error: (error as Error).message,\r\n                status: \"error\",\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute tool calls\r\n     */\r\n    protected async toolCallNode(state: AgentState): Promise<Partial<AgentState>> {\r\n        const pendingCalls = state.context.pendingToolCalls as Array<{\r\n            id: string;\r\n            name: string;\r\n            arguments: Record<string, unknown>;\r\n        }>;\r\n\r\n        if (!pendingCalls || pendingCalls.length === 0) {\r\n            return { status: \"thinking\" };\r\n        }\r\n\r\n        const registry = getMCPRegistry();\r\n        const results: Array<{ tool: string; result: unknown }> = [];\r\n\r\n        for (const call of pendingCalls) {\r\n            try {\r\n                const result = await registry.callTool(call.name, call.arguments);\r\n                results.push({ tool: call.name, result });\r\n            } catch (error) {\r\n                results.push({ tool: call.name, result: { error: (error as Error).message } });\r\n            }\r\n        }\r\n\r\n        return {\r\n            toolResults: results,\r\n            status: \"thinking\",\r\n            context: {\r\n                ...state.context,\r\n                pendingToolCalls: undefined,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finalize the agent response\r\n     */\r\n    protected async finalizeNode(state: AgentState): Promise<Partial<AgentState>> {\r\n        return {\r\n            completed: true,\r\n            status: \"complete\",\r\n            context: {\r\n                ...state.context,\r\n                completedAt: new Date().toISOString(),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Route from process node\r\n     */\r\n    protected routeFromProcess(state: AgentState): \"tool_call\" | \"finalize\" {\r\n        const pendingCalls = state.context.pendingToolCalls;\r\n        if (pendingCalls && Array.isArray(pendingCalls) && pendingCalls.length > 0) {\r\n            return \"tool_call\";\r\n        }\r\n        return \"finalize\";\r\n    }\r\n\r\n    /**\r\n     * Get available tools for this agent\r\n     */\r\n    protected getTools() {\r\n        const registry = getMCPRegistry();\r\n        return registry.getToolsForAgent(this.config.type);\r\n    }\r\n\r\n    /**\r\n     * Get the system prompt for this agent\r\n     */\r\n    protected abstract getSystemPrompt(): string;\r\n\r\n    /**\r\n     * Process a query and return the response\r\n     */\r\n    async process(query: string): Promise<string> {\r\n        const initialState: Partial<AgentState> = {\r\n            messages: [createMessage(\"user\", query)],\r\n        };\r\n\r\n        const result = await this.graph.invoke(initialState);\r\n\r\n        if (result.error) {\r\n            throw new AgentError(result.error, this.config.type);\r\n        }\r\n\r\n        const lastMessage = result.messages[result.messages.length - 1];\r\n        return lastMessage?.content ?? \"\";\r\n    }\r\n\r\n    /**\r\n     * Stream process with events\r\n     */\r\n    async *streamProcess(query: string): AsyncIterable<AgentEvent> {\r\n        const initialState: Partial<AgentState> = {\r\n            messages: [createMessage(\"user\", query)],\r\n        };\r\n\r\n        const stream = await this.graph.stream(initialState);\r\n\r\n        for await (const event of stream) {\r\n            const [nodeName, nodeState] = Object.entries(event)[0] ?? [];\r\n\r\n            if (!nodeName || !nodeState) continue;\r\n\r\n            const state = nodeState as Partial<AgentState>;\r\n\r\n            switch (nodeName) {\r\n                case \"initialize\":\r\n                    yield createAgentEvent(\"thinking\", \"Starting...\", this.config.type);\r\n                    break;\r\n                case \"process\":\r\n                    if (state.messages && state.messages.length > 0) {\r\n                        const lastMsg = state.messages[state.messages.length - 1];\r\n                        yield createAgentEvent(\"response\", lastMsg?.content, this.config.type);\r\n                    }\r\n                    break;\r\n                case \"tool_call\":\r\n                    if (state.toolResults) {\r\n                        for (const result of state.toolResults) {\r\n                            yield createAgentEvent(\"tool_result\", result, this.config.type);\r\n                        }\r\n                    }\r\n                    break;\r\n                case \"finalize\":\r\n                    yield createAgentEvent(\"complete\", null, this.config.type);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a structured task\r\n     */\r\n    async execute(task: AgentTask): Promise<AgentResult> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const response = await this.process(\r\n                typeof task.data.query === \"string\" ? task.data.query : JSON.stringify(task.data)\r\n            );\r\n\r\n            return {\r\n                taskId: task.id,\r\n                success: true,\r\n                data: { response },\r\n                duration: Date.now() - startTime,\r\n                completedAt: new Date(),\r\n            };\r\n        } catch (error) {\r\n            return {\r\n                taskId: task.id,\r\n                success: false,\r\n                error: (error as Error).message,\r\n                duration: Date.now() - startTime,\r\n                completedAt: new Date(),\r\n            };\r\n        }\r\n    }\r\n}"]}