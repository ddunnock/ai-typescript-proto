"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@xyflow/react/dist/esm/index.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@xyflow/react/dist/esm/index.js ***!
  \********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   EdgeToolbar: () => (/* binding */ EdgeToolbar),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   MiniMapNode: () => (/* binding */ MiniMapNode),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   experimental_useOnEdgesChangeMiddleware: () => (/* binding */ experimental_useOnEdgesChangeMiddleware),\n/* harmony export */   experimental_useOnNodesChangeMiddleware: () => (/* binding */ experimental_useOnNodesChangeMiddleware),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../node_modules/.pnpm/next@14.2.33_@babel+core@7.28.5_@opentelemetry+api@1.9.0_@playwright+test@1.57.0_react-_40e69a44082d02acf5b91e9d11d891dc/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.2.33_@babel+core@7.28.5_@opentelemetry+api@1.9.0_@playwright+test@1.57.0_react-_40e69a44082d02acf5b91e9d11d891dc/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/../../node_modules/.pnpm/classcat@5.0.5/node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/../../node_modules/.pnpm/@xyflow+system@0.0.74/node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/../../node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.27_react@18.3.1/node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/../../node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.27_react@18.3.1/node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/.pnpm/next@14.2.33_@babel+core@7.28.5_@opentelemetry+api@1.9.0_@playwright+test@1.57.0_react-_40e69a44082d02acf5b91e9d11d891dc/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,EdgeToolbar,Handle,MiniMap,MiniMapNode,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,experimental_useOnEdgesChangeMiddleware,experimental_useOnNodesChangeMiddleware,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error001\"]();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            getState: store.getState,\n            setState: store.setState,\n            subscribe: store.subscribe\n        }), [\n        store\n    ]);\n}\nconst style = {\n    display: \"none\"\n};\nconst ariaLiveStyle = {\n    position: \"absolute\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0px, 0px, 0px, 0px)\",\n    clipPath: \"inset(100%)\"\n};\nconst ARIA_NODE_DESC_KEY = \"react-flow__node-desc\";\nconst ARIA_EDGE_DESC_KEY = \"react-flow__edge-desc\";\nconst ARIA_LIVE_MESSAGE = \"react-flow__aria-live\";\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig[\"node.a11yDescription.default\"] : ariaLabelConfig[\"node.a11yDescription.keyboardDisabled\"]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig[\"edge.a11yDescription.default\"]\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = \"top-left\", children, className, style, ...rest }, ref)=>{\n    const positionClasses = `${position}`.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__panel\",\n            className,\n            ...positionClasses\n        ]),\n        style: style,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = \"Panel\";\nfunction Attribution({ proOptions, position = \"bottom-right\" }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const params = {\n            nodes: selectedNodes,\n            edges: selectedEdges\n        };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChangeHandlers.forEach((fn)=>fn(params));\n    }, [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    \"nodes\",\n    \"edges\",\n    \"defaultNodes\",\n    \"defaultEdges\",\n    \"onConnect\",\n    \"onConnectStart\",\n    \"onConnectEnd\",\n    \"onClickConnectStart\",\n    \"onClickConnectEnd\",\n    \"nodesDraggable\",\n    \"autoPanOnNodeFocus\",\n    \"nodesConnectable\",\n    \"nodesFocusable\",\n    \"edgesFocusable\",\n    \"edgesReconnectable\",\n    \"elevateNodesOnSelect\",\n    \"elevateEdgesOnSelect\",\n    \"minZoom\",\n    \"maxZoom\",\n    \"nodeExtent\",\n    \"onNodesChange\",\n    \"onEdgesChange\",\n    \"elementsSelectable\",\n    \"connectionMode\",\n    \"snapGrid\",\n    \"snapToGrid\",\n    \"translateExtent\",\n    \"connectOnClick\",\n    \"defaultEdgeOptions\",\n    \"fitView\",\n    \"fitViewOptions\",\n    \"onNodesDelete\",\n    \"onEdgesDelete\",\n    \"onDelete\",\n    \"onNodeDrag\",\n    \"onNodeDragStart\",\n    \"onNodeDragStop\",\n    \"onSelectionDrag\",\n    \"onSelectionDragStart\",\n    \"onSelectionDragStop\",\n    \"onMoveStart\",\n    \"onMove\",\n    \"onMoveEnd\",\n    \"noPanClassName\",\n    \"nodeOrigin\",\n    \"autoPanOnConnect\",\n    \"autoPanOnNodeDrag\",\n    \"onError\",\n    \"connectionRadius\",\n    \"isValidConnection\",\n    \"selectNodesOnDrag\",\n    \"nodeDragThreshold\",\n    \"connectionDragThreshold\",\n    \"onBeforeDelete\",\n    \"debug\",\n    \"autoPanSpeed\",\n    \"ariaLabelConfig\",\n    \"zIndexMode\"\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    \"rfId\"\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: \"nopan\",\n    rfId: \"1\"\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n        return ()=>{\n            // when we reset the store we also need to reset the previous fields\n            previousFields.current = initPrevValues;\n            reset();\n        };\n    }, []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        for (const fieldName of fieldsToTrack){\n            const fieldValue = props[fieldName];\n            const previousFieldValue = previousFields.current[fieldName];\n            if (fieldValue === previousFieldValue) continue;\n            if (typeof props[fieldName] === \"undefined\") continue;\n            // Custom handling with dedicated setters for some fields\n            if (fieldName === \"nodes\") setNodes(fieldValue);\n            else if (fieldName === \"edges\") setEdges(fieldValue);\n            else if (fieldName === \"minZoom\") setMinZoom(fieldValue);\n            else if (fieldName === \"maxZoom\") setMaxZoom(fieldValue);\n            else if (fieldName === \"translateExtent\") setTranslateExtent(fieldValue);\n            else if (fieldName === \"nodeExtent\") setNodeExtent(fieldValue);\n            else if (fieldName === \"ariaLabelConfig\") store.setState({\n                ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n            });\n            else if (fieldName === \"fitView\") store.setState({\n                fitViewQueued: fieldValue\n            });\n            else if (fieldName === \"fitViewOptions\") store.setState({\n                fitViewOptions: fieldValue\n            });\n            else store.setState({\n                [fieldName]: fieldValue\n            });\n        }\n        previousFields.current = props;\n    }, // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map((fieldName)=>props[fieldName]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia(\"(prefers-color-scheme: dark)\");\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === \"system\" ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (colorMode !== \"system\") {\n            setColorModeClass(colorMode);\n            return;\n        }\n        const mediaQuery = getMediaQuery();\n        const updateColorModeClass = ()=>setColorModeClass(mediaQuery?.matches ? \"dark\" : \"light\");\n        updateColorModeClass();\n        mediaQuery?.addEventListener(\"change\", updateColorModeClass);\n        return ()=>{\n            mediaQuery?.removeEventListener(\"change\", updateColorModeClass);\n        };\n    }, [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? \"dark\" : \"light\";\n}\nconst defaultDoc = typeof document !== \"undefined\" ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                keyCode\n            ];\n            const keys = keyCodeArr.filter((kc)=>typeof kc === \"string\")/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map((kc)=>kc.replace(\"+\", \"\\n\").replace(\"\\n\\n\", \"\\n+\").split(\"\\n\"));\n            const keysFlat = keys.reduce((res, item)=>res.concat(...item), []);\n            return [\n                keys,\n                keysFlat\n            ];\n        }\n        return [\n            [],\n            []\n        ];\n    }, [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const target = options?.target ?? defaultDoc;\n        const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n        if (keyCode !== null) {\n            const downHandler = (event)=>{\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    const target = event.composedPath?.()?.[0] || event.target;\n                    const isInteractiveElement = target?.nodeName === \"BUTTON\" || target?.nodeName === \"A\";\n                    if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                        event.preventDefault();\n                    }\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event)=>{\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                } else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === \"Meta\") {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = ()=>{\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener(\"keydown\", downHandler);\n            target?.addEventListener(\"keyup\", upHandler);\n            window.addEventListener(\"blur\", resetHandler);\n            window.addEventListener(\"contextmenu\", resetHandler);\n            return ()=>{\n                target?.removeEventListener(\"keydown\", downHandler);\n                target?.removeEventListener(\"keyup\", upHandler);\n                window.removeEventListener(\"blur\", resetHandler);\n                window.removeEventListener(\"contextmenu\", resetHandler);\n            };\n        }\n    }, [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? \"code\" : \"key\";\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            zoomIn: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomOut: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomTo: (zoomLevel, options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleTo(zoomLevel, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            getZoom: ()=>store.getState().transform[2],\n            setViewport: async (viewport, options)=>{\n                const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport({\n                    x: viewport.x ?? tX,\n                    y: viewport.y ?? tY,\n                    zoom: viewport.zoom ?? tZoom\n                }, options);\n                return Promise.resolve(true);\n            },\n            getViewport: ()=>{\n                const [x, y, zoom] = store.getState().transform;\n                return {\n                    x,\n                    y,\n                    zoom\n                };\n            },\n            setCenter: async (x, y, options)=>{\n                return store.getState().setCenter(x, y, options);\n            },\n            fitBounds: async (bounds, options)=>{\n                const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport(viewport, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            screenToFlowPosition: (clientPosition, options = {})=>{\n                const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                if (!domNode) {\n                    return clientPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const correctedPosition = {\n                    x: clientPosition.x - domX,\n                    y: clientPosition.y - domY\n                };\n                const _snapGrid = options.snapGrid ?? snapGrid;\n                const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n            },\n            flowToScreenPosition: (flowPosition)=>{\n                const { transform, domNode } = store.getState();\n                if (!domNode) {\n                    return flowPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                return {\n                    x: rendererPosition.x + domX,\n                    y: rendererPosition.y + domY\n                };\n            }\n        };\n    }, []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === \"add\") {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === \"remove\" || change.type === \"replace\") {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === \"remove\") {\n            continue;\n        }\n        if (changes[0].type === \"replace\") {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case \"select\":\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case \"position\":\n            {\n                if (typeof change.position !== \"undefined\") {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== \"undefined\") {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case \"dimensions\":\n            {\n                if (typeof change.dimensions !== \"undefined\") {\n                    element.measured = {\n                        ...change.dimensions\n                    };\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === \"width\") {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === \"height\") {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === \"boolean\") {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: \"select\",\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: \"replace\"\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: \"add\",\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: \"remove\"\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: \"remove\"\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createQueue(()=>setSerial((n)=>n + BigInt(1))));\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect(()=>{\n        const queueItems = queue.get();\n        if (queueItems.length) {\n            runQueue(queueItems);\n            queue.reset();\n        }\n    }, [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued, onNodesChangeMiddlewareMap } = store.getState();\n        /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        let changes = getElementsDiffChanges({\n            items: next,\n            lookup: nodeLookup\n        });\n        for (const middleware of onNodesChangeMiddlewareMap.values()){\n            changes = middleware(changes);\n        }\n        if (hasDefaultNodes) {\n            setNodes(next);\n        }\n        // We only want to fire onNodesChange if there are changes to the nodes\n        if (changes.length > 0) {\n            onNodesChange?.(changes);\n        } else if (fitViewQueued) {\n            // If there are no changes to the nodes, we still need to call setNodes\n            // to trigger a re-render and fitView.\n            window.requestAnimationFrame(()=>{\n                const { fitViewQueued, nodes, setNodes } = store.getState();\n                if (fitViewQueued) {\n                    setNodes(nodes);\n                }\n            });\n        }\n    }, []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n        let next = edges;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        if (hasDefaultEdges) {\n            setEdges(next);\n        } else if (onEdgesChange) {\n            onEdgesChange(getElementsDiffChanges({\n                items: next,\n                lookup: edgeLookup\n            }));\n        }\n    }, []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            nodeQueue,\n            edgeQueue\n        }), []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error(\"useBatchContext must be used within a BatchProvider\");\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const getInternalNode = (id)=>store.getState().nodeLookup.get(id);\n        const setNodes = (payload)=>{\n            batchContext.nodeQueue.push(payload);\n        };\n        const setEdges = (payload)=>{\n            batchContext.edgeQueue.push(payload);\n        };\n        const getNodeRect = (node)=>{\n            const { nodeLookup, nodeOrigin } = store.getState();\n            const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n            const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n            const nodeWithPosition = {\n                ...nodeToUse,\n                position,\n                width: nodeToUse.measured?.width ?? nodeToUse.width,\n                height: nodeToUse.measured?.height ?? nodeToUse.height\n            };\n            return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n        };\n        const updateNode = (id, nodeUpdate, options = {\n            replace: false\n        })=>{\n            setNodes((prevNodes)=>prevNodes.map((node)=>{\n                    if (node.id === id) {\n                        const nextNode = typeof nodeUpdate === \"function\" ? nodeUpdate(node) : nodeUpdate;\n                        return options.replace && isNode(nextNode) ? nextNode : {\n                            ...node,\n                            ...nextNode\n                        };\n                    }\n                    return node;\n                }));\n        };\n        const updateEdge = (id, edgeUpdate, options = {\n            replace: false\n        })=>{\n            setEdges((prevEdges)=>prevEdges.map((edge)=>{\n                    if (edge.id === id) {\n                        const nextEdge = typeof edgeUpdate === \"function\" ? edgeUpdate(edge) : edgeUpdate;\n                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                            ...edge,\n                            ...nextEdge\n                        };\n                    }\n                    return edge;\n                }));\n        };\n        return {\n            getNodes: ()=>store.getState().nodes.map((n)=>({\n                        ...n\n                    })),\n            getNode: (id)=>getInternalNode(id)?.internals.userNode,\n            getInternalNode,\n            getEdges: ()=>{\n                const { edges = [] } = store.getState();\n                return edges.map((e)=>({\n                        ...e\n                    }));\n            },\n            getEdge: (id)=>store.getState().edgeLookup.get(id),\n            setNodes,\n            setEdges,\n            addNodes: (payload)=>{\n                const newNodes = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes,\n                        ...newNodes\n                    ]);\n            },\n            addEdges: (payload)=>{\n                const newEdges = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.edgeQueue.push((edges)=>[\n                        ...edges,\n                        ...newEdges\n                    ]);\n            },\n            toObject: ()=>{\n                const { nodes = [], edges = [], transform } = store.getState();\n                const [x, y, zoom] = transform;\n                return {\n                    nodes: nodes.map((n)=>({\n                            ...n\n                        })),\n                    edges: edges.map((e)=>({\n                            ...e\n                        })),\n                    viewport: {\n                        x,\n                        y,\n                        zoom\n                    }\n                };\n            },\n            deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                    nodesToRemove,\n                    edgesToRemove,\n                    nodes,\n                    edges,\n                    onBeforeDelete\n                });\n                const hasMatchingEdges = matchingEdges.length > 0;\n                const hasMatchingNodes = matchingNodes.length > 0;\n                if (hasMatchingEdges) {\n                    const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                    onEdgesDelete?.(matchingEdges);\n                    triggerEdgeChanges(edgeChanges);\n                }\n                if (hasMatchingNodes) {\n                    const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                    onNodesDelete?.(matchingNodes);\n                    triggerNodeChanges(nodeChanges);\n                }\n                if (hasMatchingNodes || hasMatchingEdges) {\n                    onDelete?.({\n                        nodes: matchingNodes,\n                        edges: matchingEdges\n                    });\n                }\n                return {\n                    deletedNodes: matchingNodes,\n                    deletedEdges: matchingEdges\n                };\n            },\n            /**\n             * Partial is defined as \"the 2 nodes/areas are intersecting partially\".\n             * If a is contained in b or b is contained in a, they are both\n             * considered fully intersecting.\n             */ getIntersectingNodes: (nodeOrRect, partially = true, nodes)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                const hasNodesOption = nodes !== undefined;\n                if (!nodeRect) {\n                    return [];\n                }\n                return (nodes || store.getState().nodes).filter((n)=>{\n                    const internalNode = store.getState().nodeLookup.get(n.id);\n                    if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                        return false;\n                    }\n                    const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                    const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                    const partiallyVisible = partially && overlappingArea > 0;\n                    return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                });\n            },\n            isNodeIntersecting: (nodeOrRect, area, partially = true)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                if (!nodeRect) {\n                    return false;\n                }\n                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                const partiallyVisible = partially && overlappingArea > 0;\n                return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;\n            },\n            updateNode,\n            updateNodeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateNode(id, (node)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(node) : dataUpdate;\n                    return options.replace ? {\n                        ...node,\n                        data: nextData\n                    } : {\n                        ...node,\n                        data: {\n                            ...node.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            updateEdge,\n            updateEdgeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateEdge(id, (edge)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(edge) : dataUpdate;\n                    return options.replace ? {\n                        ...edge,\n                        data: nextData\n                    } : {\n                        ...edge,\n                        data: {\n                            ...edge.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            getNodesBounds: (nodes)=>{\n                const { nodeLookup, nodeOrigin } = store.getState();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                    nodeLookup,\n                    nodeOrigin\n                });\n            },\n            getHandleConnections: ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : \"\"}`)?.values() ?? []),\n            getNodeConnections: ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : \"\"}`)?.values() ?? []),\n            fitView: async (options)=>{\n                // We either create a new Promise or reuse the existing one\n                // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                store.setState({\n                    fitViewQueued: true,\n                    fitViewOptions: options,\n                    fitViewResolver\n                });\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes\n                    ]);\n                return fitViewResolver.promise;\n            }\n        };\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            ...generalHelper,\n            ...viewportHelper,\n            viewportInitialized\n        };\n    }, [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (deleteKeyPressed) {\n            const { edges, nodes } = store.getState();\n            deleteElements({\n                nodes: nodes.filter(selected),\n                edges: edges.filter(selected)\n            });\n            store.setState({\n                nodesSelectionActive: false\n            });\n        }\n    }, [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            multiSelectionActive: multiSelectionKeyPressed\n        });\n    }, [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (!domNode.current || !(domNode.current.checkVisibility?.() ?? true)) {\n                return false;\n            }\n            const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.(\"004\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error004\"]());\n            }\n            store.setState({\n                width: size.width || 500,\n                height: size.height || 500\n            });\n        };\n        if (domNode.current) {\n            updateDimensions();\n            window.addEventListener(\"resize\", updateDimensions);\n            const resizeObserver = new ResizeObserver(()=>updateDimensions());\n            resizeObserver.observe(domNode.current);\n            return ()=>{\n                window.removeEventListener(\"resize\", updateDimensions);\n                if (resizeObserver && domNode.current) {\n                    resizeObserver.unobserve(domNode.current);\n                }\n            };\n        }\n    }, []);\n}\nconst containerStyle = {\n    position: \"absolute\",\n    width: \"100%\",\n    height: \"100%\",\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib,\n        connectionInProgress: s.connection.inProgress\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, selectionOnDrag }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib, connectionInProgress } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((transform)=>{\n        onViewportChange?.({\n            x: transform[0],\n            y: transform[1],\n            zoom: transform[2]\n        });\n        if (!isControlledViewport) {\n            store.setState({\n                transform\n            });\n        }\n    }, [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (zoomPane.current) {\n            panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                domNode: zoomPane.current,\n                minZoom,\n                maxZoom,\n                translateExtent,\n                viewport: defaultViewport,\n                onDraggingChange: (paneDragging)=>store.setState({\n                        paneDragging\n                    }),\n                onPanZoomStart: (event, vp)=>{\n                    const { onViewportChangeStart, onMoveStart } = store.getState();\n                    onMoveStart?.(event, vp);\n                    onViewportChangeStart?.(vp);\n                },\n                onPanZoom: (event, vp)=>{\n                    const { onViewportChange, onMove } = store.getState();\n                    onMove?.(event, vp);\n                    onViewportChange?.(vp);\n                },\n                onPanZoomEnd: (event, vp)=>{\n                    const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                    onMoveEnd?.(event, vp);\n                    onViewportChangeEnd?.(vp);\n                }\n            });\n            const { x, y, zoom } = panZoom.current.getViewport();\n            store.setState({\n                panZoom: panZoom.current,\n                transform: [\n                    x,\n                    y,\n                    zoom\n                ],\n                domNode: zoomPane.current.closest(\".react-flow\")\n            });\n            return ()=>{\n                panZoom.current?.destroy();\n            };\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        panZoom.current?.update({\n            onPaneContextMenu,\n            zoomOnScroll,\n            zoomOnPinch,\n            panOnScroll,\n            panOnScrollSpeed,\n            panOnScrollMode,\n            zoomOnDoubleClick,\n            panOnDrag,\n            zoomActivationKeyPressed,\n            preventScrolling,\n            noPanClassName,\n            userSelectionActive,\n            noWheelClassName,\n            lib,\n            onTransformChange,\n            connectionInProgress,\n            selectionOnDrag,\n            paneClickDistance\n        });\n    }, [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange,\n        connectionInProgress,\n        selectionOnDrag,\n        paneClickDistance\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, paneClickDistance, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isSelectionEnabled = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onClickCapture = (event)=>{\n        if (selectionInProgress.current) {\n            event.stopPropagation();\n            selectionInProgress.current = false;\n        }\n    };\n    // We are using capture here in order to prevent other pointer events\n    // to be able to create a selection above a node or an edge\n    const onPointerDownCapture = (event)=>{\n        const { domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!containerBounds.current) return;\n        const eventTargetIsContainer = event.target === container.current;\n        // if a child element has the 'nokey' class, we don't want to swallow the event and don't start a selection\n        const isNoKeyEvent = !eventTargetIsContainer && !!event.target.closest(\".nokey\");\n        const isSelectionActive = selectionOnDrag && eventTargetIsContainer || selectionKeyPressed;\n        if (isNoKeyEvent || !isSelecting || !isSelectionActive || event.button !== 0 || !event.isPrimary) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        if (!eventTargetIsContainer) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions, resetSelectedElements } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        if (!selectionInProgress.current) {\n            const requiredDistance = selectionKeyPressed ? 0 : paneClickDistance;\n            const distance = Math.hypot(mouseX - startX, mouseY - startY);\n            if (distance <= requiredDistance) {\n                return;\n            }\n            resetSelectedElements();\n            onSelectionStart?.(event);\n        }\n        selectionInProgress.current = true;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && event.target === container.current && store.getState().userSelectionRect) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null\n        });\n        if (selectionInProgress.current) {\n            onSelectionEnd?.(event);\n            store.setState({\n                nodesSelectionActive: selectedNodeIds.current.size > 0\n            });\n        }\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__pane\",\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: isSelectionEnabled ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: isSelectionEnabled ? undefined : onPaneMouseEnter,\n        onPointerMove: isSelectionEnabled ? onPointerMove : onPaneMouseMove,\n        onPointerUp: isSelectionEnabled ? onPointerUp : undefined,\n        onPointerDownCapture: isSelectionEnabled ? onPointerDownCapture : undefined,\n        onClickCapture: isSelectionEnabled ? onClickCapture : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.(\"012\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error012\"](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n            getStoreItems: ()=>store.getState(),\n            onNodeMouseDown: (id)=>{\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef\n                });\n            },\n            onDragStart: ()=>{\n                setDragging(true);\n            },\n            onDragStop: ()=>{\n                setDragging(false);\n            }\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (disabled) {\n            xyDrag.current?.destroy();\n        } else if (nodeRef.current) {\n            xyDrag.current?.update({\n                noDragClassName,\n                handleSelector,\n                domNode: nodeRef.current,\n                isSelectable,\n                nodeId,\n                nodeClickDistance\n            });\n            return ()=>{\n                xyDrag.current?.destroy();\n            };\n        }\n    }, [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\");\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((params)=>{\n        const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n        const nodeUpdates = new Map();\n        const isSelected = selectedAndDraggable(nodesDraggable);\n        /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const xDiff = params.direction.x * xVelo * params.factor;\n        const yDiff = params.direction.y * yVelo * params.factor;\n        for (const [, node] of nodeLookup){\n            if (!isSelected(node)) {\n                continue;\n            }\n            let nextPosition = {\n                x: node.internals.positionAbsolute.x + xDiff,\n                y: node.internals.positionAbsolute.y + yDiff\n            };\n            if (snapToGrid) {\n                nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n            }\n            const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                nodeId: node.id,\n                nextPosition,\n                nodeLookup,\n                nodeExtent,\n                nodeOrigin,\n                onError\n            });\n            node.position = position;\n            node.internals.positionAbsolute = positionAbsolute;\n            nodeUpdates.set(node.id, node);\n        }\n        updateNodePositions(nodeUpdates);\n    }, []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = \"source\", position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === \"target\";\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.(\"010\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error010\"]());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                handleDomNode: event.currentTarget,\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed,\n                dragThreshold: currentStore.connectionDragThreshold\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__handle\",\n            `react-flow__handle-${position}`,\n            \"nodrag\",\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__nodesselection\",\n            \"react-flow__container\",\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        selectionOnDrag: _selectionOnDrag,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            paneClickDistance: paneClickDistance,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = \"FlowRenderer\";\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        if (typeof ResizeObserver === \"undefined\") {\n            return null;\n        }\n        return new ResizeObserver((entries)=>{\n            const updates = new Map();\n            entries.forEach((entry)=>{\n                const id = entry.target.getAttribute(\"data-id\");\n                updates.set(id, {\n                    id,\n                    nodeElement: entry.target,\n                    force: true\n                });\n            });\n            updateNodeInternals(updates);\n        });\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            resizeObserver?.disconnect();\n        };\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n            }\n            resizeObserver?.observe(nodeRef.current);\n            observedNode.current = nodeRef.current;\n        }\n    }, [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n                observedNode.current = null;\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current) {\n            /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n            const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n            if (typeChanged || sourcePosChanged || targetPosChanged) {\n                prevType.current = nodeType;\n                prevSourcePosition.current = node.sourcePosition;\n                prevTargetPosition.current = node.targetPosition;\n                store.getState().updateNodeInternals(new Map([\n                    [\n                        node.id,\n                        {\n                            id: node.id,\n                            nodeElement: nodeRef.current,\n                            force: true\n                        }\n                    ]\n                ]));\n            }\n        }\n    }, [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore((s)=>{\n        const node = s.nodeLookup.get(id);\n        const isParent = s.parentLookup.has(id);\n        return {\n            node,\n            internals: node.internals,\n            isParent\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || \"default\";\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.(\"003\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error003\"](nodeType));\n        nodeType = \"default\";\n        NodeComponent = nodeTypes?.[\"default\"] || builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === \"undefined\");\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === \"undefined\");\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === \"undefined\");\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === \"undefined\");\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === \"Escape\";\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig[\"node.a11yDescription.ariaLiveMessage\"]({\n                    direction: event.key.replace(\"Arrow\", \"\").toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(\":focus-visible\")) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__node\",\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? \"all\" : \"none\",\n            visibility: hasDimensions ? \"visible\" : \"hidden\",\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? \"group\" : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nvar NodeWrapper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeWrapper);\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, its designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when youre dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs  and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once  instead of once per node.\n             * - Any operations that youd normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized  so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper$1, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = \"NodeRenderer\";\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        if (!onlyRenderVisible) {\n            return s.edges.map((edge)=>edge.id);\n        }\n        const visibleEdgeIds = [];\n        if (s.width && s.height) {\n            for (const edge of s.edges){\n                const sourceNode = s.nodeLookup.get(edge.source);\n                const targetNode = s.nodeLookup.get(edge.target);\n                if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                    sourceNode,\n                    targetNode,\n                    width: s.width,\n                    height: s.height,\n                    transform: s.transform\n                })) {\n                    visibleEdgeIds.push(edge.id);\n                }\n            }\n        }\n        return visibleEdgeIds;\n    }, [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrow\",\n        style: style,\n        strokeLinecap: \"round\",\n        fill: \"none\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color,\n            fill: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrowclosed\",\n        style: style,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.(\"009\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error009\"](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = \"strokeWidth\", strokeWidth, orient = \"auto-start-reverse\" })=>{\n    const Symbol1 = useMarkerSymbol(type);\n    if (!Symbol1) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol1, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore((s)=>s.edges);\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n            id: rfId,\n            defaultColor,\n            defaultMarkerStart: defaultEdgeOptions?.markerStart,\n            defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n        });\n        return markers;\n    }, [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = \"MarkerDefinitions\";\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        \"react-flow__edge-textwrapper\",\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (edgeTextRef.current) {\n            const textBbox = edgeTextRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height\n            });\n        }\n    }, [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? \"visible\" : \"hidden\",\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = \"EdgeText\";\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    \"react-flow__edge-path\",\n                    props.className\n                ])\n            }),\n            interactionWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }) : null,\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = \"SimpleBezierEdge\";\nSimpleBezierEdgeInternal.displayName = \"SimpleBezierEdgeInternal\";\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset,\n            stepPosition: pathOptions?.stepPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = \"SmoothStepEdge\";\nSmoothStepEdgeInternal.displayName = \"SmoothStepEdgeInternal\";\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n                    borderRadius: 0,\n                    offset: props.pathOptions?.offset\n                }), [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = \"StepEdge\";\nStepEdgeInternal.displayName = \"StepEdgeInternal\";\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = \"StraightEdge\";\nStraightEdgeInternal.displayName = \"StraightEdgeInternal\";\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = \"BezierEdge\";\nBezierEdgeInternal.displayName = \"BezierEdgeInternal\";\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = \"react-flow__edgeupdater\";\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === \"target\";\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        const _onConnectStart = (_event, params)=>{\n            setReconnecting(true);\n            onReconnectStart?.(event, edge, oppositeHandle.type);\n            onConnectStart?.(_event, params);\n        };\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart: _onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle,\n            dragThreshold: store.getState().connectionDragThreshold,\n            handleDomNode: event.currentTarget\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: \"target\"\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: \"source\"\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === \"source\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === \"target\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore((s)=>s.edgeLookup.get(id));\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || \"default\";\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.(\"011\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error011\"](edgeType));\n        edgeType = \"default\";\n        EdgeComponent = edgeTypes?.[\"default\"] || builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === \"undefined\");\n    const isReconnectable = typeof onReconnect !== \"undefined\" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === \"undefined\");\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === \"undefined\");\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((store)=>{\n        const sourceNode = store.nodeLookup.get(edge.source);\n        const targetNode = store.nodeLookup.get(edge.target);\n        if (!sourceNode || !targetNode) {\n            return {\n                zIndex: edge.zIndex,\n                ...nullPosition\n            };\n        }\n        const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n            id,\n            sourceNode,\n            targetNode,\n            sourceHandle: edge.sourceHandle || null,\n            targetHandle: edge.targetHandle || null,\n            connectionMode: store.connectionMode,\n            onError\n        });\n        const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n            selected: edge.selected,\n            zIndex: edge.zIndex,\n            sourceNode,\n            targetNode,\n            elevateOnSelect: store.elevateEdgesOnSelect,\n            zIndexMode: store.zIndexMode\n        });\n        return {\n            zIndex,\n            ...edgePosition || nullPosition\n        };\n    }, [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined, [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined, [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === \"Escape\";\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge\",\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? \"group\" : \"img\"),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: \"pathOptions\" in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nvar EdgeWrapper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeWrapper);\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper$1, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = \"EdgeRenderer\";\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(()=>onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (viewport) {\n            syncViewport?.(viewport);\n            store.setState({\n                transform: [\n                    viewport.x,\n                    viewport.y,\n                    viewport.zoom\n                ]\n            });\n        }\n    }, [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__connection\",\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition, pointer } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle,\n            pointer: pointer\n        });\n    }\n    let path = \"\";\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = \"ConnectionLine\";\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            const usedKeys = new Set([\n                ...Object.keys(typesRef.current),\n                ...Object.keys(nodeOrEdgeTypes)\n            ]);\n            for (const key of usedKeys){\n                if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                    store.getState().onError?.(\"002\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error002\"]());\n                    break;\n                }\n            }\n            typesRef.current = nodeOrEdgeTypes;\n        }\n    }, [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            if (!checked.current) {\n                const pane = document.querySelector(\".react-flow__pane\");\n                if (pane && !(window.getComputedStyle(pane).zIndex === \"1\")) {\n                    store.getState().onError?.(\"013\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error013\"](\"react\"));\n                }\n                checked.current = true;\n            }\n        }\n    }, []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = \"GraphView\";\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent, zIndexMode = \"basic\" } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        zIndexMode\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: \"1\",\n        width: width ?? 0,\n        height: height ?? 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: \"nopan\",\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        connectionDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: true,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: \"\",\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: \"react\",\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig,\n        zIndexMode,\n        onNodesChangeMiddlewareMap: new Map(),\n        onEdgesChangeMiddlewareMap: new Map()\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges,\n                zIndexMode\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued, zIndexMode } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true,\n                    zIndexMode\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued, zIndexMode } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, zIndexMode);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    zIndexMode\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                let changes = [];\n                const { nodeLookup, triggerNodeChanges, connection, updateConnection, onNodesChangeMiddlewareMap } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: \"position\",\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (node && connection.inProgress && connection.fromNode.id === node.id) {\n                        const updatedFrom = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHandlePosition)(node, connection.fromHandle, _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left, true);\n                        updateConnection({\n                            ...connection,\n                            from: updatedFrom\n                        });\n                    }\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                for (const middleware of onNodesChangeMiddlewareMap.values()){\n                    changes = middleware(changes);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger edge changes\", changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent, zIndexMode } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false,\n                    zIndexMode\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== \"undefined\" ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, zIndexMode, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createStore({\n            nodes,\n            edges,\n            defaultNodes,\n            defaultEdges,\n            width,\n            height,\n            fitView,\n            minZoom,\n            maxZoom,\n            fitViewOptions,\n            nodeOrigin,\n            nodeExtent,\n            zIndexMode\n        }));\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        zIndexMode: zIndexMode,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = \"Backspace\", selectionKeyCode = \"Shift\", selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = \"Space\", multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = \"#b1b1b7\", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 1, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = \"nodrag\", noWheelClassName = \"nowheel\", noPanClassName = \"nopan\", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = \"light\", debug, onScroll, ariaLabelConfig, zIndexMode = \"basic\", ...rest }, ref) {\n    const rfId = id || \"1\";\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        e.currentTarget.scrollTo({\n            top: 0,\n            left: 0,\n            behavior: \"instant\"\n        });\n        onScroll?.(e);\n    }, [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow\",\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            zIndexMode: zIndexMode,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    connectionDragThreshold: connectionDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig,\n                    zIndexMode: zIndexMode\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector(\".react-flow__edgelabel-renderer\");\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector(\".react-flow__viewport-portal\");\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        const { domNode, updateNodeInternals } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [\n            id\n        ];\n        const updates = new Map();\n        updateIds.forEach((updateId)=>{\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                updates.set(updateId, {\n                    id: updateId,\n                    nodeElement,\n                    force: true\n                });\n            }\n        });\n        requestAnimationFrame(()=>updateNodeInternals(updates, {\n                triggerFitView: false\n            }));\n    }, []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setNodes((nds)=>applyNodeChanges(changes, nds)), []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setEdges((eds)=>applyEdgeChanges(changes, eds)), []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeStart: onStart\n        });\n    }, [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChange: onChange\n        });\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeEnd: onEnd\n        });\n    }, [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const nextOnSelectionChangeHandlers = [\n            ...store.getState().onSelectionChangeHandlers,\n            onChange\n        ];\n        store.setState({\n            onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n        });\n        return ()=>{\n            const nextHandlers = store.getState().onSelectionChangeHandlers.filter((fn)=>fn !== onChange);\n            store.setState({\n                onSelectionChangeHandlers: nextHandlers\n            });\n        };\n    }, [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn(\"[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections\");\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error014\"]();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        const data = [];\n        const isArrayOfIds = Array.isArray(nodeIds);\n        const _nodeIds = isArrayOfIds ? nodeIds : [\n            nodeIds\n        ];\n        for (const nodeId of _nodeIds){\n            const node = s.nodeLookup.get(nodeId);\n            if (node) {\n                data.push({\n                    id: node.id,\n                    type: node.type,\n                    data: node.data\n                });\n            }\n        }\n        return isArrayOfIds ? data : data[0] ?? null;\n    }, [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>s.nodeLookup.get(id), [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\n/**\n * Registers a middleware function to transform node changes.\n *\n * @public\n * @param fn - Middleware function. Should be memoized with useCallback to avoid re-registration.\n */ function experimental_useOnNodesChangeMiddleware(fn) {\n    const store = useStoreApi();\n    const [symbol] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>Symbol());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onNodesChangeMiddlewareMap } = store.getState();\n        onNodesChangeMiddlewareMap.set(symbol, fn);\n    }, [\n        fn\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onNodesChangeMiddlewareMap } = store.getState();\n        return ()=>{\n            onNodesChangeMiddlewareMap.delete(symbol);\n        };\n    }, []);\n}\n/**\n * Registers a middleware function to transform edge changes.\n *\n * @public\n * @param fn - Middleware function. Should be memoized with useCallback to avoid re-registration.\n */ function experimental_useOnEdgesChangeMiddleware(fn) {\n    const store = useStoreApi();\n    const [symbol] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>Symbol());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onEdgesChangeMiddlewareMap } = store.getState();\n        onEdgesChangeMiddlewareMap.set(symbol, fn);\n    }, [\n        fn\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onEdgesChangeMiddlewareMap } = store.getState();\n        return ()=>{\n            onEdgesChangeMiddlewareMap.delete(symbol);\n        };\n    }, []);\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            \"dots\",\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : \"\"}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background\",\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            \"--xy-background-color-props\": bgColor,\n            \"--xy-background-pattern-color-props\": color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = \"Background\";\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components its important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls-button\",\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = \"bottom-left\", orientation = \"vertical\", \"aria-label\": ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === \"horizontal\" ? \"horizontal\" : \"vertical\";\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls\",\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig[\"controls.ariaLabel\"],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = \"Controls\";\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap-node\",\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? \"crispEdges\" : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, its designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore((s)=>{\n        const { internals } = s.nodeLookup.get(id);\n        const node = internals.userNode;\n        const { x, y } = internals.positionAbsolute;\n        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n        return {\n            node,\n            x,\n            y,\n            width,\n            height\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = \"react-flow__minimap-desc\";\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = \"bottom-right\", onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 1, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (svg.current && panZoom) {\n            minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                domNode: svg.current,\n                panZoom,\n                getTransform: ()=>store.getState().transform,\n                getViewScale: ()=>viewScaleRef.current\n            });\n            return ()=>{\n                minimapInstance.current?.destroy();\n            };\n        }\n    }, [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        minimapInstance.current?.update({\n            translateExtent,\n            width: flowWidth,\n            height: flowHeight,\n            inversePan,\n            pannable,\n            zoomStep,\n            zoomable\n        });\n    }, [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event, nodeId)=>{\n        const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n        onNodeClick(event, node);\n    }, []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig[\"minimap.ariaLabel\"];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            \"--xy-minimap-background-color-props\": typeof bgColor === \"string\" ? bgColor : undefined,\n            \"--xy-minimap-mask-background-color-props\": typeof maskColor === \"string\" ? maskColor : undefined,\n            \"--xy-minimap-mask-stroke-color-props\": typeof maskStrokeColor === \"string\" ? maskStrokeColor : undefined,\n            \"--xy-minimap-mask-stroke-width-props\": typeof maskStrokeWidth === \"number\" ? maskStrokeWidth * viewScale : undefined,\n            \"--xy-minimap-node-background-color-props\": typeof nodeColor === \"string\" ? nodeColor : undefined,\n            \"--xy-minimap-node-stroke-color-props\": typeof nodeStrokeColor === \"string\" ? nodeStrokeColor : undefined,\n            \"--xy-minimap-node-stroke-width-props\": typeof nodeStrokeWidth === \"number\" ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap\",\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = \"MiniMap\";\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: \"right\",\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: \"bottom-right\"\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === \"string\" ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        if (!resizer.current) {\n            resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                domNode: resizeControlRef.current,\n                nodeId: id,\n                getStoreItems: ()=>{\n                    const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                    return {\n                        nodeLookup,\n                        transform,\n                        snapGrid,\n                        snapToGrid,\n                        nodeOrigin,\n                        paneDomNode: domNode\n                    };\n                },\n                onChange: (change, childChanges)=>{\n                    const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                    const changes = [];\n                    const nextPosition = {\n                        x: change.x,\n                        y: change.y\n                    };\n                    const node = nodeLookup.get(id);\n                    if (node && node.expandParent && node.parentId) {\n                        const origin = node.origin ?? nodeOrigin;\n                        const width = change.width ?? node.measured.width ?? 0;\n                        const height = change.height ?? node.measured.height ?? 0;\n                        const child = {\n                            id: node.id,\n                            parentId: node.parentId,\n                            rect: {\n                                width,\n                                height,\n                                ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                    x: change.x ?? node.position.x,\n                                    y: change.y ?? node.position.y\n                                }, {\n                                    width,\n                                    height\n                                }, node.parentId, nodeLookup, origin)\n                            }\n                        };\n                        const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                            child\n                        ], nodeLookup, parentLookup, nodeOrigin);\n                        changes.push(...parentExpandChanges);\n                        /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                        nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                    }\n                    if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                        const positionChange = {\n                            id,\n                            type: \"position\",\n                            position: {\n                                ...nextPosition\n                            }\n                        };\n                        changes.push(positionChange);\n                    }\n                    if (change.width !== undefined && change.height !== undefined) {\n                        const setAttributes = !resizeDirection ? true : resizeDirection === \"horizontal\" ? \"width\" : \"height\";\n                        const dimensionChange = {\n                            id,\n                            type: \"dimensions\",\n                            resizing: true,\n                            setAttributes,\n                            dimensions: {\n                                width: change.width,\n                                height: change.height\n                            }\n                        };\n                        changes.push(dimensionChange);\n                    }\n                    for (const childChange of childChanges){\n                        const positionChange = {\n                            ...childChange,\n                            type: \"position\"\n                        };\n                        changes.push(positionChange);\n                    }\n                    triggerNodeChanges(changes);\n                },\n                onEnd: ({ width, height })=>{\n                    const dimensionChange = {\n                        id: id,\n                        type: \"dimensions\",\n                        resizing: false,\n                        dimensions: {\n                            width,\n                            height\n                        }\n                    };\n                    store.getState().triggerNodeChanges([\n                        dimensionChange\n                    ]);\n                }\n            });\n        }\n        resizer.current.update({\n            controlPosition,\n            boundaries: {\n                minWidth,\n                minHeight,\n                maxWidth,\n                maxHeight\n            },\n            keepAspectRatio,\n            resizeDirection,\n            onResizeStart,\n            onResize,\n            onResizeEnd,\n            shouldResize\n        });\n        return ()=>{\n            resizer.current?.destroy();\n        };\n    }, [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__resize-control\",\n            \"nodrag\",\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? \"backgroundColor\" : \"borderColor\"]: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector(\".react-flow__renderer\");\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = \"center\", ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>{\n        const nodeIds = Array.isArray(nodeId) ? nodeId : [\n            nodeId || contextNodeId || \"\"\n        ];\n        const internalNodes = nodeIds.reduce((res, id)=>{\n            const node = state.nodeLookup.get(id);\n            if (node) {\n                res.set(node.id, node);\n            }\n            return res;\n        }, new Map());\n        return internalNodes;\n    }, [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: \"absolute\",\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__node-toolbar\",\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, \"\").trim(),\n            children: children\n        })\n    });\n}\nconst zoomSelector = (state)=>state.transform[2];\n/**\n * This component can render a toolbar or tooltip to one side of a custom edge. This\n * toolbar doesn't scale with the viewport so that the content stays the same size.\n *\n * @public\n * @example\n * ```jsx\n * import { EdgeToolbar, BaseEdge, getBezierPath, type EdgeProps } from \"@xyflow/react\";\n *\n * export function CustomEdge({ id, data, ...props }: EdgeProps) {\n *   const [edgePath, centerX, centerY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeToolbar edgeId={id} x={centerX} y={centerY} isVisible>\n *         <button onClick={() => console.log('edge', id, 'click')}}>Click me</button>\n *       </EdgeToolbar>\n *     </>\n *   );\n * }\n * ```\n */ function EdgeToolbar({ edgeId, x, y, children, className, style, isVisible, alignX = \"center\", alignY = \"center\", ...rest }) {\n    const edgeSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>state.edgeLookup.get(edgeId), [\n        edgeId\n    ]);\n    const edge = useStore(edgeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : edge?.selected;\n    const zoom = useStore(zoomSelector);\n    if (!isActive) {\n        return null;\n    }\n    const zIndex = (edge?.zIndex ?? 0) + 1;\n    const transform = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeToolbarTransform)(x, y, zoom, alignX, alignY);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeLabelRenderer, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: {\n                position: \"absolute\",\n                transform,\n                zIndex,\n                pointerEvents: \"all\",\n                transformOrigin: \"0 0\",\n                ...style\n            },\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge-toolbar\",\n                className\n            ]),\n            \"data-id\": edge?.id ?? \"\",\n            ...rest,\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crcmVhY3RAMTIuMTAuMF9AdHlwZXMrcmVhY3RAMTguMy4yN19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0aENBQ3dEO0FBQ2dGO0FBQzlHO0FBQzh1QztBQUN0N0I7QUFDL1A7QUFDekM7QUFDRDtBQUV6QyxNQUFNK0YsNkJBQWU1RixvREFBYUEsQ0FBQztBQUNuQyxNQUFNNkYsYUFBYUQsYUFBYUUsUUFBUTtBQUV4QyxNQUFNQyxzQkFBc0JwRix5REFBYSxDQUFDLFdBQVc7QUFDckQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxTQUFTcUYsU0FBU0MsUUFBUSxFQUFFQyxVQUFVO0lBQ2xDLE1BQU1DLFFBQVFsRyxpREFBVUEsQ0FBQzJGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBT1AsMkVBQXNCQSxDQUFDVyxPQUFPRixVQUFVQztBQUNuRDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNHO0lBQ0wsTUFBTUYsUUFBUWxHLGlEQUFVQSxDQUFDMkY7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPN0YsOENBQU9BLENBQUMsSUFBTztZQUNsQm9HLFVBQVVILE1BQU1HLFFBQVE7WUFDeEJDLFVBQVVKLE1BQU1JLFFBQVE7WUFDeEJDLFdBQVdMLE1BQU1LLFNBQVM7UUFDOUIsSUFBSTtRQUFDTDtLQUFNO0FBQ2Y7QUFFQSxNQUFNTSxRQUFRO0lBQUVDLFNBQVM7QUFBTztB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QUFHdnBDLE1BQU07SUFDdkgsTUFBTXdwQyxlQUFlcnhDLGtEQUFXQSxDQUFDLENBQUNtbUIsUUFBVUEsTUFBTWpkLFVBQVUsQ0FBQ3dLLEdBQUcsQ0FBQzJQLFNBQVM7UUFBQ0E7S0FBTztJQUNsRixNQUFNcGEsT0FBT3pELFNBQVM2ckMsY0FBY25zQyxvREFBT0E7SUFDM0MsTUFBTTJhLFdBQVcsT0FBT213QixjQUFjLFlBQVlBLFlBQVkvbUMsTUFBTUo7SUFDcEUsTUFBTTJCLE9BQU9oRixTQUFTeXJDO0lBQ3RCLElBQUksQ0FBQ3B4QixVQUFVO1FBQ1gsT0FBTztJQUNYO0lBQ0EsTUFBTTZRLFNBQVMsQ0FBQ3puQixNQUFNeW5CLFVBQVUsS0FBSztJQUNyQyxNQUFNcmYsWUFBWTNNLHVFQUF1QkEsQ0FBQzRGLEdBQUdDLEdBQUdDLE1BQU0ybUMsUUFBUUM7SUFDOUQsT0FBUTd4QyxzREFBR0EsQ0FBQ3NrQyxtQkFBbUI7UUFBRXI4QixVQUFVakksc0RBQUdBLENBQUMsT0FBTztZQUFFMEcsT0FBTztnQkFDbkRHLFVBQVU7Z0JBQ1ZpTDtnQkFDQXFmO2dCQUNBRSxlQUFlO2dCQUNmMGdCLGlCQUFpQjtnQkFDakIsR0FBR3JyQyxLQUFLO1lBQ1o7WUFBRzJCLFdBQVcxSCxvREFBRUEsQ0FBQztnQkFBQztnQkFBNEIwSDthQUFVO1lBQUcsV0FBV3FCLE1BQU0xQixNQUFNO1lBQUksR0FBR00sSUFBSTtZQUFFTCxVQUFVQTtRQUFTO0lBQUc7QUFDakk7QUFFNHdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHJlcG8vZGV2LWNvbnNvbGUvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crcmVhY3RAMTIuMTAuMF9AdHlwZXMrcmVhY3RAMTguMy4yN19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3QvZXNtL2luZGV4LmpzP2Q4M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IGpzeHMsIEZyYWdtZW50LCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlcywgbWVyZ2VBcmlhTGFiZWxDb25maWcsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCB3aXRoUmVzb2x2ZXJzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGdldERpbWVuc2lvbnMsIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgYXJlU2V0c0VxdWFsLCBYWURyYWcsIHNuYXBQb3NpdGlvbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBQb3NpdGlvbiwgQ29ubmVjdGlvbk1vZGUsIGlzTW91c2VFdmVudCwgWFlIYW5kbGUsIGdldEhvc3RGb3JFbGVtZW50LCBhZGRFZGdlLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBpc051bWVyaWMsIG5vZGVIYXNEaW1lbnNpb25zLCBnZXROb2RlRGltZW5zaW9ucywgZWxlbWVudFNlbGVjdGlvbktleXMsIGlzRWRnZVZpc2libGUsIE1hcmtlclR5cGUsIGNyZWF0ZU1hcmtlcklkcywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0QmV6aWVyUGF0aCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldE1hcmtlcklkLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBDb25uZWN0aW9uTGluZVR5cGUsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIGFkb3B0VXNlck5vZGVzLCBpbml0aWFsQ29ubmVjdGlvbiwgZGV2V2FybiwgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgdXBkYXRlTm9kZUludGVybmFscywgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIGdldEhhbmRsZVBvc2l0aW9uLCBoYW5kbGVFeHBhbmRQYXJlbnQsIHBhbkJ5LCBmaXRWaWV3cG9ydCwgaXNNYWNPcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgc2hhbGxvd05vZGVEYXRhLCBYWU1pbmltYXAsIGdldEJvdW5kc09mUmVjdHMsIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBYWVJlc2l6ZXIsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUywgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0sIGdldEVkZ2VUb29sYmFyVHJhbnNmb3JtIH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuZXhwb3J0IHsgQ29ubmVjdGlvbkxpbmVUeXBlLCBDb25uZWN0aW9uTW9kZSwgTWFya2VyVHlwZSwgUGFuT25TY3JvbGxNb2RlLCBQb3NpdGlvbiwgUmVzaXplQ29udHJvbFZhcmlhbnQsIFNlbGVjdGlvbk1vZGUsIGFkZEVkZ2UsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldEJlemllclBhdGgsIGdldENvbm5lY3RlZEVkZ2VzLCBnZXRFZGdlQ2VudGVyLCBnZXRJbmNvbWVycywgZ2V0Tm9kZXNCb3VuZHMsIGdldE91dGdvZXJzLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRWaWV3cG9ydEZvckJvdW5kcywgcmVjb25uZWN0RWRnZSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmltcG9ydCB7IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4sIGNyZWF0ZVdpdGhFcXVhbGl0eUZuIH0gZnJvbSAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciQxID0gU3RvcmVDb250ZXh0LlByb3ZpZGVyO1xuXG5jb25zdCB6dXN0YW5kRXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMDEnXSgpO1xuLyoqXG4gKiBUaGlzIGhvb2sgY2FuIGJlIHVzZWQgdG8gc3Vic2NyaWJlIHRvIGludGVybmFsIHN0YXRlIGNoYW5nZXMgb2YgdGhlIFJlYWN0IEZsb3dcbiAqIGNvbXBvbmVudC4gVGhlIGB1c2VTdG9yZWAgaG9vayBpcyByZS1leHBvcnRlZCBmcm9tIHRoZSBbWnVzdGFuZF0oaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy96dXN0YW5kKVxuICogc3RhdGUgbWFuYWdlbWVudCBsaWJyYXJ5LCBzbyB5b3Ugc2hvdWxkIGNoZWNrIG91dCB0aGVpciBkb2NzIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHNlbGVjdG9yIC0gQSBzZWxlY3RvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzbGljZSBvZiB0aGUgZmxvdydzIGludGVybmFsIHN0YXRlLlxuICogRXh0cmFjdGluZyBvciB0cmFuc2Zvcm1pbmcganVzdCB0aGUgc3RhdGUgeW91IG5lZWQgaXMgYSBnb29kIHByYWN0aWNlIHRvIGF2b2lkIHVubmVjZXNzYXJ5XG4gKiByZS1yZW5kZXJzLlxuICogQHBhcmFtIGVxdWFsaXR5Rm4gLSBBIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHZhbHVlLiBUaGlzIGlzIGluY3JlZGlibHkgdXNlZnVsXG4gKiBmb3IgcHJldmVudGluZyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzLiBHb29kIHNlbnNpYmxlIGRlZmF1bHRzIGFyZSB1c2luZyBgT2JqZWN0LmlzYCBvciBpbXBvcnRpbmdcbiAqIGB6dXN0YW5kL3NoYWxsb3dgLCBidXQgeW91IGNhbiBiZSBhcyBncmFudWxhciBhcyB5b3UgbGlrZS5cbiAqIEByZXR1cm5zIFRoZSBzZWxlY3RlZCBzdGF0ZSBzbGljZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5ub2Rlcyk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgc2hvdWxkIG9ubHkgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBvdGhlciB3YXkgdG8gYWNjZXNzIHRoZSBpbnRlcm5hbFxuICogc3RhdGUuIEZvciBtYW55IG9mIHRoZSBjb21tb24gdXNlIGNhc2VzLCB0aGVyZSBhcmUgZGVkaWNhdGVkIGhvb2tzIGF2YWlsYWJsZVxuICogc3VjaCBhcyB7QGxpbmsgdXNlUmVhY3RGbG93fSwge0BsaW5rIHVzZVZpZXdwb3J0fSwgZXRjLlxuICovXG5mdW5jdGlvbiB1c2VTdG9yZShzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuKHN0b3JlLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG4vKipcbiAqIEluIHNvbWUgY2FzZXMsIHlvdSBtaWdodCBuZWVkIHRvIGFjY2VzcyB0aGUgc3RvcmUgZGlyZWN0bHkuIFRoaXMgaG9vayByZXR1cm5zIHRoZSBzdG9yZSBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgb24gZGVtYW5kIHRvIGFjY2VzcyB0aGUgc3RhdGUgb3IgZGlzcGF0Y2ggYWN0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RvcmUgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgc2hvdWxkIG9ubHkgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBvdGhlciB3YXkgdG8gYWNjZXNzIHRoZSBpbnRlcm5hbFxuICogc3RhdGUuIEZvciBtYW55IG9mIHRoZSBjb21tb24gdXNlIGNhc2VzLCB0aGVyZSBhcmUgZGVkaWNhdGVkIGhvb2tzIGF2YWlsYWJsZVxuICogc3VjaCBhcyB7QGxpbmsgdXNlUmVhY3RGbG93fSwge0BsaW5rIHVzZVZpZXdwb3J0fSwgZXRjLlxuICovXG5mdW5jdGlvbiB1c2VTdG9yZUFwaSgpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIHNldFN0YXRlOiBzdG9yZS5zZXRTdGF0ZSxcbiAgICAgICAgc3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUsXG4gICAgfSksIFtzdG9yZV0pO1xufVxuXG5jb25zdCBzdHlsZSA9IHsgZGlzcGxheTogJ25vbmUnIH07XG5jb25zdCBhcmlhTGl2ZVN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBtYXJnaW46IC0xLFxuICAgIGJvcmRlcjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBjbGlwOiAncmVjdCgwcHgsIDBweCwgMHB4LCAwcHgpJyxcbiAgICBjbGlwUGF0aDogJ2luc2V0KDEwMCUpJyxcbn07XG5jb25zdCBBUklBX05PREVfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fbm9kZS1kZXNjJztcbmNvbnN0IEFSSUFfRURHRV9ERVNDX0tFWSA9ICdyZWFjdC1mbG93X19lZGdlLWRlc2MnO1xuY29uc3QgQVJJQV9MSVZFX01FU1NBR0UgPSAncmVhY3QtZmxvd19fYXJpYS1saXZlJztcbmNvbnN0IGFyaWFMaXZlU2VsZWN0b3IgPSAocykgPT4gcy5hcmlhTGl2ZU1lc3NhZ2U7XG5jb25zdCBhcmlhTGFiZWxDb25maWdTZWxlY3RvciA9IChzKSA9PiBzLmFyaWFMYWJlbENvbmZpZztcbmZ1bmN0aW9uIEFyaWFMaXZlTWVzc2FnZSh7IHJmSWQgfSkge1xuICAgIGNvbnN0IGFyaWFMaXZlTWVzc2FnZSA9IHVzZVN0b3JlKGFyaWFMaXZlU2VsZWN0b3IpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTElWRV9NRVNTQUdFfS0ke3JmSWR9YCwgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IGFyaWFMaXZlU3R5bGUsIGNoaWxkcmVuOiBhcmlhTGl2ZU1lc3NhZ2UgfSkpO1xufVxuZnVuY3Rpb24gQTExeURlc2NyaXB0aW9ucyh7IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXkgfSkge1xuICAgIGNvbnN0IGFyaWFMYWJlbENvbmZpZyA9IHVzZVN0b3JlKGFyaWFMYWJlbENvbmZpZ1NlbGVjdG9yKTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogZGlzYWJsZUtleWJvYXJkQTExeVxuICAgICAgICAgICAgICAgICAgICA/IGFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCddXG4gICAgICAgICAgICAgICAgICAgIDogYXJpYUxhYmVsQ29uZmlnWydub2RlLmExMXlEZXNjcmlwdGlvbi5rZXlib2FyZERpc2FibGVkJ10gfSksIGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBhcmlhTGFiZWxDb25maWdbJ2VkZ2UuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnXSB9KSwgIWRpc2FibGVLZXlib2FyZEExMXkgJiYganN4KEFyaWFMaXZlTWVzc2FnZSwgeyByZklkOiByZklkIH0pXSB9KSk7XG59XG5cbi8qKlxuICogVGhlIGA8UGFuZWwgLz5gIGNvbXBvbmVudCBoZWxwcyB5b3UgcG9zaXRpb24gY29udGVudCBhYm92ZSB0aGUgdmlld3BvcnQuXG4gKiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtgPE1pbmlNYXAgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL21pbmltYXApXG4gKiBhbmQgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgUGFuZWwgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1tdfSBmaXRWaWV3PlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtbGVmdFwiPnRvcC1sZWZ0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLWNlbnRlclwiPnRvcC1jZW50ZXI8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtcmlnaHRcIj50b3AtcmlnaHQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tbGVmdFwiPmJvdHRvbS1sZWZ0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLWNlbnRlclwiPmJvdHRvbS1jZW50ZXI8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tcmlnaHRcIj5ib3R0b20tcmlnaHQ8L1BhbmVsPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgUGFuZWwgPSBmb3J3YXJkUmVmKCh7IHBvc2l0aW9uID0gJ3RvcC1sZWZ0JywgY2hpbGRyZW4sIGNsYXNzTmFtZSwgc3R5bGUsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc2VzID0gYCR7cG9zaXRpb259YC5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmVsJywgY2xhc3NOYW1lLCAuLi5wb3NpdGlvbkNsYXNzZXNdKSwgc3R5bGU6IHN0eWxlLCByZWY6IHJlZiwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn0pO1xuUGFuZWwuZGlzcGxheU5hbWUgPSAnUGFuZWwnO1xuXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbih7IHByb09wdGlvbnMsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcgfSkge1xuICAgIGlmIChwcm9PcHRpb25zPy5oaWRlQXR0cmlidXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2F0dHJpYnV0aW9uXCIsIFwiZGF0YS1tZXNzYWdlXCI6IFwiUGxlYXNlIG9ubHkgaGlkZSB0aGlzIGF0dHJpYnV0aW9uIHdoZW4geW91IGFyZSBzdWJzY3JpYmVkIHRvIFJlYWN0IEZsb3cgUHJvOiBodHRwczovL3Byby5yZWFjdGZsb3cuZGV2XCIsIGNoaWxkcmVuOiBqc3goXCJhXCIsIHsgaHJlZjogXCJodHRwczovL3JlYWN0Zmxvdy5kZXZcIiwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLCBcImFyaWEtbGFiZWxcIjogXCJSZWFjdCBGbG93IGF0dHJpYnV0aW9uXCIsIGNoaWxkcmVuOiBcIlJlYWN0IEZsb3dcIiB9KSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJG0gPSAocykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBbXTtcbiAgICBjb25zdCBzZWxlY3RlZEVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBzLm5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKG5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMucHVzaChub2RlLmludGVybmFscy51c2VyTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCBlZGdlXSBvZiBzLmVkZ2VMb29rdXApIHtcbiAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH07XG59O1xuY29uc3Qgc2VsZWN0SWQgPSAob2JqKSA9PiBvYmouaWQ7XG5mdW5jdGlvbiBhcmVFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIChzaGFsbG93KGEuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSkgJiZcbiAgICAgICAgc2hhbGxvdyhhLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCkpKTtcbn1cbmZ1bmN0aW9uIFNlbGVjdGlvbkxpc3RlbmVySW5uZXIoeyBvblNlbGVjdGlvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJG0sIGFyZUVxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9O1xuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZT8uKHBhcmFtcyk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5mb3JFYWNoKChmbikgPT4gZm4ocGFyYW1zKSk7XG4gICAgfSwgW3NlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMsIG9uU2VsZWN0aW9uQ2hhbmdlXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBjaGFuZ2VTZWxlY3RvciA9IChzKSA9PiAhIXMub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycztcbmZ1bmN0aW9uIFNlbGVjdGlvbkxpc3RlbmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzID0gdXNlU3RvcmUoY2hhbmdlU2VsZWN0b3IpO1xuICAgIGlmIChvblNlbGVjdGlvbkNoYW5nZSB8fCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBqc3goU2VsZWN0aW9uTGlzdGVuZXJJbm5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBkZWZhdWx0Tm9kZU9yaWdpbiA9IFswLCAwXTtcbmNvbnN0IGRlZmF1bHRWaWV3cG9ydCA9IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuXG4vKlxuICogVGhpcyBjb21wb25lbnQgaGVscHMgdXMgdG8gdXBkYXRlIHRoZSBzdG9yZSB3aXRoIHRoZSB2YWx1ZXMgY29taW5nIGZyb20gdGhlIHVzZXIuXG4gKiBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIHZhbHVlcyB3ZSBjYW4gdXBkYXRlIGRpcmVjdGx5IHdpdGggYHVzZURpcmVjdFN0b3JlVXBkYXRlcmAgKGxpa2UgYHNuYXBHcmlkYClcbiAqIGFuZCB2YWx1ZXMgdGhhdCBoYXZlIGEgZGVkaWNhdGVkIHNldHRlciBmdW5jdGlvbiBpbiB0aGUgc3RvcmUgKGxpa2UgYHNldE5vZGVzYCkuXG4gKi9cbi8vIFRoZXNlIGZpZWxkcyBleGlzdCBpbiB0aGUgZ2xvYmFsIHN0b3JlLCBhbmQgd2UgbmVlZCB0byBrZWVwIHRoZW0gdXAgdG8gZGF0ZVxuY29uc3QgcmVhY3RGbG93RmllbGRzVG9UcmFjayA9IFtcbiAgICAnbm9kZXMnLFxuICAgICdlZGdlcycsXG4gICAgJ2RlZmF1bHROb2RlcycsXG4gICAgJ2RlZmF1bHRFZGdlcycsXG4gICAgJ29uQ29ubmVjdCcsXG4gICAgJ29uQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25Db25uZWN0RW5kJyxcbiAgICAnb25DbGlja0Nvbm5lY3RTdGFydCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0RW5kJyxcbiAgICAnbm9kZXNEcmFnZ2FibGUnLFxuICAgICdhdXRvUGFuT25Ob2RlRm9jdXMnLFxuICAgICdub2Rlc0Nvbm5lY3RhYmxlJyxcbiAgICAnbm9kZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzUmVjb25uZWN0YWJsZScsXG4gICAgJ2VsZXZhdGVOb2Rlc09uU2VsZWN0JyxcbiAgICAnZWxldmF0ZUVkZ2VzT25TZWxlY3QnLFxuICAgICdtaW5ab29tJyxcbiAgICAnbWF4Wm9vbScsXG4gICAgJ25vZGVFeHRlbnQnLFxuICAgICdvbk5vZGVzQ2hhbmdlJyxcbiAgICAnb25FZGdlc0NoYW5nZScsXG4gICAgJ2VsZW1lbnRzU2VsZWN0YWJsZScsXG4gICAgJ2Nvbm5lY3Rpb25Nb2RlJyxcbiAgICAnc25hcEdyaWQnLFxuICAgICdzbmFwVG9HcmlkJyxcbiAgICAndHJhbnNsYXRlRXh0ZW50JyxcbiAgICAnY29ubmVjdE9uQ2xpY2snLFxuICAgICdkZWZhdWx0RWRnZU9wdGlvbnMnLFxuICAgICdmaXRWaWV3JyxcbiAgICAnZml0Vmlld09wdGlvbnMnLFxuICAgICdvbk5vZGVzRGVsZXRlJyxcbiAgICAnb25FZGdlc0RlbGV0ZScsXG4gICAgJ29uRGVsZXRlJyxcbiAgICAnb25Ob2RlRHJhZycsXG4gICAgJ29uTm9kZURyYWdTdGFydCcsXG4gICAgJ29uTm9kZURyYWdTdG9wJyxcbiAgICAnb25TZWxlY3Rpb25EcmFnJyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RhcnQnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdG9wJyxcbiAgICAnb25Nb3ZlU3RhcnQnLFxuICAgICdvbk1vdmUnLFxuICAgICdvbk1vdmVFbmQnLFxuICAgICdub1BhbkNsYXNzTmFtZScsXG4gICAgJ25vZGVPcmlnaW4nLFxuICAgICdhdXRvUGFuT25Db25uZWN0JyxcbiAgICAnYXV0b1Bhbk9uTm9kZURyYWcnLFxuICAgICdvbkVycm9yJyxcbiAgICAnY29ubmVjdGlvblJhZGl1cycsXG4gICAgJ2lzVmFsaWRDb25uZWN0aW9uJyxcbiAgICAnc2VsZWN0Tm9kZXNPbkRyYWcnLFxuICAgICdub2RlRHJhZ1RocmVzaG9sZCcsXG4gICAgJ2Nvbm5lY3Rpb25EcmFnVGhyZXNob2xkJyxcbiAgICAnb25CZWZvcmVEZWxldGUnLFxuICAgICdkZWJ1ZycsXG4gICAgJ2F1dG9QYW5TcGVlZCcsXG4gICAgJ2FyaWFMYWJlbENvbmZpZycsXG4gICAgJ3pJbmRleE1vZGUnLFxuXTtcbi8vIHJmSWQgZG9lc24ndCBleGlzdCBpbiBSZWFjdEZsb3dQcm9wcywgYnV0IGl0J3Mgb25lIG9mIHRoZSBmaWVsZHMgd2Ugd2FudCB0byB1cGRhdGVcbmNvbnN0IGZpZWxkc1RvVHJhY2sgPSBbLi4ucmVhY3RGbG93RmllbGRzVG9UcmFjaywgJ3JmSWQnXTtcbmNvbnN0IHNlbGVjdG9yJGwgPSAocykgPT4gKHtcbiAgICBzZXROb2Rlczogcy5zZXROb2RlcyxcbiAgICBzZXRFZGdlczogcy5zZXRFZGdlcyxcbiAgICBzZXRNaW5ab29tOiBzLnNldE1pblpvb20sXG4gICAgc2V0TWF4Wm9vbTogcy5zZXRNYXhab29tLFxuICAgIHNldFRyYW5zbGF0ZUV4dGVudDogcy5zZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgc2V0Tm9kZUV4dGVudDogcy5zZXROb2RlRXh0ZW50LFxuICAgIHJlc2V0OiBzLnJlc2V0LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiBzLnNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLFxufSk7XG5jb25zdCBpbml0UHJldlZhbHVlcyA9IHtcbiAgICAvKlxuICAgICAqIHRoZXNlIGFyZSB2YWx1ZXMgdGhhdCBhcmUgYWxzbyBwYXNzZWQgZGlyZWN0bHkgdG8gb3RoZXIgY29tcG9uZW50c1xuICAgICAqIHRoYW4gdGhlIFN0b3JlVXBkYXRlci4gV2UgY2FuIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNldFN0b3JlIGNhbGxzXG4gICAgICogYnkgc2V0dGluZyB0aGUgc2FtZSB2YWx1ZXMgaGVyZSBhcyBwcmV2IGZpZWxkcy5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVFeHRlbnQ6IGluZmluaXRlRXh0ZW50LFxuICAgIG5vZGVPcmlnaW46IGRlZmF1bHROb2RlT3JpZ2luLFxuICAgIG1pblpvb206IDAuNSxcbiAgICBtYXhab29tOiAyLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICByZklkOiAnMScsXG59O1xuZnVuY3Rpb24gU3RvcmVVcGRhdGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBzZXROb2Rlcywgc2V0RWRnZXMsIHNldE1pblpvb20sIHNldE1heFpvb20sIHNldFRyYW5zbGF0ZUV4dGVudCwgc2V0Tm9kZUV4dGVudCwgcmVzZXQsIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKHByb3BzLmRlZmF1bHROb2RlcywgcHJvcHMuZGVmYXVsdEVkZ2VzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzZXQgdGhlIHN0b3JlIHdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXMgZmllbGRzXG4gICAgICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gaW5pdFByZXZWYWx1ZXM7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBwcmV2aW91c0ZpZWxkcyA9IHVzZVJlZihpbml0UHJldlZhbHVlcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZmllbGRzVG9UcmFjaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHByb3BzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkVmFsdWUgPSBwcmV2aW91c0ZpZWxkcy5jdXJyZW50W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gcHJldmlvdXNGaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tmaWVsZE5hbWVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBoYW5kbGluZyB3aXRoIGRlZGljYXRlZCBzZXR0ZXJzIGZvciBzb21lIGZpZWxkc1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVzJylcbiAgICAgICAgICAgICAgICBzZXROb2RlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2VkZ2VzJylcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21pblpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1pblpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtYXhab29tJylcbiAgICAgICAgICAgICAgICBzZXRNYXhab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHJhbnNsYXRlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdub2RlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXROb2RlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnYXJpYUxhYmVsQ29uZmlnJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGFyaWFMYWJlbENvbmZpZzogbWVyZ2VBcmlhTGFiZWxDb25maWcoZmllbGRWYWx1ZSkgfSk7XG4gICAgICAgICAgICAvLyBSZW5hbWVkIGZpZWxkc1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0VmlldycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0Vmlld09wdGlvbnMnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09wdGlvbnM6IGZpZWxkVmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBwcm9wcztcbiAgICB9LCBcbiAgICAvLyBPbmx5IHJlLXJ1biB0aGUgZWZmZWN0IGlmIG9uZSBvZiB0aGUgZmllbGRzIHdlIHRyYWNrIGNoYW5nZXNcbiAgICBmaWVsZHNUb1RyYWNrLm1hcCgoZmllbGROYW1lKSA9PiBwcm9wc1tmaWVsZE5hbWVdKSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1lZGlhUXVlcnkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG59XG4vKipcbiAqIEhvb2sgZm9yIHJlY2VpdmluZyB0aGUgY3VycmVudCBjb2xvciBtb2RlIGNsYXNzICdkYXJrJyBvciAnbGlnaHQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbG9yTW9kZSAtIFRoZSBjb2xvciBtb2RlIHRvIHVzZSAoJ2RhcmsnLCAnbGlnaHQnIG9yICdzeXN0ZW0nKVxuICovXG5mdW5jdGlvbiB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpIHtcbiAgICBjb25zdCBbY29sb3JNb2RlQ2xhc3MsIHNldENvbG9yTW9kZUNsYXNzXSA9IHVzZVN0YXRlKGNvbG9yTW9kZSA9PT0gJ3N5c3RlbScgPyBudWxsIDogY29sb3JNb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29sb3JNb2RlICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgc2V0Q29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gZ2V0TWVkaWFRdWVyeSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb2xvck1vZGVDbGFzcyA9ICgpID0+IHNldENvbG9yTW9kZUNsYXNzKG1lZGlhUXVlcnk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgdXBkYXRlQ29sb3JNb2RlQ2xhc3MoKTtcbiAgICAgICAgbWVkaWFRdWVyeT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjb2xvck1vZGVdKTtcbiAgICByZXR1cm4gY29sb3JNb2RlQ2xhc3MgIT09IG51bGwgPyBjb2xvck1vZGVDbGFzcyA6IGdldE1lZGlhUXVlcnkoKT8ubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cbmNvbnN0IGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBzcGVjaWZpYyBrZXkgY29kZXMgYW5kIHRlbGxzIHlvdSB3aGV0aGVyIHRoZXkgYXJlXG4gKiBjdXJyZW50bHkgcHJlc3NlZCBvciBub3QuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VLZXlQcmVzcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IHNwYWNlUHJlc3NlZCA9IHVzZUtleVByZXNzKCdTcGFjZScpO1xuICogIGNvbnN0IGNtZEFuZFNQcmVzc2VkID0gdXNlS2V5UHJlc3MoWydNZXRhK3MnLCAnU3RyZytzJ10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICB7c3BhY2VQcmVzc2VkICYmIDxwPlNwYWNlIHByZXNzZWQhPC9wPn1cbiAqICAgICB7Y21kQW5kU1ByZXNzZWQgJiYgPHA+Q21kICsgUyBwcmVzc2VkITwvcD59XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VLZXlQcmVzcyhcbi8qKlxuICogVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgc3BlY2lmaWVzIHdoaWNoIGtleShzKSBzaG91bGQgdHJpZ2dlclxuICogYW4gYWN0aW9uLlxuICpcbiAqIEEgKipzdHJpbmcqKiBjYW4gcmVwcmVzZW50OlxuICogLSBBICoqc2luZ2xlIGtleSoqLCBlLmcuIGAnYSdgXG4gKiAtIEEgKiprZXkgY29tYmluYXRpb24qKiwgdXNpbmcgYCcrJ2AgdG8gc2VwYXJhdGUga2V5cywgZS5nLiBgJ2ErZCdgXG4gKlxuICogQW4gICoqYXJyYXkgb2Ygc3RyaW5ncyoqIHJlcHJlc2VudHMgKiptdWx0aXBsZSBwb3NzaWJsZSBrZXkgaW5wdXRzKiouIEZvciBleGFtcGxlLCBgWydhJywgJ2QrcyddYFxuICogbWVhbnMgdGhlIHVzZXIgY2FuIHByZXNzIGVpdGhlciB0aGUgc2luZ2xlIGtleSBgJ2EnYCBvciB0aGUgY29tYmluYXRpb24gb2YgYCdkJ2AgYW5kIGAncydgLlxuICogQGRlZmF1bHQgbnVsbFxuICovXG5rZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgdGFyZ2V0OiBkZWZhdWx0RG9jLCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogdHJ1ZSB9KSB7XG4gICAgY29uc3QgW2tleVByZXNzZWQsIHNldEtleVByZXNzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaWYgYSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZCBpbiBvcmRlciB0byB0cmFjayBpdFxuICAgIGNvbnN0IG1vZGlmaWVyUHJlc3NlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciB0aGUgcHJlc3NlZCBrZXlzIGluIG9yZGVyIHRvIHN1cHBvcnQgY29tYmluYXRpb25zXG4gICAgY29uc3QgcHJlc3NlZEtleXMgPSB1c2VSZWYobmV3IFNldChbXSkpO1xuICAgIC8qXG4gICAgICoga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAgKiBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgICogdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgICAqIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgICAqIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAgKiB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgICAqL1xuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2UgZmlyc3QgcmVwbGFjZSBhbGwgJysnIHdpdGggJ1xcbicgIHdoaWNoIHdlIHdpbGwgdXNlIHRvIHNwbGl0IHRoZSBrZXlzIG9uXG4gICAgICAgICAgICAgICAgICogdGhlbiB3ZSByZXBsYWNlICdcXG5cXG4nIHdpdGggJ1xcbisnLCB0aGlzIHdheSB3ZSBjYW4gYWxzbyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiAna2V5KysnXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIGVuZCB3ZSBzaW1wbHkgc3BsaXQgb24gJ1xcbicgdG8gZ2V0IHRoZSBrZXkgYXJyYXlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAubWFwKChrYykgPT4ga2MucmVwbGFjZSgnKycsICdcXG4nKS5yZXBsYWNlKCdcXG5cXG4nLCAnXFxuKycpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzRmxhdCA9IGtleXMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHJlcy5jb25jYXQoLi4uaXRlbSksIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5cywga2V5c0ZsYXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICB9LCBba2V5Q29kZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnM/LnRhcmdldCA/PyBkZWZhdWx0RG9jO1xuICAgICAgICBjb25zdCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA9IG9wdGlvbnM/LmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyID8/IHRydWU7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIWFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmFkZChldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQlVUVE9OJyB8fCB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREZWZhdWx0ICE9PSBmYWxzZSAmJiAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgIWlzSW50ZXJhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLypcbiAgICAgICAgICogd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgICAqIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgICogdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAgKi9cbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLypcbiAgICAgICAgICogc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgICAqIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHVzZVZpZXdwb3J0SGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6b29tSW46IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEgLyAxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tVG86ICh6b29tTGV2ZWwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlVG8oem9vbUxldmVsLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Wm9vbTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICBzZXRWaWV3cG9ydDogYXN5bmMgKHZpZXdwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IFt0WCwgdFksIHRab29tXSwgcGFuWm9vbSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdmlld3BvcnQueCA/PyB0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdmlld3BvcnQueSA/PyB0WSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmlld3BvcnQuem9vbSA/PyB0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgem9vbSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5zZXRDZW50ZXIoeCwgeSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0Qm91bmRzOiBhc3luYyAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBvcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuVG9GbG93UG9zaXRpb246IChjbGllbnRQb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2xpZW50UG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsaWVudFBvc2l0aW9uLnkgLSBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBHcmlkID0gb3B0aW9ucy5zbmFwR3JpZCA/PyBzbmFwR3JpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBfc25hcFRvR3JpZCA9IG9wdGlvbnMuc25hcFRvR3JpZCA/PyBzbmFwVG9HcmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChjb3JyZWN0ZWRQb3NpdGlvbiwgdHJhbnNmb3JtLCBfc25hcFRvR3JpZCwgX3NuYXBHcmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93VG9TY3JlZW5Qb3NpdGlvbjogKGZsb3dQb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQb3NpdGlvbiA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGZsb3dQb3NpdGlvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiByZW5kZXJlclBvc2l0aW9uLnkgKyBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgY2hhbmdlcyB0byBub2RlcyBvciBlZGdlcyB0aGF0IGFyZSB0cmlnZ2VyZWQgYnkgUmVhY3QgRmxvdyBpbnRlcm5hbGx5LlxuICogV2hlbiB5b3UgZHJhZyBhIG5vZGUgZm9yIGV4YW1wbGUsIFJlYWN0IEZsb3cgd2lsbCBzZW5kIGEgcG9zaXRpb24gY2hhbmdlIHVwZGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gdGhlbiBhcHBsaWVzIHRoZSBjaGFuZ2VzIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWxlbWVudHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBbXTtcbiAgICAvKlxuICAgICAqIEJ5IHN0b3JpbmcgYSBtYXAgb2YgY2hhbmdlcyBmb3IgZWFjaCBlbGVtZW50LCB3ZSBjYW4gYSBxdWljayBsb29rdXAgYXMgd2VcbiAgICAgKiBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIGFycmF5IVxuICAgICAqL1xuICAgIGNvbnN0IGNoYW5nZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkSXRlbUNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGFkZEl0ZW1DaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRm9yIGEgJ3JlbW92ZScgY2hhbmdlIHdlIGNhbiBzYWZlbHkgaWdub3JlIGFueSBvdGhlciBjaGFuZ2VzIHF1ZXVlZCBmb3JcbiAgICAgICAgICAgICAqIHRoZSBzYW1lIGVsZW1lbnQsIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZCBhbnl3YXkhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudENoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHNvbWUgY2hhbmdlcyBxdWV1ZWQgYWxyZWFkeSwgd2UgY2FuIGRvIGEgbXV0YWJsZSB1cGRhdGUgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGFycmF5IGFuZCBzYXZlIG91cnNlbHZlcyBzb21lIGNvcHlpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc01hcC5zZXQoY2hhbmdlLmlkLCBbY2hhbmdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChlbGVtZW50LmlkKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2hlbiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBmb3IgYW4gZWxlbWVudCB3ZSBjYW4ganVzdCBwdXNoIGl0IHVubW9kaWZpZWQsXG4gICAgICAgICAqIG5vIG5lZWQgdG8gY29weSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgJ3JlbW92ZScgY2hhbmdlIHF1ZXVlZCwgaXQnbGwgYmUgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZXNbMF0uaXRlbSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igb3RoZXIgdHlwZXMgb2YgY2hhbmdlcywgd2Ugd2FudCB0byBzdGFydCB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIHRoZVxuICAgICAgICAgKiBvYmplY3Qgc28gUmVhY3Qga25vd3MgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkLiBTZXF1ZW50aWFsIGNoYW5nZXMgd2lsbFxuICAgICAgICAgKiBlYWNoIF9tdXRhdGVfIHRoaXMgb2JqZWN0LCBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUgY29weS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlKGNoYW5nZSwgdXBkYXRlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHVwZGF0ZWRFbGVtZW50KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiB3ZSBuZWVkIHRvIHdhaXQgZm9yIGFsbCBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgYmVmb3JlIGFkZGluZyBuZXcgaXRlbXNcbiAgICAgKiB0byBiZSBhYmxlIHRvIGFkZCB0aGVtIGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICovXG4gICAgaWYgKGFkZEl0ZW1DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICBhZGRJdGVtQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5zcGxpY2UoY2hhbmdlLmluZGV4LCAwLCB7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRWxlbWVudHM7XG59XG4vLyBBcHBsaWVzIGEgc2luZ2xlIGNoYW5nZSB0byBhbiBlbGVtZW50LiBUaGlzIGlzIGEgKm11dGFibGUqIHVwZGF0ZS5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlKGNoYW5nZSwgZWxlbWVudCkge1xuICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZCA9IGNoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IGNoYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZHJhZ2dpbmcgPSBjaGFuZ2UuZHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZGltZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jaGFuZ2UuZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09IHRydWUgfHwgY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQud2lkdGggPSBjaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09IHRydWUgfHwgY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IGNoYW5nZS5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnJlc2l6aW5nID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6aW5nID0gY2hhbmdlLnJlc2l6aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIG5vZGUgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjaGFuZ2VzIC0gQXJyYXkgb2YgY2hhbmdlcyB0byBhcHBseS5cbiAqIEBwYXJhbSBub2RlcyAtIEFycmF5IG9mIG5vZGVzIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBub2Rlcy5cbiAqIEBleGFtcGxlXG4gKmBgYHRzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgYXBwbHlOb2RlQ2hhbmdlcywgdHlwZSBOb2RlLCB0eXBlIEVkZ2UsIHR5cGUgT25Ob2Rlc0NoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlPE5vZGVbXT4oW10pO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGU8RWRnZVtdPihbXSk7XG4gKiAgY29uc3Qgb25Ob2Rlc0NoYW5nZTogT25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0Tm9kZXMoKG9sZE5vZGVzKSA9PiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG9sZE5vZGVzKSk7XG4gKiAgICB9LFxuICogICAgW3NldE5vZGVzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBOb2RlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgZWRnZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIGVkZ2VzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIGVkZ2VzIC0gQXJyYXkgb2YgZWRnZSB0byBhcHBseSB0aGUgY2hhbmdlcyB0by5cbiAqIEByZXR1cm5zIEFycmF5IG9mIHVwZGF0ZWQgZWRnZXMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseUVkZ2VDaGFuZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAqICAgIChjaGFuZ2VzKSA9PiB7XG4gKiAgICAgIHNldEVkZ2VzKChvbGRFZGdlcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBvbGRFZGdlcykpO1xuICogICAgfSxcbiAqICAgIFtzZXRFZGdlc10sXG4gKiAgKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9IC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgRWRnZUNoYW5nZX1cbiAqIHRoYXQgZGVzY3JpYmVzIGhvdyB0byB1cGRhdGUgdGhlIGVkZ2VzIG9mIHlvdXIgZmxvdyBpbiBzb21lIHdheS5cbiAqIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheVxuICogb2YgdGhlc2UgY2hhbmdlcyBhbmQgYXBwbHkgdGhlbSB0byB5b3VyIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaWQsIHNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhpdGVtcywgc2VsZWN0ZWRJZHMgPSBuZXcgU2V0KCksIG11dGF0ZUl0ZW0gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgaXRlbXMpIHtcbiAgICAgICAgY29uc3Qgd2lsbEJlU2VsZWN0ZWQgPSBzZWxlY3RlZElkcy5oYXMoaWQpO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHNldCBhbGwgaXRlbXMgdG8gc2VsZWN0ZWQ9ZmFsc2Ugb24gdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICBpZiAoIShpdGVtLnNlbGVjdGVkID09PSB1bmRlZmluZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSAmJiBpdGVtLnNlbGVjdGVkICE9PSB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKG11dGF0ZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHRoaXMgaGFjayBpcyBuZWVkZWQgZm9yIG5vZGVzLiBXaGVuIHRoZSB1c2VyIGRyYWdnZWQgYSBub2RlLCBpdCdzIHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgICAqIFdoZW4gYW5vdGhlciBub2RlIGdldHMgZHJhZ2dlZCwgd2UgbmVlZCB0byBkZXNlbGVjdCB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgICAgICAgICAqIGluIG9yZGVyIHRvIGhhdmUgb25seSBvbmUgc2VsZWN0ZWQgbm9kZSBhdCBhIHRpbWUgLSB0aGUgb25Ob2Rlc0NoYW5nZSBjYWxsYmFjayBjb21lcyB0b28gbGF0ZSBoZXJlIDovXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHdpbGxCZVNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpdGVtLmlkLCB3aWxsQmVTZWxlY3RlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7IGl0ZW1zID0gW10sIGxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBpdGVtc0xvb2t1cCA9IG5ldyBNYXAoaXRlbXMubWFwKChpdGVtKSA9PiBbaXRlbS5pZCwgaXRlbV0pKTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgaXRlbV0gb2YgaXRlbXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cEl0ZW0gPSBsb29rdXAuZ2V0KGl0ZW0uaWQpO1xuICAgICAgICBjb25zdCBzdG9yZUl0ZW0gPSBsb29rdXBJdGVtPy5pbnRlcm5hbHM/LnVzZXJOb2RlID8/IGxvb2t1cEl0ZW07XG4gICAgICAgIGlmIChzdG9yZUl0ZW0gIT09IHVuZGVmaW5lZCAmJiBzdG9yZUl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkOiBpdGVtLmlkLCBpdGVtOiBpdGVtLCB0eXBlOiAncmVwbGFjZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3JlSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpdGVtOiBpdGVtLCB0eXBlOiAnYWRkJywgaW5kZXggfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWRdIG9mIGxvb2t1cCkge1xuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IGl0ZW1zTG9va3VwLmdldChpZCk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpZCwgdHlwZTogJ3JlbW92ZScgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBlbGVtZW50VG9SZW1vdmVDaGFuZ2UoaXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICB9O1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpLlxuICogSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvXG4gKiBbYE5vZGVgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9ub2RlKSBpZiBpdCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGEgYE5vZGVgLiBJZiB5b3UncmUgdXNpbmcgVHlwZVNjcmlwdCxcbiAqIHRoaXMgZnVuY3Rpb24gYWN0cyBhcyBhIHR5cGUgZ3VhcmQgYW5kIHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBgTm9kZWAgaWYgaXQgcmV0dXJuc1xuICogYHRydWVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBpc05vZGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmlmIChpc05vZGUobm9kZSkpIHtcbiAqIC8vIC4uLlxuICp9XG4gKmBgYFxuICovXG5jb25zdCBpc05vZGUgPSAoZWxlbWVudCkgPT4gaXNOb2RlQmFzZShlbGVtZW50KTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgRWRnZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBUZXN0cyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBgRWRnZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBFZGdlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzRWRnZShlZGdlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzRWRnZSA9IChlbGVtZW50KSA9PiBpc0VkZ2VCYXNlKGVsZW1lbnQpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1vYmplY3QtdHlwZVxuZnVuY3Rpb24gZml4ZWRGb3J3YXJkUmVmKHJlbmRlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZvcndhcmRSZWYocmVuZGVyKTtcbn1cblxuLy8gd2UgbmVlZCB0aGlzIGhvb2sgdG8gcHJldmVudCBhIHdhcm5pbmcgd2hlbiB1c2luZyByZWFjdC1mbG93IGluIFNTUlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGEgcXVldWUgdGhhdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSBydW5RdWV1ZSAtIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBxdWV1ZSBpcyBmbHVzaGVkXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcmV0dXJucyBhIFF1ZXVlIG9iamVjdFxuICovXG5mdW5jdGlvbiB1c2VRdWV1ZShydW5RdWV1ZSkge1xuICAgIC8qXG4gICAgICogQmVjYXVzZSB3ZSdyZSB1c2luZyBhIHJlZiBhYm92ZSwgd2UgbmVlZCBzb21lIHdheSB0byBsZXQgUmVhY3Qga25vdyB3aGVuIHRvXG4gICAgICogYWN0dWFsbHkgcHJvY2VzcyB0aGUgcXVldWUuIFdlIGluY3JlbWVudCB0aGlzIG51bWJlciBhbnkgdGltZSB3ZSBtdXRhdGUgdGhlXG4gICAgICogcXVldWUsIGNyZWF0aW5nIGEgbmV3IHN0YXRlIHRvIHRyaWdnZXIgdGhlIGxheW91dCBlZmZlY3QgYmVsb3cuXG4gICAgICogVXNpbmcgYSBib29sZWFuIGRpcnR5IGZsYWcgaGVyZSBpbnN0ZWFkIHdvdWxkIGxlYWQgdG8gaXNzdWVzIHJlbGF0ZWQgdG9cbiAgICAgKiBhdXRvbWF0aWMgYmF0Y2hpbmcuIChodHRwczovL2dpdGh1Yi5jb20veHlmbG93L3h5Zmxvdy9pc3N1ZXMvNDc3OSlcbiAgICAgKi9cbiAgICBjb25zdCBbc2VyaWFsLCBzZXRTZXJpYWxdID0gdXNlU3RhdGUoQmlnSW50KDApKTtcbiAgICAvKlxuICAgICAqIEEgcmVmZXJlbmNlIG9mIGFsbCB0aGUgYmF0Y2hlZCB1cGRhdGVzIHRvIHByb2Nlc3MgYmVmb3JlIHRoZSBuZXh0IHJlbmRlci4gV2VcbiAgICAgKiB3YW50IGEgcmVmZXJlbmNlIGhlcmUgc28gbXVsdGlwbGUgc3luY2hyb25vdXMgY2FsbHMgdG8gYHNldE5vZGVzYCBldGMgY2FuIGJlXG4gICAgICogYmF0Y2hlZCB0b2dldGhlci5cbiAgICAgKi9cbiAgICBjb25zdCBbcXVldWVdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlUXVldWUoKCkgPT4gc2V0U2VyaWFsKG4gPT4gbiArIEJpZ0ludCgxKSkpKTtcbiAgICAvKlxuICAgICAqIExheW91dCBlZmZlY3RzIGFyZSBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIHdoaWNoIG1lYW5zIHdlXG4gICAgICogc2hvdWxkbid0IHJ1biBpbnRvIGFueSBpc3N1ZXMgd2l0aCBzdGFsZSBzdGF0ZSBvciB3ZWlyZCBpc3N1ZXMgdGhhdCBjb21lIGZyb21cbiAgICAgKiByZW5kZXJpbmcgdGhpbmdzIG9uZSBmcmFtZSBsYXRlciB0aGFuIGV4cGVjdGVkICh3ZSB1c2VkIHRvIHVzZSBgc2V0VGltZW91dGApLlxuICAgICAqL1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZUl0ZW1zID0gcXVldWUuZ2V0KCk7XG4gICAgICAgIGlmIChxdWV1ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuUXVldWUocXVldWVJdGVtcyk7XG4gICAgICAgICAgICBxdWV1ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwgW3NlcmlhbF0pO1xuICAgIHJldHVybiBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXVlKGNiKSB7XG4gICAgbGV0IHF1ZXVlID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBxdWV1ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBCYXRjaENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBUaGlzIGlzIGEgY29udGV4dCBwcm92aWRlciB0aGF0IGhvbGRzIGFuZCBwcm9jZXNzZXMgdGhlIG5vZGUgYW5kIGVkZ2UgdXBkYXRlIHF1ZXVlc1xuICogdGhhdCBhcmUgbmVlZGVkIHRvIGhhbmRsZSBzZXROb2RlcywgYWRkTm9kZXMsIHNldEVkZ2VzIGFuZCBhZGRFZGdlcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQmF0Y2hQcm92aWRlcih7IGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIHNldE5vZGVzLCBoYXNEZWZhdWx0Tm9kZXMsIG9uTm9kZXNDaGFuZ2UsIG5vZGVMb29rdXAsIGZpdFZpZXdRdWV1ZWQsIG9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhbiBgQXJyYXkucmVkdWNlYCBpbiBpbXBlcmF0aXZlIGNsb3RoaW5nLiBQcm9jZXNzaW5nXG4gICAgICAgICAqIHRoaXMgcXVldWUgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoIHNvIHdlJ2QgbGlrZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWQgb2ZcbiAgICAgICAgICogYXJyYXkgbWV0aG9kcyB3aGVyZSB3ZSBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYW5nZXMgPSBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHtcbiAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgbG9va3VwOiBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjaGFuZ2VzID0gbWlkZGxld2FyZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZmlyZSBvbk5vZGVzQ2hhbmdlIGlmIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIHRoZSBub2Rlc1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMgdG8gdGhlIG5vZGVzLCB3ZSBzdGlsbCBuZWVkIHRvIGNhbGwgc2V0Tm9kZXNcbiAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgYW5kIGZpdFZpZXcuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpdFZpZXdRdWV1ZWQsIG5vZGVzLCBzZXROb2RlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIFJlYWN0Rmxvd0luc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIG5vZGVzIGFuZCBlZGdlcywgbWFuaXB1bGF0ZSB0aGUgdmlld3BvcnQsIG9yIHF1ZXJ5IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBOb2RlQ291bnRlcigpIHtcbiAqICBjb25zdCByZWFjdEZsb3cgPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IGNvdW50Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgICBzZXRDb3VudChyZWFjdEZsb3cuZ2V0Tm9kZXMoKS5sZW5ndGgpO1xuICogICAgLy8geW91IG5lZWQgdG8gcGFzcyBpdCBhcyBhIGRlcGVuZGVuY3kgaWYgeW91IGFyZSB1c2luZyBpdCB3aXRoIHVzZUVmZmVjdCBvciB1c2VDYWxsYmFja1xuICogICAgLy8gYmVjYXVzZSBhdCB0aGUgZmlyc3QgcmVuZGVyLCBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXQgYW5kIHNvbWUgZnVuY3Rpb25zIG1pZ2h0IG5vdCB3b3JrLlxuICogIH0sIFtyZWFjdEZsb3ddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxidXR0b24gb25DbGljaz17Y291bnROb2Rlc30+VXBkYXRlIGNvdW50PC9idXR0b24+XG4gKiAgICAgIDxwPlRoZXJlIGFyZSB7Y291bnR9IG5vZGVzIGluIHRoZSBmbG93LjwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVJlYWN0RmxvdygpIHtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlciA9IHVzZVZpZXdwb3J0SGVscGVyKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUJhdGNoQ29udGV4dCgpO1xuICAgIGNvbnN0IHZpZXdwb3J0SW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciRrKTtcbiAgICBjb25zdCBnZW5lcmFsSGVscGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEludGVybmFsTm9kZSA9IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHNldE5vZGVzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0RWRnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0LmVkZ2VRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXROb2RlUmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlVG9Vc2UgPSBpc05vZGUobm9kZSkgPyBub2RlIDogbm9kZUxvb2t1cC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGVUb1VzZS5wYXJlbnRJZFxuICAgICAgICAgICAgICAgID8gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKG5vZGVUb1VzZS5wb3NpdGlvbiwgbm9kZVRvVXNlLm1lYXN1cmVkLCBub2RlVG9Vc2UucGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pXG4gICAgICAgICAgICAgICAgOiBub2RlVG9Vc2UucG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBub2RlV2l0aFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGVUb1VzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVRvVXNlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlVG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlVG9Vc2UubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlVG9Vc2UuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlVG9SZWN0KG5vZGVXaXRoUG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVOb2RlID0gKGlkLCBub2RlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlcygocHJldk5vZGVzKSA9PiBwcmV2Tm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdHlwZW9mIG5vZGVVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBub2RlVXBkYXRlKG5vZGUpIDogbm9kZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc05vZGUobmV4dE5vZGUpID8gbmV4dE5vZGUgOiB7IC4uLm5vZGUsIC4uLm5leHROb2RlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVFZGdlID0gKGlkLCBlZGdlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXRFZGdlcygocHJldkVkZ2VzKSA9PiBwcmV2RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGdlID0gdHlwZW9mIGVkZ2VVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBlZGdlVXBkYXRlKGVkZ2UpIDogZWRnZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc0VkZ2UobmV4dEVkZ2UpID8gbmV4dEVkZ2UgOiB7IC4uLmVkZ2UsIC4uLm5leHRFZGdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Tm9kZXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGdldE5vZGU6IChpZCkgPT4gZ2V0SW50ZXJuYWxOb2RlKGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlLFxuICAgICAgICAgICAgZ2V0SW50ZXJuYWxOb2RlLFxuICAgICAgICAgICAgZ2V0RWRnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRnZTogKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmVkZ2VMb29rdXAuZ2V0KGlkKSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRFZGdlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaCgoZWRnZXMpID0+IFsuLi5lZGdlcywgLi4ubmV3RWRnZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b09iamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXSwgdHJhbnNmb3JtIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50czogYXN5bmMgKHsgbm9kZXM6IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXM6IGVkZ2VzVG9SZW1vdmUgPSBbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgZWRnZXMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBvbkRlbGV0ZSwgb25CZWZvcmVEZWxldGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0gPSBhd2FpdCBnZXRFbGVtZW50c1RvUmVtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZURlbGV0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0VkZ2VzID0gbWF0Y2hpbmdFZGdlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nTm9kZXMgPSBtYXRjaGluZ05vZGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBtYXRjaGluZ0VkZ2VzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4obWF0Y2hpbmdFZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbWF0Y2hpbmdOb2Rlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2Rlc0RlbGV0ZT8uKG1hdGNoaW5nTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2RlcyB8fCBoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlPy4oeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWROb2RlczogbWF0Y2hpbmdOb2RlcywgZGVsZXRlZEVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJ0aWFsIGlzIGRlZmluZWQgYXMgXCJ0aGUgMiBub2Rlcy9hcmVhcyBhcmUgaW50ZXJzZWN0aW5nIHBhcnRpYWxseVwiLlxuICAgICAgICAgICAgICogSWYgYSBpcyBjb250YWluZWQgaW4gYiBvciBiIGlzIGNvbnRhaW5lZCBpbiBhLCB0aGV5IGFyZSBib3RoXG4gICAgICAgICAgICAgKiBjb25zaWRlcmVkIGZ1bGx5IGludGVyc2VjdGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXM6IChub2RlT3JSZWN0LCBwYXJ0aWFsbHkgPSB0cnVlLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOb2Rlc09wdGlvbiA9IG5vZGVzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZXMgfHwgc3RvcmUuZ2V0U3RhdGUoKS5ub2RlcykuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUgJiYgIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZU9yUmVjdC5pZCB8fCAhaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3QoaGFzTm9kZXNPcHRpb24gPyBuIDogaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKGN1cnJOb2RlUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFydGlhbGx5VmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBcmVhID49IGN1cnJOb2RlUmVjdC53aWR0aCAqIGN1cnJOb2RlUmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNOb2RlSW50ZXJzZWN0aW5nOiAobm9kZU9yUmVjdCwgYXJlYSwgcGFydGlhbGx5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKG5vZGVSZWN0LCBhcmVhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJ0aWFsbHlWaXNpYmxlIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhLndpZHRoICogYXJlYS5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBcmVhID49IG5vZGVSZWN0LndpZHRoICogbm9kZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOb2RlLFxuICAgICAgICAgICAgdXBkYXRlTm9kZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGUoaWQsIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKG5vZGUpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4ubm9kZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4ubm9kZSwgZGF0YTogeyAuLi5ub2RlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVFZGdlLFxuICAgICAgICAgICAgdXBkYXRlRWRnZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2UoaWQsIChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKGVkZ2UpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4uZWRnZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4uZWRnZSwgZGF0YTogeyAuLi5lZGdlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROb2Rlc0JvdW5kczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2Rlc0JvdW5kcyhub2RlcywgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEhhbmRsZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBpZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICAgICAgZ2V0Tm9kZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBoYW5kbGVJZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9JHt0eXBlID8gKGhhbmRsZUlkID8gYC0ke3R5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHt0eXBlfWApIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGZpdFZpZXc6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGNyZWF0ZSBhIG5ldyBQcm9taXNlIG9yIHJldXNlIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIGZpdFZpZXcgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgcm93LCB3ZSBvbmx5IGVuZCB1cCB3aXRoIGEgc2luZ2xlIFByb21pc2VcbiAgICAgICAgICAgICAgICBjb25zdCBmaXRWaWV3UmVzb2x2ZXIgPSBzdG9yZS5nZXRTdGF0ZSgpLmZpdFZpZXdSZXNvbHZlciA/PyB3aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2NoZWR1bGUgYSBmaXRWaWV3IGJ5IHNldHRpbmcgZml0Vmlld1F1ZXVlZCBhbmQgdHJpZ2dlcmluZyBhIHNldE5vZGVzXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiB0cnVlLCBmaXRWaWV3T3B0aW9uczogb3B0aW9ucywgZml0Vmlld1Jlc29sdmVyIH0pO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2Rlc10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRWaWV3UmVzb2x2ZXIucHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmdlbmVyYWxIZWxwZXIsXG4gICAgICAgICAgICAuLi52aWV3cG9ydEhlbHBlcixcbiAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQsXG4gICAgICAgIH07XG4gICAgfSwgW3ZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0ZWQgPSAoaXRlbSkgPT4gaXRlbS5zZWxlY3RlZDtcbmNvbnN0IHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIGdsb2JhbCBrZXkgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiBmYWxzZSB9KTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4kMSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBub2Rlcy5maWx0ZXIoc2VsZWN0ZWQpLCBlZGdlczogZWRnZXMuZmlsdGVyKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc2l6ZUhhbmRsZXIoZG9tTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb21Ob2RlLmN1cnJlbnQgfHwgIShkb21Ob2RlLmN1cnJlbnQuY2hlY2tWaXNpYmlsaXR5Py4oKSA/PyB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXREaW1lbnNpb25zKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgPT09IDAgfHwgc2l6ZS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDQnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNCddKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB3aWR0aDogc2l6ZS53aWR0aCB8fCA1MDAsIGhlaWdodDogc2l6ZS5oZWlnaHQgfHwgNTAwIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB1cGRhdGVEaW1lbnNpb25zKCkpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU9ic2VydmVyICYmIGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5jb25zdCBjb250YWluZXJTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxufTtcblxuY29uc3Qgc2VsZWN0b3IkaiA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBsaWI6IHMubGliLFxuICAgIGNvbm5lY3Rpb25JblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbn0pO1xuZnVuY3Rpb24gWm9vbVBhbmUoeyBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2UsIHNlbGVjdGlvbk9uRHJhZywgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB6b29tUGFuZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIGxpYiwgY29ubmVjdGlvbkluUHJvZ3Jlc3MgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGosIHNoYWxsb3cpO1xuICAgIGNvbnN0IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHpvb21BY3RpdmF0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuWm9vbSA9IHVzZVJlZigpO1xuICAgIHVzZVJlc2l6ZUhhbmRsZXIoem9vbVBhbmUpO1xuICAgIGNvbnN0IG9uVHJhbnNmb3JtQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4oeyB4OiB0cmFuc2Zvcm1bMF0sIHk6IHRyYW5zZm9ybVsxXSwgem9vbTogdHJhbnNmb3JtWzJdIH0pO1xuICAgICAgICBpZiAoIWlzQ29udHJvbGxlZFZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh6b29tUGFuZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQgPSBYWVBhblpvb20oe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2U6IChwYW5lRHJhZ2dpbmcpID0+IHN0b3JlLnNldFN0YXRlKHsgcGFuZURyYWdnaW5nIH0pLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0OiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0LCBvbk1vdmVTdGFydCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3ZlU3RhcnQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb206IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlLCBvbk1vdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZT8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ6IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlRW5kLCBvbk1vdmVFbmQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZUVuZD8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VFbmQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBwYW5ab29tLmN1cnJlbnQuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwYW5ab29tOiBwYW5ab29tLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbeCwgeSwgem9vbV0sXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogem9vbVBhbmUuY3VycmVudC5jbG9zZXN0KCcucmVhY3QtZmxvdycpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhblpvb20uY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICAgICAgY29ubmVjdGlvbkluUHJvZ3Jlc3MsXG4gICAgICAgICAgICBzZWxlY3Rpb25PbkRyYWcsXG4gICAgICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgbGliLFxuICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgY29ubmVjdGlvbkluUHJvZ3Jlc3MsXG4gICAgICAgIHNlbGVjdGlvbk9uRHJhZyxcbiAgICAgICAgcGFuZUNsaWNrRGlzdGFuY2UsXG4gICAgXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fcmVuZGVyZXJcIiwgcmVmOiB6b29tUGFuZSwgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRpID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBzLnVzZXJTZWxlY3Rpb25SZWN0LFxufSk7XG5mdW5jdGlvbiBVc2VyU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvblJlY3QgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGksIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19zZWxlY3Rpb24gcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogdXNlclNlbGVjdGlvblJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHVzZXJTZWxlY3Rpb25SZWN0LmhlaWdodCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3VzZXJTZWxlY3Rpb25SZWN0Lnh9cHgsICR7dXNlclNlbGVjdGlvblJlY3QueX1weClgLFxuICAgICAgICB9IH0pKTtcbn1cblxuY29uc3Qgd3JhcEhhbmRsZXIgPSAoaGFuZGxlciwgY29udGFpbmVyUmVmKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXI/LihldmVudCk7XG4gICAgfTtcbn07XG5jb25zdCBzZWxlY3RvciRoID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgY29ubmVjdGlvbkluUHJvZ3Jlc3M6IHMuY29ubmVjdGlvbi5pblByb2dyZXNzLFxuICAgIGRyYWdnaW5nOiBzLnBhbmVEcmFnZ2luZyxcbn0pO1xuZnVuY3Rpb24gUGFuZSh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIHBhbmVDbGlja0Rpc3RhbmNlLCBzZWxlY3Rpb25PbkRyYWcsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljaywgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZHJhZ2dpbmcsIGNvbm5lY3Rpb25JblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRoLCBzaGFsbG93KTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkVuYWJsZWQgPSBlbGVtZW50c1NlbGVjdGFibGUgJiYgKGlzU2VsZWN0aW5nIHx8IHVzZXJTZWxlY3Rpb25BY3RpdmUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVJZHMgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgICBjb25zdCBzZWxlY3RlZEVkZ2VJZHMgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgICAvLyBVc2VkIHRvIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0cyBnbyBvZiB0aGUgc2VsZWN0aW9uS2V5IGR1cmluZyBhIHNlbGVjdGlvblxuICAgIGNvbnN0IHNlbGVjdGlvbkluUHJvZ3Jlc3MgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gV2UgcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXQgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICAgICAgLy8gV2UgYWxzbyBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIGEgY29ubmVjdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAoc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50IHx8IGNvbm5lY3Rpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblBhbmVDbGljaz8uKGV2ZW50KTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5yZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnPy5pbmNsdWRlcygyKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblBhbmVDb250ZXh0TWVudT8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uV2hlZWwgPSBvblBhbmVTY3JvbGwgPyAoZXZlbnQpID0+IG9uUGFuZVNjcm9sbChldmVudCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25DbGlja0NhcHR1cmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gV2UgYXJlIHVzaW5nIGNhcHR1cmUgaGVyZSBpbiBvcmRlciB0byBwcmV2ZW50IG90aGVyIHBvaW50ZXIgZXZlbnRzXG4gICAgLy8gdG8gYmUgYWJsZSB0byBjcmVhdGUgYSBzZWxlY3Rpb24gYWJvdmUgYSBub2RlIG9yIGFuIGVkZ2VcbiAgICBjb25zdCBvblBvaW50ZXJEb3duQ2FwdHVyZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50ID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0SXNDb250YWluZXIgPSBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgICAvLyBpZiBhIGNoaWxkIGVsZW1lbnQgaGFzIHRoZSAnbm9rZXknIGNsYXNzLCB3ZSBkb24ndCB3YW50IHRvIHN3YWxsb3cgdGhlIGV2ZW50IGFuZCBkb24ndCBzdGFydCBhIHNlbGVjdGlvblxuICAgICAgICBjb25zdCBpc05vS2V5RXZlbnQgPSAhZXZlbnRUYXJnZXRJc0NvbnRhaW5lciAmJiAhIWV2ZW50LnRhcmdldC5jbG9zZXN0KCcubm9rZXknKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3Rpb25BY3RpdmUgPSAoc2VsZWN0aW9uT25EcmFnICYmIGV2ZW50VGFyZ2V0SXNDb250YWluZXIpIHx8IHNlbGVjdGlvbktleVByZXNzZWQ7XG4gICAgICAgIGlmIChpc05vS2V5RXZlbnQgfHwgIWlzU2VsZWN0aW5nIHx8ICFpc1NlbGVjdGlvbkFjdGl2ZSB8fCBldmVudC5idXR0b24gIT09IDAgfHwgIWV2ZW50LmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8uc2V0UG9pbnRlckNhcHR1cmU/LihldmVudC5wb2ludGVySWQpO1xuICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50Lm5hdGl2ZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZXZlbnRUYXJnZXRJc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgZWRnZUxvb2t1cCwgY29ubmVjdGlvbkxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgcmVzZXRTZWxlY3RlZEVsZW1lbnRzLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fCAhdXNlclNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHg6IG1vdXNlWCwgeTogbW91c2VZIH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50Lm5hdGl2ZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRYLCBzdGFydFkgfSA9IHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWREaXN0YW5jZSA9IHNlbGVjdGlvbktleVByZXNzZWQgPyAwIDogcGFuZUNsaWNrRGlzdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QobW91c2VYIC0gc3RhcnRYLCBtb3VzZVkgLSBzdGFydFkpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHJlcXVpcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVJZHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50O1xuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCA9IG5ldyBTZXQoZ2V0Tm9kZXNJbnNpZGUobm9kZUxvb2t1cCwgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlZGdlc1NlbGVjdGFibGUgPSBkZWZhdWx0RWRnZU9wdGlvbnM/LnNlbGVjdGFibGUgPz8gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2Ygc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbkxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZWRnZUlkIH0gb2YgY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZWRnZUxvb2t1cC5nZXQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZS5zZWxlY3RhYmxlID8/IGVkZ2VzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZE5vZGVJZHMsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZEVkZ2VJZHMsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBuZXh0VXNlclNlbGVjdFJlY3QsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQ/LnJlbGVhc2VQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgICAgICAqIHRoZSB1c2VyIGRpZCBub3QgbW92ZSB0aGUgbW91c2UuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgZXZlbnQudGFyZ2V0ID09PSBjb250YWluZXIuY3VycmVudCAmJiBzdG9yZS5nZXRTdGF0ZSgpLnVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gcGFuT25EcmFnID09PSB0cnVlIHx8IChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDApKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZScsIHsgZHJhZ2dhYmxlLCBkcmFnZ2luZywgc2VsZWN0aW9uOiBpc1NlbGVjdGluZyB9XSksIG9uQ2xpY2s6IGlzU2VsZWN0aW9uRW5hYmxlZCA/IHVuZGVmaW5lZCA6IHdyYXBIYW5kbGVyKG9uQ2xpY2ssIGNvbnRhaW5lciksIG9uQ29udGV4dE1lbnU6IHdyYXBIYW5kbGVyKG9uQ29udGV4dE1lbnUsIGNvbnRhaW5lciksIG9uV2hlZWw6IHdyYXBIYW5kbGVyKG9uV2hlZWwsIGNvbnRhaW5lciksIG9uUG9pbnRlckVudGVyOiBpc1NlbGVjdGlvbkVuYWJsZWQgPyB1bmRlZmluZWQgOiBvblBhbmVNb3VzZUVudGVyLCBvblBvaW50ZXJNb3ZlOiBpc1NlbGVjdGlvbkVuYWJsZWQgPyBvblBvaW50ZXJNb3ZlIDogb25QYW5lTW91c2VNb3ZlLCBvblBvaW50ZXJVcDogaXNTZWxlY3Rpb25FbmFibGVkID8gb25Qb2ludGVyVXAgOiB1bmRlZmluZWQsIG9uUG9pbnRlckRvd25DYXB0dXJlOiBpc1NlbGVjdGlvbkVuYWJsZWQgPyBvblBvaW50ZXJEb3duQ2FwdHVyZSA6IHVuZGVmaW5lZCwgb25DbGlja0NhcHR1cmU6IGlzU2VsZWN0aW9uRW5hYmxlZCA/IG9uQ2xpY2tDYXB0dXJlIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgcmVmOiBjb250YWluZXIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtjaGlsZHJlbiwganN4KFVzZXJTZWxlY3Rpb24sIHt9KV0gfSkpO1xufVxuXG4vKlxuICogdGhpcyBoYW5kbGVyIGlzIGNhbGxlZCBieVxuICogMS4gdGhlIGNsaWNrIGhhbmRsZXIgd2hlbiBub2RlIGlzIG5vdCBkcmFnZ2FibGUgb3Igc2VsZWN0Tm9kZXNPbkRyYWcgPSBmYWxzZVxuICogb3JcbiAqIDIuIHRoZSBvbiBkcmFnIHN0YXJ0IGhhbmRsZXIgd2hlbiBub2RlIGlzIGRyYWdnYWJsZSBhbmQgc2VsZWN0Tm9kZXNPbkRyYWcgPSB0cnVlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vZGVDbGljayh7IGlkLCBzdG9yZSwgdW5zZWxlY3QgPSBmYWxzZSwgbm9kZVJlZiwgfSkge1xuICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWROb2RlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZUxvb2t1cCwgb25FcnJvciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEyJ10oaWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICBpZiAoIW5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlcyhbaWRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5zZWxlY3QgfHwgKG5vZGUuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpKSB7XG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbbm9kZV0sIGVkZ2VzOiBbXSB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IG5vZGVSZWY/LmN1cnJlbnQ/LmJsdXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgWFlEcmFnIGhlbHBlciBmcm9tIEB4eWZsb3cvc3lzdGVtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHh5RHJhZyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHh5RHJhZy5jdXJyZW50ID0gWFlEcmFnKHtcbiAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICBvbk5vZGVNb3VzZURvd246IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0b3A6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IG5vZGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW25vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRpc2FibGVkLCBpc1NlbGVjdGFibGUsIG5vZGVSZWYsIG5vZGVJZF0pO1xuICAgIHJldHVybiBkcmFnZ2luZztcbn1cblxuY29uc3Qgc2VsZWN0ZWRBbmREcmFnZ2FibGUgPSAobm9kZXNEcmFnZ2FibGUpID0+IChuKSA9PiBuLnNlbGVjdGVkICYmIChuLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG4uZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuLyoqXG4gKiBIb29rIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9ucyBieSBwYXNzaW5nIGEgZGlyZWN0aW9uIGFuZCBmYWN0b3JcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VDYWxsYmFjaygocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUV4dGVudCwgc25hcFRvR3JpZCwgc25hcEdyaWQsIG5vZGVzRHJhZ2dhYmxlLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkQW5kRHJhZ2dhYmxlKG5vZGVzRHJhZ2dhYmxlKTtcbiAgICAgICAgLypcbiAgICAgICAgICogYnkgZGVmYXVsdCBhIG5vZGUgbW92ZXMgNXB4IG9uIGVhY2gga2V5IHByZXNzXG4gICAgICAgICAqIGlmIHNuYXAgZ3JpZCBpcyBlbmFibGVkLCB3ZSB1c2UgdGhhdCBmb3IgdGhlIHZlbG9jaXR5XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB4VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFswXSA6IDU7XG4gICAgICAgIGNvbnN0IHlWZWxvID0gc25hcFRvR3JpZCA/IHNuYXBHcmlkWzFdIDogNTtcbiAgICAgICAgY29uc3QgeERpZmYgPSBwYXJhbXMuZGlyZWN0aW9uLnggKiB4VmVsbyAqIHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGNvbnN0IHlEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi55ICogeVZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgICAgIGlmICghaXNTZWxlY3RlZChub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggKyB4RGlmZixcbiAgICAgICAgICAgICAgICB5OiBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgKyB5RGlmZixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHNuYXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIHNuYXBHcmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIG5vZGVVcGRhdGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKG5vZGVVcGRhdGVzKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG1vdmVTZWxlY3RlZE5vZGVzO1xufVxuXG5jb25zdCBOb2RlSWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyID0gTm9kZUlkQ29udGV4dC5Qcm92aWRlcjtcbk5vZGVJZENvbnRleHQuQ29uc3VtZXI7XG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoaXMgaG9vayB0byBnZXQgdGhlIGlkIG9mIHRoZSBub2RlIGl0IGlzIHVzZWQgaW5zaWRlLiBJdCBpcyB1c2VmdWxcbiAqIGlmIHlvdSBuZWVkIHRoZSBub2RlJ3MgaWQgZGVlcGVyIGluIHRoZSByZW5kZXIgdHJlZSBidXQgZG9uJ3Qgd2FudCB0byBtYW51YWxseVxuICogZHJpbGwgZG93biB0aGUgaWQgYXMgYSBwcm9wLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFRoZSBpZCBmb3IgYSBub2RlIGluIHRoZSBmbG93LlxuICpcbiAqIEBleGFtcGxlXG4gKmBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlSWQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEN1c3RvbU5vZGUoKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxzcGFuPlRoaXMgbm9kZSBoYXMgYW4gaWQgb2YgPC9zcGFuPlxuICogICAgICA8Tm9kZUlkRGlzcGxheSAvPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpcbiAqZnVuY3Rpb24gTm9kZUlkRGlzcGxheSgpIHtcbiAqICBjb25zdCBub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAqXG4gKiAgcmV0dXJuIDxzcGFuPntub2RlSWR9PC9zcGFuPjtcbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgdXNlTm9kZUlkID0gKCkgPT4ge1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZUNvbnRleHQoTm9kZUlkQ29udGV4dCk7XG4gICAgcmV0dXJuIG5vZGVJZDtcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGcgPSAocykgPT4gKHtcbiAgICBjb25uZWN0T25DbGljazogcy5jb25uZWN0T25DbGljayxcbiAgICBub1BhbkNsYXNzTmFtZTogcy5ub1BhbkNsYXNzTmFtZSxcbiAgICByZklkOiBzLnJmSWQsXG59KTtcbmNvbnN0IGNvbm5lY3RpbmdTZWxlY3RvciA9IChub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSA9PiAoc3RhdGUpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBjbGlja0hhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb24gfSA9IHN0YXRlO1xuICAgIGNvbnN0IHsgZnJvbUhhbmRsZSwgdG9IYW5kbGUsIGlzVmFsaWQgfSA9IGNvbm5lY3Rpb247XG4gICAgY29uc3QgY29ubmVjdGluZ1RvID0gdG9IYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIHRvSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgdG9IYW5kbGU/LnR5cGUgPT09IHR5cGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGluZ0Zyb206IGZyb21IYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIGZyb21IYW5kbGU/LmlkID09PSBoYW5kbGVJZCAmJiBmcm9tSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBjb25uZWN0aW5nVG8sXG4gICAgICAgIGNsaWNrQ29ubmVjdGluZzogY2xpY2tIYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIGNsaWNrSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgY2xpY2tIYW5kbGU/LnR5cGUgPT09IHR5cGUsXG4gICAgICAgIGlzUG9zc2libGVFbmRIYW5kbGU6IGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgID8gZnJvbUhhbmRsZT8udHlwZSAhPT0gdHlwZVxuICAgICAgICAgICAgOiBub2RlSWQgIT09IGZyb21IYW5kbGU/Lm5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZT8uaWQsXG4gICAgICAgIGNvbm5lY3Rpb25JblByb2Nlc3M6ICEhZnJvbUhhbmRsZSxcbiAgICAgICAgY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWNsaWNrSGFuZGxlLFxuICAgICAgICB2YWxpZDogY29ubmVjdGluZ1RvICYmIGlzVmFsaWQsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBIYW5kbGVDb21wb25lbnQoeyB0eXBlID0gJ3NvdXJjZScsIHBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBpc1ZhbGlkQ29ubmVjdGlvbiwgaXNDb25uZWN0YWJsZSA9IHRydWUsIGlzQ29ubmVjdGFibGVTdGFydCA9IHRydWUsIGlzQ29ubmVjdGFibGVFbmQgPSB0cnVlLCBpZCwgb25Db25uZWN0LCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBvbk1vdXNlRG93biwgb25Ub3VjaFN0YXJ0LCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IGhhbmRsZUlkID0gaWQgfHwgbnVsbDtcbiAgICBjb25zdCBpc1RhcmdldCA9IHR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCB7IGNvbm5lY3RPbkNsaWNrLCBub1BhbkNsYXNzTmFtZSwgcmZJZCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZywgc2hhbGxvdyk7XG4gICAgY29uc3QgeyBjb25uZWN0aW5nRnJvbSwgY29ubmVjdGluZ1RvLCBjbGlja0Nvbm5lY3RpbmcsIGlzUG9zc2libGVFbmRIYW5kbGUsIGNvbm5lY3Rpb25JblByb2Nlc3MsIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzcywgdmFsaWQsIH0gPSB1c2VTdG9yZShjb25uZWN0aW5nU2VsZWN0b3Iobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSksIHNoYWxsb3cpO1xuICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTAnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMCddKCkpO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbm5lY3RFeHRlbmRlZCA9IChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0RWRnZU9wdGlvbnMsIG9uQ29ubmVjdDogb25Db25uZWN0QWN0aW9uLCBoYXNEZWZhdWx0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGVkZ2VQYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIHNldEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc2V0RWRnZXMoYWRkRWRnZShlZGdlUGFyYW1zLCBlZGdlcykpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ29ubmVjdEFjdGlvbj8uKGVkZ2VQYXJhbXMpO1xuICAgICAgICBvbkNvbm5lY3Q/LihlZGdlUGFyYW1zKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc01vdXNlVHJpZ2dlcmVkID0gaXNNb3VzZUV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgaWYgKGlzQ29ubmVjdGFibGVTdGFydCAmJlxuICAgICAgICAgICAgKChpc01vdXNlVHJpZ2dlcmVkICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkgfHwgIWlzTW91c2VUcmlnZ2VyZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RvcmUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgWFlIYW5kbGUub25Qb2ludGVyRG93bihldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgICAgIGhhbmRsZURvbU5vZGU6IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogY3VycmVudFN0b3JlLmF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBjdXJyZW50U3RvcmUuZG9tTm9kZSxcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwOiBjdXJyZW50U3RvcmUubm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBsaWI6IGN1cnJlbnRTdG9yZS5saWIsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGZsb3dJZDogY3VycmVudFN0b3JlLnJmSWQsXG4gICAgICAgICAgICAgICAgcGFuQnk6IGN1cnJlbnRTdG9yZS5wYW5CeSxcbiAgICAgICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUuY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogY3VycmVudFN0b3JlLm9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdEVuZDogY3VycmVudFN0b3JlLm9uQ29ubmVjdEVuZCxcbiAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUudXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEV4dGVuZGVkLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBjdXJyZW50U3RvcmUuaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3BlZWQ6IGN1cnJlbnRTdG9yZS5hdXRvUGFuU3BlZWQsXG4gICAgICAgICAgICAgICAgZHJhZ1RocmVzaG9sZDogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25EcmFnVGhyZXNob2xkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW91c2VUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIG9uTW91c2VEb3duPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0Py4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uU3RvcmUsIGxpYiwgcmZJZDogZmxvd0lkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uOiBjb25uZWN0aW9uU3RhdGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIW5vZGVJZCB8fCAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlICYmICFpc0Nvbm5lY3RhYmxlU3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSkge1xuICAgICAgICAgICAgb25DbGlja0Nvbm5lY3RTdGFydD8uKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGU6IHR5cGUgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiB7IG5vZGVJZCwgdHlwZSwgaWQ6IGhhbmRsZUlkIH0gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyID0gaXNWYWxpZENvbm5lY3Rpb24gfHwgaXNWYWxpZENvbm5lY3Rpb25TdG9yZTtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uLCBpc1ZhbGlkIH0gPSBYWUhhbmRsZS5pc1ZhbGlkKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICBoYW5kbGU6IHtcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgaWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBmcm9tTm9kZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBmcm9tSGFuZGxlSWQ6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLmlkIHx8IG51bGwsXG4gICAgICAgICAgICBmcm9tVHlwZTogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUudHlwZSxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzVmFsaWQgJiYgY29ubmVjdGlvbikge1xuICAgICAgICAgICAgb25Db25uZWN0RXh0ZW5kZWQoY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbkNsb25lID0gc3RydWN0dXJlZENsb25lKGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGRlbGV0ZSBjb25uZWN0aW9uQ2xvbmUuaW5Qcm9ncmVzcztcbiAgICAgICAgY29ubmVjdGlvbkNsb25lLnRvUG9zaXRpb24gPSBjb25uZWN0aW9uQ2xvbmUudG9IYW5kbGUgPyBjb25uZWN0aW9uQ2xvbmUudG9IYW5kbGUucG9zaXRpb24gOiBudWxsO1xuICAgICAgICBvbkNsaWNrQ29ubmVjdEVuZD8uKGV2ZW50LCBjb25uZWN0aW9uQ2xvbmUpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBudWxsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtaGFuZGxlaWRcIjogaGFuZGxlSWQsIFwiZGF0YS1ub2RlaWRcIjogbm9kZUlkLCBcImRhdGEtaGFuZGxlcG9zXCI6IHBvc2l0aW9uLCBcImRhdGEtaWRcIjogYCR7cmZJZH0tJHtub2RlSWR9LSR7aGFuZGxlSWR9LSR7dHlwZX1gLCBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICdyZWFjdC1mbG93X19oYW5kbGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2hhbmRsZS0ke3Bvc2l0aW9ufWAsXG4gICAgICAgICAgICAnbm9kcmFnJyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogIWlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIHRhcmdldDogaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVzdGFydDogaXNDb25uZWN0YWJsZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlZW5kOiBpc0Nvbm5lY3RhYmxlRW5kLFxuICAgICAgICAgICAgICAgIGNsaWNrY29ubmVjdGluZzogY2xpY2tDb25uZWN0aW5nLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmdmcm9tOiBjb25uZWN0aW5nRnJvbSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5ndG86IGNvbm5lY3RpbmdUbyxcbiAgICAgICAgICAgICAgICB2YWxpZCxcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNob3dzIHdoZXJlIHlvdSBjYW4gc3RhcnQgYSBjb25uZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAgKiBhbmQgd2hlcmUgeW91IGNhbiBlbmQgaXQgd2hpbGUgY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25pbmRpY2F0b3I6IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFjb25uZWN0aW9uSW5Qcm9jZXNzIHx8IGlzUG9zc2libGVFbmRIYW5kbGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChjb25uZWN0aW9uSW5Qcm9jZXNzIHx8IGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzcyA/IGlzQ29ubmVjdGFibGVFbmQgOiBpc0Nvbm5lY3RhYmxlU3RhcnQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIG9uTW91c2VEb3duOiBvblBvaW50ZXJEb3duLCBvblRvdWNoU3RhcnQ6IG9uUG9pbnRlckRvd24sIG9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrID8gb25DbGljayA6IHVuZGVmaW5lZCwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIFRoZSBgPEhhbmRsZSAvPmAgY29tcG9uZW50IGlzIHVzZWQgaW4geW91ciBbY3VzdG9tIG5vZGVzXSgvbGVhcm4vY3VzdG9taXphdGlvbi9jdXN0b20tbm9kZXMpXG4gKiB0byBkZWZpbmUgY29ubmVjdGlvbiBwb2ludHMuXG4gKlxuICpAcHVibGljXG4gKlxuICpAZXhhbXBsZVxuICpcbiAqYGBganN4XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24gfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21Ob2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogJzEwcHggMjBweCcgfX0+XG4gKiAgICAgICAge2RhdGEubGFiZWx9XG4gKiAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKmBgYFxuICovXG5jb25zdCBIYW5kbGUgPSBtZW1vKGZpeGVkRm9yd2FyZFJlZihIYW5kbGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gSW5wdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20gfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2RhdGE/LmxhYmVsLCBqc3goSGFuZGxlLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KV0gfSkpO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gR3JvdXBOb2RlKCkge1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBPdXRwdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbF0gfSkpO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbmNvbnN0IGJ1aWx0aW5Ob2RlVHlwZXMgPSB7XG4gICAgaW5wdXQ6IElucHV0Tm9kZSxcbiAgICBkZWZhdWx0OiBEZWZhdWx0Tm9kZSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUsXG4gICAgZ3JvdXA6IEdyb3VwTm9kZSxcbn07XG5mdW5jdGlvbiBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICBpZiAobm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IG5vZGUuc3R5bGU/LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLnN0eWxlPy5oZWlnaHQsXG4gICAgfTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkZiA9IChzKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwge1xuICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhIW5vZGUuc2VsZWN0ZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGlzTnVtZXJpYyh3aWR0aCkgPyB3aWR0aCA6IG51bGwsXG4gICAgICAgIGhlaWdodDogaXNOdW1lcmljKGhlaWdodCkgPyBoZWlnaHQgOiBudWxsLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgIHRyYW5zZm9ybVN0cmluZzogYHRyYW5zbGF0ZSgke3MudHJhbnNmb3JtWzBdfXB4LCR7cy50cmFuc2Zvcm1bMV19cHgpIHNjYWxlKCR7cy50cmFuc2Zvcm1bMl19KSB0cmFuc2xhdGUoJHt4fXB4LCR7eX1weClgLFxuICAgIH07XG59O1xuZnVuY3Rpb24gTm9kZXNTZWxlY3Rpb24oeyBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZiwgc2hhbGxvdyk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlLmdldFN0YXRlKCkubm9kZXMuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUoZXZlbnQsIHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uJywgJ3JlYWN0LWZsb3dfX2NvbnRhaW5lcicsIG5vUGFuQ2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0cmluZyxcbiAgICAgICAgfSwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHJlZjogbm9kZVJlZiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uLXJlY3RcIiwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudSwgdGFiSW5kZXg6IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiAtMSwgb25LZXlEb3duOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogb25LZXlEb3duLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIH0gfSkgfSkpO1xufVxuXG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbmNvbnN0IHNlbGVjdG9yJGUgPSAocykgPT4ge1xuICAgIHJldHVybiB7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBzLm5vZGVzU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUgfTtcbn07XG5mdW5jdGlvbiBGbG93UmVuZGVyZXJDb21wb25lbnQoeyBjaGlsZHJlbiwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogX3Bhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6IF9wYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIH0pIHtcbiAgICBjb25zdCB7IG5vZGVzU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uQWN0aXZlIH0gPSB1c2VTdG9yZShzZWxlY3RvciRlLCBzaGFsbG93KTtcbiAgICBjb25zdCBzZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moc2VsZWN0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHBhbkFjdGl2YXRpb25LZXlDb2RlLCB7IHRhcmdldDogd2luIH0pO1xuICAgIGNvbnN0IHBhbk9uRHJhZyA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PbkRyYWc7XG4gICAgY29uc3QgcGFuT25TY3JvbGwgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25TY3JvbGw7XG4gICAgY29uc3QgX3NlbGVjdGlvbk9uRHJhZyA9IHNlbGVjdGlvbk9uRHJhZyAmJiBwYW5PbkRyYWcgIT09IHRydWU7XG4gICAgY29uc3QgaXNTZWxlY3RpbmcgPSBzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHVzZXJTZWxlY3Rpb25BY3RpdmUgfHwgX3NlbGVjdGlvbk9uRHJhZztcbiAgICB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlIH0pO1xuICAgIHJldHVybiAoanN4KFpvb21QYW5lLCB7IG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiAhc2VsZWN0aW9uS2V5UHJlc3NlZCAmJiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZTogb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQ6IGlzQ29udHJvbGxlZFZpZXdwb3J0LCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIHNlbGVjdGlvbk9uRHJhZzogX3NlbGVjdGlvbk9uRHJhZywgY2hpbGRyZW46IGpzeHMoUGFuZSwgeyBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBpc1NlbGVjdGluZzogISFpc1NlbGVjdGluZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgc2VsZWN0aW9uS2V5UHJlc3NlZDogc2VsZWN0aW9uS2V5UHJlc3NlZCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBzZWxlY3Rpb25PbkRyYWc6IF9zZWxlY3Rpb25PbkRyYWcsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChqc3goTm9kZXNTZWxlY3Rpb24sIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKV0gfSkgfSkpO1xufVxuRmxvd1JlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0Zsb3dSZW5kZXJlcic7XG5jb25zdCBGbG93UmVuZGVyZXIgPSBtZW1vKEZsb3dSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJGQgPSAob25seVJlbmRlclZpc2libGUpID0+IChzKSA9PiB7XG4gICAgcmV0dXJuIG9ubHlSZW5kZXJWaXNpYmxlXG4gICAgICAgID8gZ2V0Tm9kZXNJbnNpZGUocy5ub2RlTG9va3VwLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzLndpZHRoLCBoZWlnaHQ6IHMuaGVpZ2h0IH0sIHMudHJhbnNmb3JtLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpXG4gICAgICAgIDogQXJyYXkuZnJvbShzLm5vZGVMb29rdXAua2V5cygpKTtcbn07XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgbm9kZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBub2RlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlTm9kZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzZWxlY3RvciRkKG9ubHlSZW5kZXJWaXNpYmxlKSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlSWRzO1xufVxuXG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMudXBkYXRlTm9kZUludGVybmFscztcbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKCkge1xuICAgIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VTdG9yZShzZWxlY3RvciRjKTtcbiAgICBjb25zdCBbcmVzaXplT2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGVudHJ5LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUVsZW1lbnQ6IGVudHJ5LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICAgIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGhhbmRsZSB0aGUgcmVzaXplIG9ic2VydmF0aW9uICsgaW50ZXJuYWwgdXBkYXRlcyBmb3IgdGhlIHBhc3NlZCBub2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgbm9kZVJlZiAtIHJlZmVyZW5jZSB0byB0aGUgbm9kZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IG9ic2VydmVkTm9kZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYobm9kZS5zb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlRhcmdldFBvc2l0aW9uID0gdXNlUmVmKG5vZGUudGFyZ2V0UG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdXNlUmVmKG5vZGVUeXBlKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gaGFzRGltZW5zaW9ucyAmJiAhIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50ICYmICFub2RlLmhpZGRlbiAmJiAoIWlzSW5pdGlhbGl6ZWQgfHwgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgIT09IG5vZGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUobm9kZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgfSwgW2lzSW5pdGlhbGl6ZWQsIG5vZGUuaGlkZGVuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWxzXG4gICAgICAgICAgICAgKiB0byBtYWtlIHN1cmUgdGhlIGVkZ2VzIGFyZSB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IG5vZGVUeXBlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9zQ2hhbmdlZCA9IHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlLmN1cnJlbnQgPSBub2RlVHlwZTtcbiAgICAgICAgICAgICAgICBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCA9IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVOb2RlSW50ZXJuYWxzKG5ldyBNYXAoW1tub2RlLmlkLCB7IGlkOiBub2RlLmlkLCBub2RlRWxlbWVudDogbm9kZVJlZi5jdXJyZW50LCBmb3JjZTogdHJ1ZSB9XV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtub2RlLmlkLCBub2RlVHlwZSwgbm9kZS5zb3VyY2VQb3NpdGlvbiwgbm9kZS50YXJnZXRQb3NpdGlvbl0pO1xuICAgIHJldHVybiBub2RlUmVmO1xufVxuXG5mdW5jdGlvbiBOb2RlV3JhcHBlcih7IGlkLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2ssIG5vZGVzRHJhZ2dhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCByZXNpemVPYnNlcnZlciwgbm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZCwgbm9kZVR5cGVzLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgaW50ZXJuYWxzLCBpc1BhcmVudCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBpc1BhcmVudCA9IHMucGFyZW50TG9va3VwLmhhcyhpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiBub2RlLmludGVybmFscyxcbiAgICAgICAgICAgIGlzUGFyZW50LFxuICAgICAgICB9O1xuICAgIH0sIHNoYWxsb3cpO1xuICAgIGxldCBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/Lltub2RlVHlwZV0gfHwgYnVpbHRpbk5vZGVUeXBlc1tub2RlVHlwZV07XG4gICAgaWYgKE5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgbm9kZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/LlsnZGVmYXVsdCddIHx8IGJ1aWx0aW5Ob2RlVHlwZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIShub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKG5vZGUuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBub2RlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNDb25uZWN0YWJsZSA9ICEhKG5vZGUuY29ubmVjdGFibGUgfHwgKG5vZGVzQ29ubmVjdGFibGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShub2RlLmZvY3VzYWJsZSB8fCAobm9kZXNGb2N1c2FibGUgJiYgdHlwZW9mIG5vZGUuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYXNEaW1lbnNpb25zID0gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciB9KTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgICAgICBkaXNhYmxlZDogbm9kZS5oaWRkZW4gfHwgIWlzRHJhZ2dhYmxlLFxuICAgICAgICBub0RyYWdDbGFzc05hbWUsXG4gICAgICAgIGhhbmRsZVNlbGVjdG9yOiBub2RlLmRyYWdIYW5kbGUsXG4gICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgbm9kZUNsaWNrRGlzdGFuY2UsXG4gICAgfSk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBpbmxpbmVEaW1lbnNpb25zID0gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaXNTZWxlY3RhYmxlIHx8IGlzRHJhZ2dhYmxlIHx8IG9uQ2xpY2sgfHwgb25Nb3VzZUVudGVyIHx8IG9uTW91c2VNb3ZlIHx8IG9uTW91c2VMZWF2ZTtcbiAgICBjb25zdCBvbk1vdXNlRW50ZXJIYW5kbGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IG9uTW91c2VNb3ZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTW92ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51SGFuZGxlciA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gb25Eb3VibGVDbGlja1xuICAgICAgICA/IChldmVudCkgPT4gb25Eb3VibGVDbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TZWxlY3ROb2RlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiAoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc0RyYWdnYWJsZSB8fCBub2RlRHJhZ1RocmVzaG9sZCA+IDApKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdGhpcyBoYW5kbGVyIGdldHMgY2FsbGVkIGJ5IFhZRHJhZyBvbiBkcmFnIHN0YXJ0IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9dHJ1ZVxuICAgICAgICAgICAgICogaGVyZSB3ZSBvbmx5IG5lZWQgdG8gY2FsbCBpdCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc0lucHV0RE9NTm9kZShldmVudC5uYXRpdmVFdmVudCkgfHwgZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdCxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEcmFnZ2FibGUgJiYgbm9kZS5zZWxlY3RlZCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBiZWhhdmlvciBvbiBhcnJvdyBrZXkgcHJlc3Mgd2hlbiBub2RlIGlzIG1vdmVkXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgeyBhcmlhTGFiZWxDb25maWcgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmFyaWFMaXZlTWVzc2FnZSddKHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBldmVudC5rZXkucmVwbGFjZSgnQXJyb3cnLCAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgeDogfn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiB+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25Gb2N1cyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVLZXlib2FyZEExMXkgfHwgIW5vZGVSZWYuY3VycmVudD8ubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCB3aWR0aCwgaGVpZ2h0LCBhdXRvUGFuT25Ob2RlRm9jdXMsIHNldENlbnRlciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Ob2RlRm9jdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aXRoaW5WaWV3cG9ydCA9IGdldE5vZGVzSW5zaWRlKG5ldyBNYXAoW1tpZCwgbm9kZV1dKSwgeyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0IH0sIHRyYW5zZm9ybSwgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCF3aXRoaW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgc2V0Q2VudGVyKG5vZGUucG9zaXRpb24ueCArIG5vZGVEaW1lbnNpb25zLndpZHRoIC8gMiwgbm9kZS5wb3NpdGlvbi55ICsgbm9kZURpbWVuc2lvbnMuaGVpZ2h0IC8gMiwge1xuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX25vZGUtJHtub2RlVHlwZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3ZlcndyaXRhYmxlIGJ5IHBhc3NpbmcgYG5vcGFuYCBhcyBhIGNsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpc1BhcmVudCxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIHJlZjogbm9kZVJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHpJbmRleDogaW50ZXJuYWxzLnosXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fXB4LCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueX1weClgLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogaGFzUG9pbnRlckV2ZW50cyA/ICdhbGwnIDogJ25vbmUnLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGFzRGltZW5zaW9ucyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgLi4ubm9kZS5zdHlsZSxcbiAgICAgICAgICAgIC4uLmlubGluZURpbWVuc2lvbnMsXG4gICAgICAgIH0sIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX25vZGUtJHtpZH1gLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlckhhbmRsZXIsIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZUhhbmRsZXIsIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlSGFuZGxlciwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudUhhbmRsZXIsIG9uQ2xpY2s6IG9uU2VsZWN0Tm9kZUhhbmRsZXIsIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2tIYW5kbGVyLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCBvbkZvY3VzOiBpc0ZvY3VzYWJsZSA/IG9uRm9jdXMgOiB1bmRlZmluZWQsIHJvbGU6IG5vZGUuYXJpYVJvbGUgPz8gKGlzRm9jdXNhYmxlID8gJ2dyb3VwJyA6IHVuZGVmaW5lZCksIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJub2RlXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IG5vZGUuYXJpYUxhYmVsLCAuLi5ub2RlLmRvbUF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBqc3goUHJvdmlkZXIsIHsgdmFsdWU6IGlkLCBjaGlsZHJlbjoganN4KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBub2RlLmRhdGEsIHR5cGU6IG5vZGVUeXBlLCBwb3NpdGlvbkFic29sdXRlWDogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCwgcG9zaXRpb25BYnNvbHV0ZVk6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksIHNlbGVjdGVkOiBub2RlLnNlbGVjdGVkID8/IGZhbHNlLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRyYWdnYWJsZTogaXNEcmFnZ2FibGUsIGRlbGV0YWJsZTogbm9kZS5kZWxldGFibGUgPz8gdHJ1ZSwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb246IG5vZGUuc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiBub2RlLnRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IG5vZGUuZHJhZ0hhbmRsZSwgekluZGV4OiBpbnRlcm5hbHMueiwgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsIC4uLm5vZGVEaW1lbnNpb25zIH0pIH0pIH0pKTtcbn1cbnZhciBOb2RlV3JhcHBlciQxID0gbWVtbyhOb2RlV3JhcHBlcik7XG5cbmNvbnN0IHNlbGVjdG9yJGIgPSAocykgPT4gKHtcbiAgICBub2Rlc0RyYWdnYWJsZTogcy5ub2Rlc0RyYWdnYWJsZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHMubm9kZXNGb2N1c2FibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmZ1bmN0aW9uIE5vZGVSZW5kZXJlckNvbXBvbmVudChwcm9wcykge1xuICAgIGNvbnN0IHsgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VWaXNpYmxlTm9kZUlkcyhwcm9wcy5vbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNcIiwgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE5vZGVSZW5kZXJlciBhbmRcbiAgICAgICAgICAgICAqIE5vZGVDb21wb25lbnRXcmFwcGVyIG1heSBhcHBlYXIgd2VpcmQuIEhvd2V2ZXIsIGl04oCZcyBkZXNpZ25lZCB0b1xuICAgICAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIHlvdeKAmXJlIGRyYWdnaW5nIGEgc2luZ2xlIG5vZGUsIHRoYXQgbm9kZSBnZXRzXG4gICAgICAgICAgICAgKiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIHBlciBzZWNvbmQuIElmIGBOb2RlUmVuZGVyZXJgIHdlcmUgdG8gdXBkYXRlXG4gICAgICAgICAgICAgKiBldmVyeSB0aW1lLCBpdCB3b3VsZCBoYXZlIHRvIHJlLXJ1biB0aGUgYG5vZGVzLm1hcCgpYCBsb29wIGV2ZXJ5XG4gICAgICAgICAgICAgKiB0aW1lLiBUaGlzIGdldHMgcHJpY2V5IHdpdGggaHVuZHJlZHMgb2Ygbm9kZXMsIGVzcGVjaWFsbHkgaWYgZXZlcnlcbiAgICAgICAgICAgICAqIGxvb3AgY3ljbGUgZG9lcyBtb3JlIHRoYW4ganVzdCByZW5kZXJpbmcgYSBKU1ggZWxlbWVudCFcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBcyBhIHJlc3VsdCBvZiB0aGlzIGNob2ljZSwgd2UgdG9vayB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgKiBkZWNpc2lvbnM6XG4gICAgICAgICAgICAgKiAtIE5vZGVSZW5kZXJlciBzdWJzY3JpYmVzICpvbmx5KiB0byBub2RlIElEcyDigJMgYW5kIHRoZXJlZm9yZVxuICAgICAgICAgICAgICogICByZXJlbmRlciAqb25seSogd2hlbiB2aXNpYmxlIG5vZGVzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgdGhlIHJlc3VsdCBvZiB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgICAqICAgc2hhcmVkIGJldHdlZW4gbm9kZXMgKHN1Y2ggYXMgY3JlYXRpbmcgdGhlIGBSZXNpemVPYnNlcnZlcmBcbiAgICAgICAgICAgICAqICAgaW5zdGFuY2UsIG9yIHN1YnNjcmliaW5nIHRvIGBzZWxlY3RvcmApLiBUaGlzIG1lYW5zIGV4dHJhIHByb3BcbiAgICAgICAgICAgICAqICAgZHJpbGxpbmcgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLCBidXQgaXQgbWVhbnMgd2UgbmVlZCB0byBydW5cbiAgICAgICAgICAgICAqICAgdGhlc2Ugb3BlcmF0aW9ucyBvbmx5IG9uY2Ug4oCTIGluc3RlYWQgb2Ygb25jZSBwZXIgbm9kZS5cbiAgICAgICAgICAgICAqIC0gQW55IG9wZXJhdGlvbnMgdGhhdCB5b3XigJlkIG5vcm1hbGx5IHdyaXRlIGluc2lkZSBgbm9kZXMubWFwYCBhcmVcbiAgICAgICAgICAgICAqICAgbW92ZWQgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLiBUaGlzIGVuc3VyZXMgdGhleSBhcmVcbiAgICAgICAgICAgICAqICAgbWVtb3JpemVkIOKAkyBzbyBpZiBgTm9kZVJlbmRlcmVyYCAqaGFzKiB0byByZXJlbmRlciwgaXQgb25seVxuICAgICAgICAgICAgICogICBuZWVkcyB0byByZWdlbmVyYXRlIHRoZSBsaXN0IG9mIG5vZGVzLCBub3RoaW5nIGVsc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGpzeChOb2RlV3JhcHBlciQxLCB7IGlkOiBub2RlSWQsIG5vZGVUeXBlczogcHJvcHMubm9kZVR5cGVzLCBub2RlRXh0ZW50OiBwcm9wcy5ub2RlRXh0ZW50LCBvbkNsaWNrOiBwcm9wcy5vbk5vZGVDbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk5vZGVNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogcHJvcHMub25Ob2RlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTm9kZU1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnU6IHByb3BzLm9uTm9kZUNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrOiBwcm9wcy5vbk5vZGVEb3VibGVDbGljaywgbm9EcmFnQ2xhc3NOYW1lOiBwcm9wcy5ub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBwcm9wcy5ub1BhbkNsYXNzTmFtZSwgcmZJZDogcHJvcHMucmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogcHJvcHMuZGlzYWJsZUtleWJvYXJkQTExeSwgcmVzaXplT2JzZXJ2ZXI6IHJlc2l6ZU9ic2VydmVyLCBub2Rlc0RyYWdnYWJsZTogbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlOiBwcm9wcy5ub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvcjogb25FcnJvciB9LCBub2RlSWQpKTtcbiAgICAgICAgfSkgfSkpO1xufVxuTm9kZVJlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ05vZGVSZW5kZXJlcic7XG5jb25zdCBOb2RlUmVuZGVyZXIgPSBtZW1vKE5vZGVSZW5kZXJlckNvbXBvbmVudCk7XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB0aGUgdmlzaWJsZSBlZGdlIGlkcyBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvbmx5UmVuZGVyVmlzaWJsZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIGVkZ2UgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGlmICghb25seVJlbmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUVkZ2VJZHMgPSBbXTtcbiAgICAgICAgaWYgKHMud2lkdGggJiYgcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBzLmVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRWRnZVZpc2libGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlRWRnZUlkcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZUVkZ2VJZHM7XG4gICAgfSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlSWRzO1xufVxuXG5jb25zdCBBcnJvd1N5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgLi4uKGNvbG9yICYmIHsgc3Ryb2tlOiBjb2xvciB9KSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBjbGFzc05hbWU6IFwiYXJyb3dcIiwgc3R5bGU6IHN0eWxlLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDRcIiB9KSk7XG59O1xuY29uc3QgQXJyb3dDbG9zZWRTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIC4uLihjb2xvciAmJiB7IHN0cm9rZTogY29sb3IsIGZpbGw6IGNvbG9yIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IGNsYXNzTmFtZTogXCJhcnJvd2Nsb3NlZFwiLCBzdHlsZTogc3R5bGUsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0IC01LC00XCIgfSkpO1xufTtcbmNvbnN0IE1hcmtlclN5bWJvbHMgPSB7XG4gICAgW01hcmtlclR5cGUuQXJyb3ddOiBBcnJvd1N5bWJvbCxcbiAgICBbTWFya2VyVHlwZS5BcnJvd0Nsb3NlZF06IEFycm93Q2xvc2VkU3ltYm9sLFxufTtcbmZ1bmN0aW9uIHVzZU1hcmtlclN5bWJvbCh0eXBlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW1ib2xFeGlzdHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTWFya2VyU3ltYm9scywgdHlwZSk7XG4gICAgICAgIGlmICghc3ltYm9sRXhpc3RzKSB7XG4gICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA5JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDknXSh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyU3ltYm9sc1t0eXBlXTtcbiAgICB9LCBbdHlwZV0pO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5cbmNvbnN0IE1hcmtlciA9ICh7IGlkLCB0eXBlLCBjb2xvciwgd2lkdGggPSAxMi41LCBoZWlnaHQgPSAxMi41LCBtYXJrZXJVbml0cyA9ICdzdHJva2VXaWR0aCcsIHN0cm9rZVdpZHRoLCBvcmllbnQgPSAnYXV0by1zdGFydC1yZXZlcnNlJywgfSkgPT4ge1xuICAgIGNvbnN0IFN5bWJvbCA9IHVzZU1hcmtlclN5bWJvbCh0eXBlKTtcbiAgICBpZiAoIVN5bWJvbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJtYXJrZXJcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXJyb3doZWFkXCIsIGlkOiBpZCwgbWFya2VyV2lkdGg6IGAke3dpZHRofWAsIG1hcmtlckhlaWdodDogYCR7aGVpZ2h0fWAsIHZpZXdCb3g6IFwiLTEwIC0xMCAyMCAyMFwiLCBtYXJrZXJVbml0czogbWFya2VyVW5pdHMsIG9yaWVudDogb3JpZW50LCByZWZYOiBcIjBcIiwgcmVmWTogXCIwXCIsIGNoaWxkcmVuOiBqc3goU3ltYm9sLCB7IGNvbG9yOiBjb2xvciwgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoIH0pIH0pKTtcbn07XG4vKlxuICogd2hlbiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiBhIHBhZ2UgYW5kIHlvdSBoaWRlIHRoZSBmaXJzdCBvbmUsIHRoZSBvdGhlciBvbmVzIGhhdmUgbm8gbWFya2VycyBhbnltb3JlXG4gKiB3aGVuIHRoZXkgZG8gaGF2ZSBtYXJrZXJzIHdpdGggdGhlIHNhbWUgaWRzLiBUbyBwcmV2ZW50IHRoaXMgdGhlIHVzZXIgY2FuIHBhc3MgYSB1bmlxdWUgaWQgdG8gdGhlIHJlYWN0IGZsb3cgd3JhcHBlclxuICogdGhhdCB3ZSBjYW4gdGhlbiB1c2UgZm9yIGNyZWF0aW5nIG91ciB1bmlxdWUgbWFya2VyIGlkc1xuICovXG5jb25zdCBNYXJrZXJEZWZpbml0aW9ucyA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlcyk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBjcmVhdGVNYXJrZXJJZHMoZWRnZXMsIHtcbiAgICAgICAgICAgIGlkOiByZklkLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlclN0YXJ0OiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlclN0YXJ0LFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlckVuZDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJFbmQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbZWRnZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgcmZJZCwgZGVmYXVsdENvbG9yXSk7XG4gICAgaWYgKCFtYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWFya2VyXCIsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNoaWxkcmVuOiBqc3goXCJkZWZzXCIsIHsgY2hpbGRyZW46IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChqc3goTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIHR5cGU6IG1hcmtlci50eXBlLCBjb2xvcjogbWFya2VyLmNvbG9yLCB3aWR0aDogbWFya2VyLndpZHRoLCBoZWlnaHQ6IG1hcmtlci5oZWlnaHQsIG1hcmtlclVuaXRzOiBtYXJrZXIubWFya2VyVW5pdHMsIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGgsIG9yaWVudDogbWFya2VyLm9yaWVudCB9LCBtYXJrZXIuaWQpKSkgfSkgfSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmZ1bmN0aW9uIEVkZ2VUZXh0Q29tcG9uZW50KHsgeCwgeSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnID0gdHJ1ZSwgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZyA9IFsyLCA0XSwgbGFiZWxCZ0JvcmRlclJhZGl1cyA9IDIsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IFtlZGdlVGV4dEJib3gsIHNldEVkZ2VUZXh0QmJveF0gPSB1c2VTdGF0ZSh7IHg6IDEsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgY29uc3QgZWRnZVRleHRDbGFzc2VzID0gY2MoWydyZWFjdC1mbG93X19lZGdlLXRleHR3cmFwcGVyJywgY2xhc3NOYW1lXSk7XG4gICAgY29uc3QgZWRnZVRleHRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVkZ2VUZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRCYm94ID0gZWRnZVRleHRSZWYuY3VycmVudC5nZXRCQm94KCk7XG4gICAgICAgICAgICBzZXRFZGdlVGV4dEJib3goe1xuICAgICAgICAgICAgICAgIHg6IHRleHRCYm94LngsXG4gICAgICAgICAgICAgICAgeTogdGV4dEJib3gueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4dEJib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0QmJveC5oZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtsYWJlbF0pO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhcImdcIiwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4IC0gZWRnZVRleHRCYm94LndpZHRoIC8gMn0gJHt5IC0gZWRnZVRleHRCYm94LmhlaWdodCAvIDJ9KWAsIGNsYXNzTmFtZTogZWRnZVRleHRDbGFzc2VzLCB2aXNpYmlsaXR5OiBlZGdlVGV4dEJib3gud2lkdGggPyAndmlzaWJsZScgOiAnaGlkZGVuJywgLi4ucmVzdCwgY2hpbGRyZW46IFtsYWJlbFNob3dCZyAmJiAoanN4KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLCBqc3goXCJ0ZXh0XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dFwiLCB5OiBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMiwgZHk6IFwiMC4zZW1cIiwgcmVmOiBlZGdlVGV4dFJlZiwgc3R5bGU6IGxhYmVsU3R5bGUsIGNoaWxkcmVuOiBsYWJlbCB9KSwgY2hpbGRyZW5dIH0pKTtcbn1cbkVkZ2VUZXh0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VUZXh0Jztcbi8qKlxuICogWW91IGNhbiB1c2UgdGhlIGA8RWRnZVRleHQgLz5gIGNvbXBvbmVudCBhcyBhIGhlbHBlciBjb21wb25lbnQgdG8gZGlzcGxheSB0ZXh0XG4gKiB3aXRoaW4geW91ciBjdXN0b20gZWRnZXMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IEVkZ2VUZXh0IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2VMYWJlbCh7IGxhYmVsIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8RWRnZVRleHRcbiAqICAgICAgIHg9ezEwMH1cbiAqICAgICAgIHk9ezEwMH1cbiAqICAgICAgIGxhYmVsPXtsYWJlbH1cbiAqICAgICAgIGxhYmVsU3R5bGU9e3sgZmlsbDogJ3doaXRlJyB9fVxuICogICAgICAgbGFiZWxTaG93QmdcbiAqICAgICAgIGxhYmVsQmdTdHlsZT17eyBmaWxsOiAncmVkJyB9fVxuICogICAgICAgbGFiZWxCZ1BhZGRpbmc9e1syLCA0XX1cbiAqICAgICAgIGxhYmVsQmdCb3JkZXJSYWRpdXM9ezJ9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqYGBgXG4gKi9cbmNvbnN0IEVkZ2VUZXh0ID0gbWVtbyhFZGdlVGV4dENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGA8QmFzZUVkZ2UgLz5gIGNvbXBvbmVudCBnZXRzIHVzZWQgaW50ZXJuYWxseSBmb3IgYWxsIHRoZSBlZGdlcy4gSXQgY2FuIGJlXG4gKiB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIGFuZCBoYW5kbGVzIHRoZSBpbnZpc2libGUgaGVscGVyIGVkZ2UgYW5kIHRoZSBlZGdlIGxhYmVsXG4gKiBmb3IgeW91LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgQmFzZUVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgLi4ucHJvcHMgfSkge1xuICogIGNvbnN0IFtlZGdlUGF0aF0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWCxcbiAqICAgIHNvdXJjZVksXG4gKiAgICB0YXJnZXRYLFxuICogICAgdGFyZ2V0WSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIDxCYXNlRWRnZSBwYXRoPXtlZGdlUGF0aH0gey4uLnByb3BzfSAvPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3Ugd2FudCB0byB1c2UgYW4gZWRnZSBtYXJrZXIgd2l0aCB0aGUgW2A8QmFzZUVkZ2UgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2Jhc2UtZWRnZSkgY29tcG9uZW50LFxuICogeW91IGNhbiBwYXNzIHRoZSBgbWFya2VyU3RhcnRgIG9yIGBtYXJrZXJFbmRgIHByb3BzIHBhc3NlZCB0byB5b3VyIGN1c3RvbSBlZGdlXG4gKiB0aHJvdWdoIHRvIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQuXG4gKiBZb3UgY2FuIHNlZSBhbGwgdGhlIHByb3BzIHBhc3NlZCB0byBhIGN1c3RvbSBlZGdlIGJ5IGxvb2tpbmcgYXQgdGhlIFtgRWRnZVByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZS1wcm9wcykgdHlwZS5cbiAqL1xuZnVuY3Rpb24gQmFzZUVkZ2UoeyBwYXRoLCBsYWJlbFgsIGxhYmVsWSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBpbnRlcmFjdGlvbldpZHRoID0gMjAsIC4uLnByb3BzIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgLi4ucHJvcHMsIGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fZWRnZS1wYXRoJywgcHJvcHMuY2xhc3NOYW1lXSkgfSksIGludGVyYWN0aW9uV2lkdGggPyAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSkgOiBudWxsLCBsYWJlbCAmJiBpc051bWVyaWMobGFiZWxYKSAmJiBpc051bWVyaWMobGFiZWxZKSA/IChqc3goRWRnZVRleHQsIHsgeDogbGFiZWxYLCB5OiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSA6IG51bGxdIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbCh7IHBvcywgeDEsIHkxLCB4MiwgeTIgfSkge1xuICAgIGlmIChwb3MgPT09IFBvc2l0aW9uLkxlZnQgfHwgcG9zID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gWzAuNSAqICh4MSArIHgyKSwgeTFdO1xuICAgIH1cbiAgICByZXR1cm4gW3gxLCAwLjUgKiAoeTEgKyB5MildO1xufVxuLyoqXG4gKiBUaGUgYGdldFNpbXBsZUJlemllclBhdGhgIHV0aWwgcmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHJlbmRlciBhIHNpbXBsZVxuICogYmV6aWVyIGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0U2ltcGxlQmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbCh7XG4gICAgICAgIHBvczogc291cmNlUG9zaXRpb24sXG4gICAgICAgIHgxOiBzb3VyY2VYLFxuICAgICAgICB5MTogc291cmNlWSxcbiAgICAgICAgeDI6IHRhcmdldFgsXG4gICAgICAgIHkyOiB0YXJnZXRZLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbCh7XG4gICAgICAgIHBvczogdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHgxOiB0YXJnZXRYLFxuICAgICAgICB5MTogdGFyZ2V0WSxcbiAgICAgICAgeDI6IHNvdXJjZVgsXG4gICAgICAgIHkyOiBzb3VyY2VZLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNpbXBsZUJlemllckVkZ2UgPSBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG5jb25zdCBTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwgPSBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNpbXBsZUJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZSc7XG5TaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU21vb3RoU3RlcEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogcGF0aE9wdGlvbnM/LmJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgIG9mZnNldDogcGF0aE9wdGlvbnM/Lm9mZnNldCxcbiAgICAgICAgICAgIHN0ZXBQb3NpdGlvbjogcGF0aE9wdGlvbnM/LnN0ZXBQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHNtb290aCBzdGVwIGVkZ2UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFNtb290aFN0ZXBFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFNtb290aFN0ZXBFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU21vb3RoU3RlcEVkZ2UgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNtb290aFN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlJztcblNtb290aFN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChTbW9vdGhTdGVwRWRnZSwgeyAuLi5wcm9wcywgaWQ6IF9pZCwgcGF0aE9wdGlvbnM6IHVzZU1lbW8oKCkgPT4gKHsgYm9yZGVyUmFkaXVzOiAwLCBvZmZzZXQ6IHByb3BzLnBhdGhPcHRpb25zPy5vZmZzZXQgfSksIFtwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0XSkgfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzdGVwIGVkZ2UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFN0ZXBFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFN0ZXBFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU3RlcEVkZ2UgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlJztcblN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmFpZ2h0RWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHN0cmFpZ2h0IGxpbmUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFN0cmFpZ2h0RWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U3RyYWlnaHRFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU3RyYWlnaHRFZGdlID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdHJhaWdodEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblN0cmFpZ2h0RWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBiZXppZXIgY3VydmUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IEJlemllckVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8QmV6aWVyRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEJlemllckVkZ2UgPSBjcmVhdGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCZXppZXJFZGdlSW50ZXJuYWwgPSBjcmVhdGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcbkJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZSc7XG5CZXppZXJFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZUludGVybmFsJztcblxuY29uc3QgYnVpbHRpbkVkZ2VUeXBlcyA9IHtcbiAgICBkZWZhdWx0OiBCZXppZXJFZGdlSW50ZXJuYWwsXG4gICAgc3RyYWlnaHQ6IFN0cmFpZ2h0RWRnZUludGVybmFsLFxuICAgIHN0ZXA6IFN0ZXBFZGdlSW50ZXJuYWwsXG4gICAgc21vb3Roc3RlcDogU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzaW1wbGViZXppZXI6IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCxcbn07XG5jb25zdCBudWxsUG9zaXRpb24gPSB7XG4gICAgc291cmNlWDogbnVsbCxcbiAgICBzb3VyY2VZOiBudWxsLFxuICAgIHRhcmdldFg6IG51bGwsXG4gICAgdGFyZ2V0WTogbnVsbCxcbiAgICBzb3VyY2VQb3NpdGlvbjogbnVsbCxcbiAgICB0YXJnZXRQb3NpdGlvbjogbnVsbCxcbn07XG5cbmNvbnN0IHNoaWZ0WCA9ICh4LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQpXG4gICAgICAgIHJldHVybiB4IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodClcbiAgICAgICAgcmV0dXJuIHggKyBzaGlmdDtcbiAgICByZXR1cm4geDtcbn07XG5jb25zdCBzaGlmdFkgPSAoeSwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3ApXG4gICAgICAgIHJldHVybiB5IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Cb3R0b20pXG4gICAgICAgIHJldHVybiB5ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHk7XG59O1xuY29uc3QgRWRnZVVwZGF0ZXJDbGFzc05hbWUgPSAncmVhY3QtZmxvd19fZWRnZXVwZGF0ZXInO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gRWRnZUFuY2hvcih7IHBvc2l0aW9uLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgPSAxMCwgb25Nb3VzZURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZU91dCwgdHlwZSwgfSkge1xuICAgIHJldHVybiAoanN4KFwiY2lyY2xlXCIsIHsgb25Nb3VzZURvd246IG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlciwgb25Nb3VzZU91dDogb25Nb3VzZU91dCwgY2xhc3NOYW1lOiBjYyhbRWRnZVVwZGF0ZXJDbGFzc05hbWUsIGAke0VkZ2VVcGRhdGVyQ2xhc3NOYW1lfS0ke3R5cGV9YF0pLCBjeDogc2hpZnRYKGNlbnRlclgsIHJhZGl1cywgcG9zaXRpb24pLCBjeTogc2hpZnRZKGNlbnRlclksIHJhZGl1cywgcG9zaXRpb24pLCByOiByYWRpdXMsIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBmaWxsOiBcInRyYW5zcGFyZW50XCIgfSkpO1xufVxuXG5mdW5jdGlvbiBFZGdlVXBkYXRlQW5jaG9ycyh7IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzLCBlZGdlLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgc2V0UmVjb25uZWN0aW5nLCBzZXRVcGRhdGVIb3ZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYW5kbGVFZGdlVXBkYXRlciA9IChldmVudCwgb3Bwb3NpdGVIYW5kbGUpID0+IHtcbiAgICAgICAgLy8gYXZvaWQgdHJpZ2dlcmluZyBlZGdlIHVwZGF0ZXIgaWYgbW91c2UgYnRuIGlzIG5vdCBsZWZ0XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGF1dG9QYW5PbkNvbm5lY3QsIGRvbU5vZGUsIGlzVmFsaWRDb25uZWN0aW9uLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgbGliLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBjYW5jZWxDb25uZWN0aW9uLCBub2RlTG9va3VwLCByZklkOiBmbG93SWQsIHBhbkJ5LCB1cGRhdGVDb25uZWN0aW9uLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgaXNUYXJnZXQgPSBvcHBvc2l0ZUhhbmRsZS50eXBlID09PSAndGFyZ2V0JztcbiAgICAgICAgY29uc3QgX29uUmVjb25uZWN0RW5kID0gKGV2dCwgY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ29ubmVjdEVkZ2UgPSAoY29ubmVjdGlvbikgPT4gb25SZWNvbm5lY3Q/LihlZGdlLCBjb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3QgX29uQ29ubmVjdFN0YXJ0ID0gKF9ldmVudCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgICAgICBvblJlY29ubmVjdFN0YXJ0Py4oZXZlbnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUpO1xuICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ/LihfZXZlbnQsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0OiBfb25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICBvbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZDogX29uUmVjb25uZWN0RW5kLFxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsXG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlOiBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgeyBub2RlSWQ6IGVkZ2UudGFyZ2V0LCBpZDogZWRnZS50YXJnZXRIYW5kbGUgPz8gbnVsbCwgdHlwZTogJ3RhcmdldCcgfSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS5zb3VyY2UsIGlkOiBlZGdlLnNvdXJjZUhhbmRsZSA/PyBudWxsLCB0eXBlOiAnc291cmNlJyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdE1vdXNlRW50ZXIgPSAoKSA9PiBzZXRVcGRhdGVIb3Zlcih0cnVlKTtcbiAgICBjb25zdCBvblJlY29ubmVjdE1vdXNlT3V0ID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIoZmFsc2UpO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyhpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAnc291cmNlJykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgY2VudGVyWDogc291cmNlWCwgY2VudGVyWTogc291cmNlWSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwic291cmNlXCIgfSkpLCAoaXNSZWNvbm5lY3RhYmxlID09PSB0cnVlIHx8IGlzUmVjb25uZWN0YWJsZSA9PT0gJ3RhcmdldCcpICYmIChqc3goRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGNlbnRlclg6IHRhcmdldFgsIGNlbnRlclk6IHRhcmdldFksIHJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbk1vdXNlRG93bjogb25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25SZWNvbm5lY3RNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvblJlY29ubmVjdE1vdXNlT3V0LCB0eXBlOiBcInRhcmdldFwiIH0pKV0gfSkpO1xufVxuXG5mdW5jdGlvbiBFZGdlV3JhcHBlcih7IGlkLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIG9uQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uRXJyb3IsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBsZXQgZWRnZSA9IHVzZVN0b3JlKChzKSA9PiBzLmVkZ2VMb29rdXAuZ2V0KGlkKSk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBlZGdlID0gZGVmYXVsdEVkZ2VPcHRpb25zID8geyAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsIC4uLmVkZ2UgfSA6IGVkZ2U7XG4gICAgbGV0IGVkZ2VUeXBlID0gZWRnZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICBsZXQgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlcz8uW2VkZ2VUeXBlXSB8fCBidWlsdGluRWRnZVR5cGVzW2VkZ2VUeXBlXTtcbiAgICBpZiAoRWRnZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDExJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTEnXShlZGdlVHlwZSkpO1xuICAgICAgICBlZGdlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlcz8uWydkZWZhdWx0J10gfHwgYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgICAgIHpJbmRleE1vZGU6IHN0b3JlLnpJbmRleE1vZGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgLi4uKGVkZ2VQb3NpdGlvbiB8fCBudWxsUG9zaXRpb24pLFxuICAgICAgICB9O1xuICAgIH0sIFtlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQsIGVkZ2Uuc291cmNlSGFuZGxlLCBlZGdlLnRhcmdldEhhbmRsZSwgZWRnZS5zZWxlY3RlZCwgZWRnZS56SW5kZXhdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgbWFya2VyU3RhcnRVcmwgPSB1c2VNZW1vKCgpID0+IChlZGdlLm1hcmtlclN0YXJ0ID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJTdGFydCwgcmZJZCl9JylgIDogdW5kZWZpbmVkKSwgW2VkZ2UubWFya2VyU3RhcnQsIHJmSWRdKTtcbiAgICBjb25zdCBtYXJrZXJFbmRVcmwgPSB1c2VNZW1vKCgpID0+IChlZGdlLm1hcmtlckVuZCA/IGB1cmwoJyMke2dldE1hcmtlcklkKGVkZ2UubWFya2VyRW5kLCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJFbmQsIHJmSWRdKTtcbiAgICBpZiAoZWRnZS5oaWRkZW4gfHwgc291cmNlWCA9PT0gbnVsbCB8fCBzb3VyY2VZID09PSBudWxsIHx8IHRhcmdldFggPT09IG51bGwgfHwgdGFyZ2V0WSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25FZGdlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBhZGRTZWxlY3RlZEVkZ2VzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChlZGdlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtdLCBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgZWRnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRWRnZURvdWJsZUNsaWNrID0gb25Eb3VibGVDbGlja1xuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Eb3VibGVDbGljayhldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZUNvbnRleHRNZW51ID0gb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Db250ZXh0TWVudShldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZU1vdXNlRW50ZXIgPSBvbk1vdXNlRW50ZXJcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZU1vdXNlTW92ZSA9IG9uTW91c2VNb3ZlXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZShldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZU1vdXNlTGVhdmUgPSBvbk1vdXNlTGVhdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZShldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkgJiYgZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBhZGRTZWxlY3RlZEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgaWYgKHVuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgZWRnZXM6IFtlZGdlXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgc3R5bGU6IHsgekluZGV4IH0sIGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgICAgICdyZWFjdC1mbG93X19lZGdlJyxcbiAgICAgICAgICAgICAgICBgcmVhY3QtZmxvd19fZWRnZS0ke2VkZ2VUeXBlfWAsXG4gICAgICAgICAgICAgICAgZWRnZS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogZWRnZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZWQ6IGVkZ2UuYW5pbWF0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiAhaXNTZWxlY3RhYmxlICYmICFvbkNsaWNrLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGluZzogdXBkYXRlSG92ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSksIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCByb2xlOiBlZGdlLmFyaWFSb2xlID8/IChpc0ZvY3VzYWJsZSA/ICdncm91cCcgOiAnaW1nJyksIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJlZGdlXCIsIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX2VkZ2UtJHtpZH1gLCBcImFyaWEtbGFiZWxcIjogZWRnZS5hcmlhTGFiZWwgPT09IG51bGwgPyB1bmRlZmluZWQgOiBlZGdlLmFyaWFMYWJlbCB8fCBgRWRnZSBmcm9tICR7ZWRnZS5zb3VyY2V9IHRvICR7ZWRnZS50YXJnZXR9YCwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGlzRm9jdXNhYmxlID8gYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCA6IHVuZGVmaW5lZCwgcmVmOiBlZGdlUmVmLCAuLi5lZGdlLmRvbUF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBbIXJlY29ubmVjdGluZyAmJiAoanN4KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IGVkZ2Uuc291cmNlLCB0YXJnZXQ6IGVkZ2UudGFyZ2V0LCB0eXBlOiBlZGdlLnR5cGUsIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogZWRnZS5hbmltYXRlZCwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkZWxldGFibGU6IGVkZ2UuZGVsZXRhYmxlID8/IHRydWUsIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZGF0YTogZWRnZS5kYXRhLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpLCBpc1JlY29ubmVjdGFibGUgJiYgKGpzeChFZGdlVXBkYXRlQW5jaG9ycywgeyBlZGdlOiBlZGdlLCBpc1JlY29ubmVjdGFibGU6IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc2V0VXBkYXRlSG92ZXI6IHNldFVwZGF0ZUhvdmVyLCBzZXRSZWNvbm5lY3Rpbmc6IHNldFJlY29ubmVjdGluZyB9KSldIH0pIH0pKTtcbn1cbnZhciBFZGdlV3JhcHBlciQxID0gbWVtbyhFZGdlV3JhcHBlcik7XG5cbmNvbnN0IHNlbGVjdG9yJGEgPSAocykgPT4gKHtcbiAgICBlZGdlc0ZvY3VzYWJsZTogcy5lZGdlc0ZvY3VzYWJsZSxcbiAgICBlZGdlc1JlY29ubmVjdGFibGU6IHMuZWRnZXNSZWNvbm5lY3RhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgY29ubmVjdGlvbk1vZGU6IHMuY29ubmVjdGlvbk1vZGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBFZGdlUmVuZGVyZXJDb21wb25lbnQoeyBkZWZhdWx0TWFya2VyQ29sb3IsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uUmVjb25uZWN0LCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VDbGljaywgcmVjb25uZWN0UmFkaXVzLCBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCB7IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlc1wiLCBjaGlsZHJlbjogW2pzeChNYXJrZXJEZWZpbml0aW9ucyQxLCB7IGRlZmF1bHRDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCByZklkOiByZklkIH0pLCBlZGdlSWRzLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeChFZGdlV3JhcHBlciQxLCB7IGlkOiBpZCwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgcmZJZDogcmZJZCwgb25FcnJvcjogb25FcnJvciwgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSwgaWQpKTtcbiAgICAgICAgICAgIH0pXSB9KSk7XG59XG5FZGdlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVJlbmRlcmVyJztcbmNvbnN0IEVkZ2VSZW5kZXJlciA9IG1lbW8oRWRnZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3IkOSA9IChzKSA9PiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pYDtcbmZ1bmN0aW9uIFZpZXdwb3J0KHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHVzZVN0b3JlKHNlbGVjdG9yJDkpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0IHh5Zmxvd19fdmlld3BvcnQgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIHN0eWxlOiB7IHRyYW5zZm9ybSB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgb25Jbml0IGhhbmRsZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KSB7XG4gICAgY29uc3QgcmZJbnN0YW5jZSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNJbml0aWFsaXplZC5jdXJyZW50ICYmIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZCAmJiBvbkluaXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb25Jbml0KHJmSW5zdGFuY2UpLCAxKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbb25Jbml0LCByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkOCA9IChzdGF0ZSkgPT4gc3RhdGUucGFuWm9vbT8uc3luY1ZpZXdwb3J0O1xuLyoqXG4gKiBIb29rIGZvciBzeW5jaW5nIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBwYW56b29tIGluc3RhbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCkge1xuICAgIGNvbnN0IHN5bmNWaWV3cG9ydCA9IHVzZVN0b3JlKHNlbGVjdG9yJDgpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgIHN5bmNWaWV3cG9ydD8uKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgdHJhbnNmb3JtOiBbdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQuem9vbV0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbdmlld3BvcnQsIHN5bmNWaWV3cG9ydF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzdG9yZVNlbGVjdG9yJDEocykge1xuICAgIHJldHVybiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzc1xuICAgICAgICA/IHsgLi4ucy5jb25uZWN0aW9uLCB0bzogcG9pbnRUb1JlbmRlcmVyUG9pbnQocy5jb25uZWN0aW9uLnRvLCBzLnRyYW5zZm9ybSkgfVxuICAgICAgICA6IHsgLi4ucy5jb25uZWN0aW9uIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBpZiAoY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSAocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHN0b3JlU2VsZWN0b3IkMShzKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uU2VsZWN0b3IoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21iaW5lZFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmVTZWxlY3RvciQxO1xufVxuLyoqXG4gKiBUaGUgYHVzZUNvbm5lY3Rpb25gIGhvb2sgcmV0dXJucyB0aGUgY3VycmVudCBjb25uZWN0aW9uIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlXG4gKiBjb25uZWN0aW9uIGludGVyYWN0aW9uLiBJZiBubyBjb25uZWN0aW9uIGludGVyYWN0aW9uIGlzIGFjdGl2ZSwgaXQgcmV0dXJucyBudWxsXG4gKiBmb3IgZXZlcnkgcHJvcGVydHkuIEEgdHlwaWNhbCB1c2UgY2FzZSBmb3IgdGhpcyBob29rIGlzIHRvIGNvbG9yaXplIGhhbmRsZXNcbiAqIGJhc2VkIG9uIGEgY2VydGFpbiBjb25kaXRpb24gKGUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgdmFsaWQgb3Igbm90KS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY29ubmVjdGlvblNlbGVjdG9yIC0gQW4gb3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0byBleHRyYWN0IGEgc2xpY2Ugb2YgdGhlXG4gKiBgQ29ubmVjdGlvblN0YXRlYCBkYXRhLiBVc2luZyBhIHNlbGVjdG9yIGNhbiBwcmV2ZW50IGNvbXBvbmVudCByZS1yZW5kZXJzIHdoZXJlIGRhdGEgeW91IGRvbid0XG4gKiBvdGhlcndpc2UgY2FyZSBhYm91dCBtaWdodCBjaGFuZ2UuIElmIGEgc2VsZWN0b3IgaXMgbm90IHByb3ZpZGVkLCB0aGUgZW50aXJlIGBDb25uZWN0aW9uU3RhdGVgXG4gKiBvYmplY3QgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gQXBwKCkge1xuICogIGNvbnN0IGNvbm5lY3Rpb24gPSB1c2VDb25uZWN0aW9uKCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PiB7Y29ubmVjdGlvbiA/IGBTb21lb25lIGlzIHRyeWluZyB0byBtYWtlIGEgY29ubmVjdGlvbiBmcm9tICR7Y29ubmVjdGlvbi5mcm9tTm9kZX0gdG8gdGhpcyBvbmUuYCA6ICdUaGVyZSBhcmUgY3VycmVudGx5IG5vIGluY29taW5nIGNvbm5lY3Rpb25zISd9XG4gKlxuICogICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIENvbm5lY3Rpb25TdGF0ZVxuICovXG5mdW5jdGlvbiB1c2VDb25uZWN0aW9uKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpO1xuICAgIHJldHVybiB1c2VTdG9yZShjb21iaW5lZFNlbGVjdG9yLCBzaGFsbG93KTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNyA9IChzKSA9PiAoe1xuICAgIG5vZGVzQ29ubmVjdGFibGU6IHMubm9kZXNDb25uZWN0YWJsZSxcbiAgICBpc1ZhbGlkOiBzLmNvbm5lY3Rpb24uaXNWYWxpZCxcbiAgICBpblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxufSk7XG5mdW5jdGlvbiBDb25uZWN0aW9uTGluZVdyYXBwZXIoeyBjb250YWluZXJTdHlsZSwgc3R5bGUsIHR5cGUsIGNvbXBvbmVudCwgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNDb25uZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgaXNWYWxpZCwgaW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVuZGVyQ29ubmVjdGlvbiA9ICEhKHdpZHRoICYmIG5vZGVzQ29ubmVjdGFibGUgJiYgaW5Qcm9ncmVzcyk7XG4gICAgaWYgKCFyZW5kZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiBjb250YWluZXJTdHlsZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb25saW5lIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb25uZWN0aW9uJywgZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKV0pLCBjaGlsZHJlbjoganN4KENvbm5lY3Rpb25MaW5lLCB7IHN0eWxlOiBzdHlsZSwgdHlwZTogdHlwZSwgQ3VzdG9tQ29tcG9uZW50OiBjb21wb25lbnQsIGlzVmFsaWQ6IGlzVmFsaWQgfSkgfSkgfSkpO1xufVxuY29uc3QgQ29ubmVjdGlvbkxpbmUgPSAoeyBzdHlsZSwgdHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIEN1c3RvbUNvbXBvbmVudCwgaXNWYWxpZCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgZnJvbSwgZnJvbU5vZGUsIGZyb21IYW5kbGUsIGZyb21Qb3NpdGlvbiwgdG8sIHRvTm9kZSwgdG9IYW5kbGUsIHRvUG9zaXRpb24sIHBvaW50ZXIgfSA9IHVzZUNvbm5lY3Rpb24oKTtcbiAgICBpZiAoIWluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQ3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoanN4KEN1c3RvbUNvbXBvbmVudCwgeyBjb25uZWN0aW9uTGluZVR5cGU6IHR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IHN0eWxlLCBmcm9tTm9kZTogZnJvbU5vZGUsIGZyb21IYW5kbGU6IGZyb21IYW5kbGUsIGZyb21YOiBmcm9tLngsIGZyb21ZOiBmcm9tLnksIHRvWDogdG8ueCwgdG9ZOiB0by55LCBmcm9tUG9zaXRpb246IGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbjogdG9Qb3NpdGlvbiwgY29ubmVjdGlvblN0YXR1czogZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSwgdG9Ob2RlOiB0b05vZGUsIHRvSGFuZGxlOiB0b0hhbmRsZSwgcG9pbnRlcjogcG9pbnRlciB9KSk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gJyc7XG4gICAgY29uc3QgcGF0aFBhcmFtcyA9IHtcbiAgICAgICAgc291cmNlWDogZnJvbS54LFxuICAgICAgICBzb3VyY2VZOiBmcm9tLnksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFg6IHRvLngsXG4gICAgICAgIHRhcmdldFk6IHRvLnksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uOiB0b1Bvc2l0aW9uLFxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldEJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU2ltcGxlQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U2ltcGxlQmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgICAgIC4uLnBhdGhQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU21vb3RoU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTdHJhaWdodFBhdGgocGF0aFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBqc3goXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9uLXBhdGhcIiwgc3R5bGU6IHN0eWxlIH0pO1xufTtcbkNvbm5lY3Rpb25MaW5lLmRpc3BsYXlOYW1lID0gJ0Nvbm5lY3Rpb25MaW5lJztcblxuY29uc3QgZW1wdHlUeXBlcyA9IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZU9yRWRnZVR5cGVzID0gZW1wdHlUeXBlcykge1xuICAgIGNvbnN0IHR5cGVzUmVmID0gdXNlUmVmKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgdXNlZEtleXMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyh0eXBlc1JlZi5jdXJyZW50KSwgLi4uT2JqZWN0LmtleXMobm9kZU9yRWRnZVR5cGVzKV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZEtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZXNSZWYuY3VycmVudFtrZXldICE9PSBub2RlT3JFZGdlVHlwZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDAyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDInXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXNSZWYuY3VycmVudCA9IG5vZGVPckVkZ2VUeXBlcztcbiAgICAgICAgfVxuICAgIH0sIFtub2RlT3JFZGdlVHlwZXNdKTtcbn1cblxuZnVuY3Rpb24gdXNlU3R5bGVzTG9hZGVkV2FybmluZygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgY2hlY2tlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcGFuZScpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lICYmICEod2luZG93LmdldENvbXB1dGVkU3R5bGUocGFuZSkuekluZGV4ID09PSAnMScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMyddKCdyZWFjdCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gR3JhcGhWaWV3Q29tcG9uZW50KHsgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uSW5pdCwgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZGVsZXRlS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxlbWVudHNTZWxlY3RhYmxlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgZGVmYXVsdE1hcmtlckNvbG9yLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50LCByZklkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgfSkge1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZVR5cGVzKTtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKGVkZ2VUeXBlcyk7XG4gICAgdXNlU3R5bGVzTG9hZGVkV2FybmluZygpO1xuICAgIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KTtcbiAgICB1c2VWaWV3cG9ydFN5bmModmlld3BvcnQpO1xuICAgIHJldHVybiAoanN4KEZsb3dSZW5kZXJlciwgeyBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogISF2aWV3cG9ydCwgY2hpbGRyZW46IGpzeHMoVmlld3BvcnQsIHsgY2hpbGRyZW46IFtqc3goRWRnZVJlbmRlcmVyLCB7IGVkZ2VUeXBlczogZWRnZVR5cGVzLCBvbkVkZ2VDbGljazogb25FZGdlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkOiByZklkIH0pLCBqc3goQ29ubmVjdGlvbkxpbmVXcmFwcGVyLCB7IHN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCB0eXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbnRhaW5lclN0eWxlOiBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyXCIgfSksIGpzeChOb2RlUmVuZGVyZXIsIHsgbm9kZVR5cGVzOiBub2RlVHlwZXMsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIHJmSWQ6IHJmSWQgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWxcIiB9KV0gfSkgfSkpO1xufVxuR3JhcGhWaWV3Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0dyYXBoVmlldyc7XG5jb25zdCBHcmFwaFZpZXcgPSBtZW1vKEdyYXBoVmlld0NvbXBvbmVudCk7XG5cbmNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgekluZGV4TW9kZSA9ICdiYXNpYycsIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IG5vZGVMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGFyZW50TG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Mb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWRnZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdG9yZUVkZ2VzID0gZGVmYXVsdEVkZ2VzID8/IGVkZ2VzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZXMgPSBkZWZhdWx0Tm9kZXMgPz8gbm9kZXMgPz8gW107XG4gICAgY29uc3Qgc3RvcmVOb2RlT3JpZ2luID0gbm9kZU9yaWdpbiA/PyBbMCwgMF07XG4gICAgY29uc3Qgc3RvcmVOb2RlRXh0ZW50ID0gbm9kZUV4dGVudCA/PyBpbmZpbml0ZUV4dGVudDtcbiAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIHN0b3JlRWRnZXMpO1xuICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2RlcyhzdG9yZU5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50OiBzdG9yZU5vZGVFeHRlbnQsXG4gICAgICAgIHpJbmRleE1vZGUsXG4gICAgfSk7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFswLCAwLCAxXTtcbiAgICBpZiAoZml0VmlldyAmJiB3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2RlTG9va3VwLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhISgobm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkgJiYgKG5vZGUuaGVpZ2h0IHx8IG5vZGUuaW5pdGlhbEhlaWdodCkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIGZpdFZpZXdPcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgIHRyYW5zZm9ybSA9IFt4LCB5LCB6b29tXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmZJZDogJzEnLFxuICAgICAgICB3aWR0aDogd2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBub2Rlczogc3RvcmVOb2RlcyxcbiAgICAgICAgbm9kZXNJbml0aWFsaXplZCxcbiAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgcGFyZW50TG9va3VwLFxuICAgICAgICBlZGdlczogc3RvcmVFZGdlcyxcbiAgICAgICAgZWRnZUxvb2t1cCxcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cCxcbiAgICAgICAgb25Ob2Rlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgb25FZGdlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgaGFzRGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgaGFzRGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuWm9vbTogbnVsbCxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IENvbm5lY3Rpb25Nb2RlLlN0cmljdCxcbiAgICAgICAgZG9tTm9kZTogbnVsbCxcbiAgICAgICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZURyYWdUaHJlc2hvbGQ6IDEsXG4gICAgICAgIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBzbmFwR3JpZDogWzE1LCAxNV0sXG4gICAgICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgICAgICBub2Rlc0RyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIGVkZ2VzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc1JlY29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGVsZXZhdGVFZGdlc09uU2VsZWN0OiB0cnVlLFxuICAgICAgICBzZWxlY3ROb2Rlc09uRHJhZzogdHJ1ZSxcbiAgICAgICAgbXVsdGlTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICBmaXRWaWV3UXVldWVkOiBmaXRWaWV3ID8/IGZhbHNlLFxuICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgZml0Vmlld1Jlc29sdmVyOiBudWxsLFxuICAgICAgICBjb25uZWN0aW9uOiB7IC4uLmluaXRpYWxDb25uZWN0aW9uIH0sXG4gICAgICAgIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBudWxsLFxuICAgICAgICBjb25uZWN0T25DbGljazogdHJ1ZSxcbiAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiAnJyxcbiAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogdHJ1ZSxcbiAgICAgICAgYXV0b1Bhbk9uTm9kZURyYWc6IHRydWUsXG4gICAgICAgIGF1dG9QYW5Pbk5vZGVGb2N1czogdHJ1ZSxcbiAgICAgICAgYXV0b1BhblNwZWVkOiAxNSxcbiAgICAgICAgY29ubmVjdGlvblJhZGl1czogMjAsXG4gICAgICAgIG9uRXJyb3I6IGRldldhcm4sXG4gICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IFtdLFxuICAgICAgICBsaWI6ICdyZWFjdCcsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgYXJpYUxhYmVsQ29uZmlnOiBkZWZhdWx0QXJpYUxhYmVsQ29uZmlnLFxuICAgICAgICB6SW5kZXhNb2RlLFxuICAgICAgICBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcDogbmV3IE1hcCgpLFxuICAgICAgICBvbkVkZ2VzQ2hhbmdlTWlkZGxld2FyZU1hcDogbmV3IE1hcCgpLFxuICAgIH07XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBtaW5ab29tLCBtYXhab29tLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB6SW5kZXhNb2RlLCB9KSA9PiBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiByZXNvbHZlRml0VmlldygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBwYW5ab29tLCBmaXRWaWV3T3B0aW9ucywgZml0Vmlld1Jlc29sdmVyLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZml0Vmlld3BvcnQoe1xuICAgICAgICAgICAgbm9kZXM6IG5vZGVMb29rdXAsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgfSwgZml0Vmlld09wdGlvbnMpO1xuICAgICAgICBmaXRWaWV3UmVzb2x2ZXI/LnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3YWl0IGZvciB0aGUgZml0Vmlld3BvcnQgdG8gcmVzb2x2ZSBiZWZvcmUgZGVsZXRpbmcgdGhlIHJlc29sdmVyLFxuICAgICAgICAgKiB3ZSB3YW50IHRvIHJldXNlIHRoZSBvbGQgcmVzb2x2ZXIgaWYgdGhlIHVzZXIgY2FsbHMgZml0VmlldyBhZ2FpbiBpbiB0aGUgbWVhbiB0aW1lXG4gICAgICAgICAqL1xuICAgICAgICBzZXQoeyBmaXRWaWV3UmVzb2x2ZXI6IG51bGwgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldEluaXRpYWxTdGF0ZSh7XG4gICAgICAgICAgICBub2RlcyxcbiAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBmaXRWaWV3LFxuICAgICAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICAgICAgZGVmYXVsdEVkZ2VzLFxuICAgICAgICAgICAgekluZGV4TW9kZSxcbiAgICAgICAgfSksXG4gICAgICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZml0Vmlld1F1ZXVlZCwgekluZGV4TW9kZSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogc2V0Tm9kZXMoKSBpcyBjYWxsZWQgZXhjbHVzaXZlbHkgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zOlxuICAgICAgICAgICAgICogLSBlaXRoZXIgd2hlbiB0aGUgYDxSZWFjdEZsb3cgbm9kZXM+YCBwcm9wIGlzIHVwZGF0ZWQgaW4gdGhlIGNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLFxuICAgICAgICAgICAgICogLSBvciB3aGVuIHRoZSB1c2VyIGNhbGxzIHNvbWV0aGluZyBsaWtlIGByZWFjdEZsb3dJbnN0YW5jZS5zZXROb2RlcygpYCBpbiBhbiB1bmNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSB0YWtlIHRoZSBub3RlIG9iamVjdHMgcGFzc2VkIGJ5IHRoZSB1c2VyIGFuZCBleHRlbmQgdGhlbSB3aXRoIGZpZWxkc1xuICAgICAgICAgICAgICogcmVsZXZhbnQgZm9yIGludGVybmFsIFJlYWN0IEZsb3cgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6SW5kZXhNb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCAmJiBub2Rlc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUZpdFZpZXcoKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBub2Rlcywgbm9kZXNJbml0aWFsaXplZCwgZml0Vmlld1F1ZXVlZDogZmFsc2UsIGZpdFZpZXdPcHRpb25zOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXQoeyBub2Rlcywgbm9kZXNJbml0aWFsaXplZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0RWRnZXM6IChlZGdlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpO1xuICAgICAgICAgICAgc2V0KHsgZWRnZXMgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNldE5vZGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgc2V0KHsgaGFzRGVmYXVsdE5vZGVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXRFZGdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2V0RWRnZXMoZWRnZXMpO1xuICAgICAgICAgICAgICAgIHNldCh7IGhhc0RlZmF1bHRFZGdlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLypcbiAgICAgICAgICogRXZlcnkgbm9kZSBnZXRzIHJlZ2lzdGVyZCBhdCBhIFJlc2l6ZU9ic2VydmVyLiBXaGVuZXZlciBhIG5vZGVcbiAgICAgICAgICogY2hhbmdlcyBpdHMgZGltZW5zaW9ucywgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbWVhc3VyZSB0aGVcbiAgICAgICAgICogbmV3IGRpbWVuc2lvbnMgYW5kIHVwZGF0ZSB0aGUgbm9kZXMuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVOb2RlSW50ZXJuYWxzOiAodXBkYXRlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VyTm9kZUNoYW5nZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgZG9tTm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgZGVidWcsIGZpdFZpZXdRdWV1ZWQsIHpJbmRleE1vZGUsIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9ID0gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVkSW50ZXJuYWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMobm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUgfSk7XG4gICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaXRWaWV3KCk7XG4gICAgICAgICAgICAgICAgc2V0KHsgZml0Vmlld1F1ZXVlZDogZmFsc2UsIGZpdFZpZXdPcHRpb25zOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHdheXMgd2FudCB0byB0cmlnZ2VyIHVzZVN0b3JlIGNhbGxzIHdoZW5ldmVyIHVwZGF0ZU5vZGVJbnRlcm5hbHMgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgc2V0KHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9uczogKG5vZGVEcmFnSXRlbXMsIGRyYWdnaW5nID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoaWxkcmVuID0gW107XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIGNvbm5lY3Rpb24sIHVwZGF0ZUNvbm5lY3Rpb24sIG9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2Ygbm9kZURyYWdJdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgbm9kZWxvb2t1cCB0byBiZSBzdXJlIHRvIHVzZSB0aGUgY3VycmVudCBleHBhbmRQYXJlbnQgYW5kIHBhcmVudElkIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBhbmRQYXJlbnQgPSAhIShub2RlPy5leHBhbmRQYXJlbnQgJiYgbm9kZT8ucGFyZW50SWQgJiYgZHJhZ0l0ZW0/LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwYW5kUGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLm1heCgwLCBkcmFnSXRlbS5wb3NpdGlvbi54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLm1heCgwLCBkcmFnSXRlbS5wb3NpdGlvbi55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgY29ubmVjdGlvbi5pblByb2dyZXNzICYmIGNvbm5lY3Rpb24uZnJvbU5vZGUuaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZyb20gPSBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBjb25uZWN0aW9uLmZyb21IYW5kbGUsIFBvc2l0aW9uLkxlZnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uKHsgLi4uY29ubmVjdGlvbiwgZnJvbTogdXBkYXRlZEZyb20gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFeHBhbmRDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRyYWdJdGVtLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IG1pZGRsZXdhcmUoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlczogKGNoYW5nZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Ob2Rlc0NoYW5nZSwgc2V0Tm9kZXMsIG5vZGVzLCBoYXNEZWZhdWx0Tm9kZXMsIGRlYnVnIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXROb2Rlcyh1cGRhdGVkTm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgbm9kZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkVkZ2VzQ2hhbmdlLCBzZXRFZGdlcywgZWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEVkZ2VzID0gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEVkZ2VzKHVwZGF0ZWRFZGdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBlZGdlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25FZGdlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRTZWxlY3RlZE5vZGVzOiAoc2VsZWN0ZWROb2RlSWRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG11bHRpU2VsZWN0aW9uQWN0aXZlLCBlZGdlTG9va3VwLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IHNlbGVjdGVkTm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGVJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgbmV3IFNldChbLi4uc2VsZWN0ZWROb2RlSWRzXSksIHRydWUpKTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXApKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VsZWN0ZWRFZGdlczogKHNlbGVjdGVkRWRnZUlkcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgZWRnZUxvb2t1cCwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZEVkZ2VzID0gc2VsZWN0ZWRFZGdlSWRzLm1hcCgoZWRnZUlkKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZWRFZGdlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgbmV3IFNldChbLi4uc2VsZWN0ZWRFZGdlSWRzXSkpKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoKSwgdHJ1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXM6ICh7IG5vZGVzLCBlZGdlcyB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXM6IHN0b3JlRWRnZXMsIG5vZGVzOiBzdG9yZU5vZGVzLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCBub2Rlc1RvVW5zZWxlY3QgPSBub2RlcyA/IG5vZGVzIDogc3RvcmVOb2RlcztcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzVG9VbnNlbGVjdCA9IGVkZ2VzID8gZWRnZXMgOiBzdG9yZUVkZ2VzO1xuICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlc1RvVW5zZWxlY3QubWFwKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlID0gbm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIHVuc2VsZWN0IHRoZSBpbnRlcm5hbCBub2RlIHRoYXQgd2FzIHNlbGVjdGVkIHByZXZpb3VzbHkgYmVmb3JlIHdlXG4gICAgICAgICAgICAgICAgICAgICAqIHNlbmQgdGhlIGNoYW5nZSB0byB0aGUgdXNlciB0byBwcmV2ZW50IGl0IHRvIGJlIHNlbGVjdGVkIHdoaWxlIGRyYWdnaW5nIHRoZSBuZXcgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxOb2RlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBlZGdlQ2hhbmdlcyA9IGVkZ2VzVG9VbnNlbGVjdC5tYXAoKGVkZ2UpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlLmlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldE1pblpvb206IChtaW5ab29tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBhblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICAgICAgcGFuWm9vbT8uc2V0U2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgICAgIHNldCh7IG1pblpvb20gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldE1heFpvb206IChtYXhab29tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBhblpvb20sIG1pblpvb20gfSA9IGdldCgpO1xuICAgICAgICAgICAgcGFuWm9vbT8uc2V0U2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgICAgIHNldCh7IG1heFpvb20gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRyYW5zbGF0ZUV4dGVudDogKHRyYW5zbGF0ZUV4dGVudCkgPT4ge1xuICAgICAgICAgICAgZ2V0KCkucGFuWm9vbT8uc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgICAgICBzZXQoeyB0cmFuc2xhdGVFeHRlbnQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50czogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBlbGVtZW50c1NlbGVjdGFibGUgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzLnJlZHVjZSgocmVzLCBub2RlKSA9PiAobm9kZS5zZWxlY3RlZCA/IFsuLi5yZXMsIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShub2RlLmlkLCBmYWxzZSldIDogcmVzKSwgW10pO1xuICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlcy5yZWR1Y2UoKHJlcywgZWRnZSkgPT4gKGVkZ2Uuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXROb2RlRXh0ZW50OiAobmV4dE5vZGVFeHRlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG5leHROb2RlRXh0ZW50WzBdWzBdID09PSBub2RlRXh0ZW50WzBdWzBdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMF1bMV0gPT09IG5vZGVFeHRlbnRbMF1bMV0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVswXSA9PT0gbm9kZUV4dGVudFsxXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzFdWzFdID09PSBub2RlRXh0ZW50WzFdWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgbm9kZUV4dGVudDogbmV4dE5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgekluZGV4TW9kZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0KHsgbm9kZUV4dGVudDogbmV4dE5vZGVFeHRlbnQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhbkJ5OiAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCB3aWR0aCwgaGVpZ2h0LCBwYW5ab29tLCB0cmFuc2xhdGVFeHRlbnQgfSA9IGdldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhbkJ5KHsgZGVsdGEsIHBhblpvb20sIHRyYW5zZm9ybSwgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDZW50ZXI6IGFzeW5jICh4LCB5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1heFpvb20sIHBhblpvb20gfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0Wm9vbSA9IHR5cGVvZiBvcHRpb25zPy56b29tICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuem9vbSA6IG1heFpvb207XG4gICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICB4OiB3aWR0aCAvIDIgLSB4ICogbmV4dFpvb20sXG4gICAgICAgICAgICAgICAgeTogaGVpZ2h0IC8gMiAtIHkgKiBuZXh0Wm9vbSxcbiAgICAgICAgICAgICAgICB6b29tOiBuZXh0Wm9vbSxcbiAgICAgICAgICAgIH0sIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uLCBlYXNlOiBvcHRpb25zPy5lYXNlLCBpbnRlcnBvbGF0ZTogb3B0aW9ucz8uaW50ZXJwb2xhdGUgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxDb25uZWN0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IHsgLi4uaW5pdGlhbENvbm5lY3Rpb24gfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVDb25uZWN0aW9uOiAoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgICAgc2V0KHsgY29ubmVjdGlvbiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHNldCh7IC4uLmdldEluaXRpYWxTdGF0ZSgpIH0pLFxuICAgIH07XG59LCBPYmplY3QuaXMpO1xuXG4vKipcbiAqIFRoZSBgPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+YCBjb21wb25lbnQgaXMgYSBbY29udGV4dCBwcm92aWRlcl0oaHR0cHM6Ly9yZWFjdC5kZXYvbGVhcm4vcGFzc2luZy1kYXRhLWRlZXBseS13aXRoLWNvbnRleHQjKVxuICogdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBhY2Nlc3MgYSBmbG93J3MgaW50ZXJuYWwgc3RhdGUgb3V0c2lkZSBvZiB0aGVcbiAqIFtgPFJlYWN0RmxvdyAvPmBdKC9hcGktcmVmZXJlbmNlL3JlYWN0LWZsb3cpIGNvbXBvbmVudC4gTWFueSBvZiB0aGUgaG9va3Mgd2VcbiAqIHByb3ZpZGUgcmVseSBvbiB0aGlzIGNvbXBvbmVudCB0byB3b3JrLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBSZWFjdEZsb3dQcm92aWRlciwgdXNlTm9kZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0Rmxvd1Byb3ZpZGVyPlxuICogICAgICA8UmVhY3RGbG93IG5vZGVzPXsuLi59IGVkZ2VzPXsuLi59IC8+XG4gKiAgICAgIDxTaWRlYmFyIC8+XG4gKiAgICA8L1JlYWN0Rmxvd1Byb3ZpZGVyPlxuICogICk7XG4gKn1cbiAqXG4gKmZ1bmN0aW9uIFNpZGViYXIoKSB7XG4gKiAgLy8gVGhpcyBob29rIHdpbGwgb25seSB3b3JrIGlmIHRoZSBjb21wb25lbnQgaXQncyB1c2VkIGluIGlzIGEgY2hpbGQgb2YgYVxuICogIC8vIDxSZWFjdEZsb3dQcm92aWRlciAvPi5cbiAqICBjb25zdCBub2RlcyA9IHVzZU5vZGVzKClcbiAqXG4gKiAgcmV0dXJuIDxhc2lkZT5kbyBzb21ldGhpbmcgd2l0aCBub2RlczwvYXNpZGU+O1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIElmIHlvdSdyZSB1c2luZyBhIHJvdXRlciBhbmQgd2FudCB5b3VyIGZsb3cncyBzdGF0ZSB0byBwZXJzaXN0IGFjcm9zcyByb3V0ZXMsXG4gKiBpdCdzIHZpdGFsIHRoYXQgeW91IHBsYWNlIHRoZSBgPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+YCBjb21wb25lbnQgX291dHNpZGVfIG9mXG4gKiB5b3VyIHJvdXRlci4gSWYgeW91IGhhdmUgbXVsdGlwbGUgZmxvd3Mgb24gdGhlIHNhbWUgcGFnZSB5b3Ugd2lsbCBuZWVkIHRvIHVzZSBhIHNlcGFyYXRlXG4gKiBgPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+YCBmb3IgZWFjaCBmbG93LlxuICovXG5mdW5jdGlvbiBSZWFjdEZsb3dQcm92aWRlcih7IGluaXRpYWxOb2Rlczogbm9kZXMsIGluaXRpYWxFZGdlczogZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGluaXRpYWxNaW5ab29tOiBtaW5ab29tLCBpbml0aWFsTWF4Wm9vbTogbWF4Wm9vbSwgaW5pdGlhbEZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgZml0Vmlldywgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgekluZGV4TW9kZSwgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBbc3RvcmVdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlU3RvcmUoe1xuICAgICAgICBub2RlcyxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIGRlZmF1bHROb2RlcyxcbiAgICAgICAgZGVmYXVsdEVkZ2VzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBmaXRWaWV3LFxuICAgICAgICBtaW5ab29tLFxuICAgICAgICBtYXhab29tLFxuICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgekluZGV4TW9kZSxcbiAgICB9KSk7XG4gICAgcmV0dXJuIChqc3goUHJvdmlkZXIkMSwgeyB2YWx1ZTogc3RvcmUsIGNoaWxkcmVuOiBqc3goQmF0Y2hQcm92aWRlciwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBXcmFwcGVyKHsgY2hpbGRyZW4sIG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBtaW5ab29tLCBtYXhab29tLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB6SW5kZXhNb2RlLCB9KSB7XG4gICAgY29uc3QgaXNXcmFwcGVkID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChpc1dyYXBwZWQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogd2UgbmVlZCB0byB3cmFwIGl0IHdpdGggYSBmcmFnbWVudCBiZWNhdXNlIGl0J3Mgbm90IGFsbG93ZWQgZm9yIGNoaWxkcmVuIHRvIGJlIGEgUmVhY3ROb2RlXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2lzc3Vlcy8xODA1MVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFJlYWN0Rmxvd1Byb3ZpZGVyLCB7IGluaXRpYWxOb2Rlczogbm9kZXMsIGluaXRpYWxFZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3LCBpbml0aWFsRml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBpbml0aWFsTWluWm9vbTogbWluWm9vbSwgaW5pdGlhbE1heFpvb206IG1heFpvb20sIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIHpJbmRleE1vZGU6IHpJbmRleE1vZGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDAsXG59O1xuZnVuY3Rpb24gUmVhY3RGbG93KHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgY2xhc3NOYW1lLCBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbkluaXQsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3AsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlLCBvblNlbGVjdGlvbkNoYW5nZSwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RvcCwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG9uQmVmb3JlRGVsZXRlLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvbkxpbmVUeXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIGRlbGV0ZUtleUNvZGUgPSAnQmFja3NwYWNlJywgc2VsZWN0aW9uS2V5Q29kZSA9ICdTaGlmdCcsIHNlbGVjdGlvbk9uRHJhZyA9IGZhbHNlLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSA9ICdTcGFjZScsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgem9vbUFjdGl2YXRpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IGZhbHNlLCBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZXNEcmFnZ2FibGUsIGF1dG9QYW5Pbk5vZGVGb2N1cywgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIG5vZGVPcmlnaW4gPSBkZWZhdWx0Tm9kZU9yaWdpbiwgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQkMSA9IGRlZmF1bHRWaWV3cG9ydCwgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIHRyYW5zbGF0ZUV4dGVudCA9IGluZmluaXRlRXh0ZW50LCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgbm9kZUV4dGVudCwgZGVmYXVsdE1hcmtlckNvbG9yID0gJyNiMWIxYjcnLCB6b29tT25TY3JvbGwgPSB0cnVlLCB6b29tT25QaW5jaCA9IHRydWUsIHBhbk9uU2Nyb2xsID0gZmFsc2UsIHBhbk9uU2Nyb2xsU3BlZWQgPSAwLjUsIHBhbk9uU2Nyb2xsTW9kZSA9IFBhbk9uU2Nyb2xsTW9kZS5GcmVlLCB6b29tT25Eb3VibGVDbGljayA9IHRydWUsIHBhbk9uRHJhZyA9IHRydWUsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlID0gMSwgbm9kZUNsaWNrRGlzdGFuY2UgPSAwLCBjaGlsZHJlbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2ssIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzID0gMTAsIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIG5vRHJhZ0NsYXNzTmFtZSA9ICdub2RyYWcnLCBub1doZWVsQ2xhc3NOYW1lID0gJ25vd2hlZWwnLCBub1BhbkNsYXNzTmFtZSA9ICdub3BhbicsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBjb25uZWN0T25DbGljaywgYXR0cmlidXRpb25Qb3NpdGlvbiwgcHJvT3B0aW9ucywgZGVmYXVsdEVkZ2VPcHRpb25zLCBlbGV2YXRlTm9kZXNPblNlbGVjdCA9IHRydWUsIGVsZXZhdGVFZGdlc09uU2VsZWN0ID0gZmFsc2UsIGRpc2FibGVLZXlib2FyZEExMXkgPSBmYWxzZSwgYXV0b1Bhbk9uQ29ubmVjdCwgYXV0b1Bhbk9uTm9kZURyYWcsIGF1dG9QYW5TcGVlZCwgY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb24sIG9uRXJyb3IsIHN0eWxlLCBpZCwgbm9kZURyYWdUaHJlc2hvbGQsIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgd2lkdGgsIGhlaWdodCwgY29sb3JNb2RlID0gJ2xpZ2h0JywgZGVidWcsIG9uU2Nyb2xsLCBhcmlhTGFiZWxDb25maWcsIHpJbmRleE1vZGUgPSAnYmFzaWMnLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHJmSWQgPSBpZCB8fCAnMSc7XG4gICAgY29uc3QgY29sb3JNb2RlQ2xhc3NOYW1lID0gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAvLyBVbmRvIHNjcm9sbCBldmVudHMsIHByZXZlbnRpbmcgdmlld3BvcnQgZnJvbSBzaGlmdGluZyB3aGVuIG5vZGVzIG91dHNpZGUgb2YgaXQgYXJlIGZvY3VzZWRcbiAgICBjb25zdCB3cmFwcGVyT25TY3JvbGwgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsVG8oeyB0b3A6IDAsIGxlZnQ6IDAsIGJlaGF2aW9yOiAnaW5zdGFudCcgfSk7XG4gICAgICAgIG9uU2Nyb2xsPy4oZSk7XG4gICAgfSwgW29uU2Nyb2xsXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgLi4ucmVzdCwgb25TY3JvbGw6IHdyYXBwZXJPblNjcm9sbCwgc3R5bGU6IHsgLi4uc3R5bGUsIC4uLndyYXBwZXJTdHlsZSB9LCByZWY6IHJlZiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3cnLCBjbGFzc05hbWUsIGNvbG9yTW9kZUNsYXNzTmFtZV0pLCBpZDogaWQsIHJvbGU6IFwiYXBwbGljYXRpb25cIiwgY2hpbGRyZW46IGpzeHMoV3JhcHBlciwgeyBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB6SW5kZXhNb2RlOiB6SW5kZXhNb2RlLCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXM6IGF1dG9QYW5Pbk5vZGVGb2N1cywgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdDogZWxldmF0ZUVkZ2VzT25TZWxlY3QsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIG9uTm9kZXNDaGFuZ2U6IG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2U6IG9uRWRnZXNDaGFuZ2UsIHNuYXBUb0dyaWQ6IHNuYXBUb0dyaWQsIHNuYXBHcmlkOiBzbmFwR3JpZCwgY29ubmVjdGlvbk1vZGU6IGNvbm5lY3Rpb25Nb2RlLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgY29ubmVjdE9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrLCBkZWZhdWx0RWRnZU9wdGlvbnM6IGRlZmF1bHRFZGdlT3B0aW9ucywgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBvbk5vZGVzRGVsZXRlOiBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlOiBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZTogb25EZWxldGUsIG9uTm9kZURyYWdTdGFydDogb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnOiBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcDogb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZzogb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdGFydDogb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0b3A6IG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIHJmSWQ6IHJmSWQsIGF1dG9QYW5PbkNvbm5lY3Q6IGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnOiBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkOiBhdXRvUGFuU3BlZWQsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZDogbm9kZURyYWdUaHJlc2hvbGQsIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkOiBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBkZWJ1ZzogZGVidWcsIGFyaWFMYWJlbENvbmZpZzogYXJpYUxhYmVsQ29uZmlnLCB6SW5kZXhNb2RlOiB6SW5kZXhNb2RlIH0pLCBqc3goU2VsZWN0aW9uTGlzdGVuZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLCBjaGlsZHJlbiwganN4KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLCBqc3goQTExeURlc2NyaXB0aW9ucywgeyByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pXSB9KSB9KSk7XG59XG4vKipcbiAqIFRoZSBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50IGlzIHRoZSBoZWFydCBvZiB5b3VyIFJlYWN0IEZsb3cgYXBwbGljYXRpb24uXG4gKiBJdCByZW5kZXJzIHlvdXIgbm9kZXMgYW5kIGVkZ2VzIGFuZCBoYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKDxSZWFjdEZsb3dcbiAqICAgIG5vZGVzPXsuLi59XG4gKiAgICBlZGdlcz17Li4ufVxuICogICAgb25Ob2Rlc0NoYW5nZT17Li4ufVxuICogICAgLi4uXG4gKiAgLz4pO1xuICp9XG4gKmBgYFxuICovXG52YXIgaW5kZXggPSBmaXhlZEZvcndhcmRSZWYoUmVhY3RGbG93KTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXInKTtcbi8qKlxuICogRWRnZXMgYXJlIFNWRy1iYXNlZC4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIG1vcmUgY29tcGxleCBsYWJlbHMgeW91IGNhbiB1c2UgdGhlXG4gKiBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBjb21wb25lbnQgdG8gYWNjZXNzIGEgZGl2IGJhc2VkIHJlbmRlcmVyLiBUaGlzIGNvbXBvbmVudFxuICogaXMgYSBwb3J0YWwgdGhhdCByZW5kZXJzIHRoZSBsYWJlbCBpbiBhIGA8ZGl2IC8+YCB0aGF0IGlzIHBvc2l0aW9uZWQgb24gdG9wIG9mXG4gKiB0aGUgZWRnZXMuIFlvdSBjYW4gc2VlIGFuIGV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGNvbXBvbmVudCBpbiB0aGVcbiAqIFtlZGdlIGxhYmVsIHJlbmRlcmVyIGV4YW1wbGVdKC9leGFtcGxlcy9lZGdlcy9lZGdlLWxhYmVsLXJlbmRlcmVyKS5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgZ2V0QmV6aWVyUGF0aCwgRWRnZUxhYmVsUmVuZGVyZXIsIEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBpZCwgZGF0YSwgLi4ucHJvcHMgfSkge1xuICogICBjb25zdCBbZWRnZVBhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgocHJvcHMpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8PlxuICogICAgICAgPEJhc2VFZGdlIGlkPXtpZH0gcGF0aD17ZWRnZVBhdGh9IC8+XG4gKiAgICAgICA8RWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgICAgIDxkaXZcbiAqICAgICAgICAgICBzdHlsZT17e1xuICogICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gKiAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgdHJhbnNsYXRlKCR7bGFiZWxYfXB4LCR7bGFiZWxZfXB4KWAsXG4gKiAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmY2MwMCcsXG4gKiAgICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAqICAgICAgICAgfX1cbiAqICAgICAgICAgICBjbGFzc05hbWU9XCJub2RyYWcgbm9wYW5cIlxuICogICAgICAgICA+XG4gKiAgICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICA8L0VkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgIDwvPlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoZSBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBoYXMgbm8gcG9pbnRlciBldmVudHMgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG9cbiAqIGFkZCBtb3VzZSBpbnRlcmFjdGlvbnMgeW91IG5lZWQgdG8gc2V0IHRoZSBzdHlsZSBgcG9pbnRlckV2ZW50czogYWxsYCBhbmQgYWRkXG4gKiB0aGUgYG5vcGFuYCBjbGFzcyBvbiB0aGUgbGFiZWwgb3IgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gaW50ZXJhY3Qgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQ2KTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDUgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsJyk7XG4vKipcbiAqIFRoZSBgPFZpZXdwb3J0UG9ydGFsIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYWRkIGNvbXBvbmVudHMgdG8gdGhlIHNhbWUgdmlld3BvcnRcbiAqIG9mIHRoZSBmbG93IHdoZXJlIG5vZGVzIGFuZCBlZGdlcyBhcmUgcmVuZGVyZWQuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXG4gKiB5b3VyIG93biBjb21wb25lbnRzIHRoYXQgYXJlIGFkaGVyZSB0byB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgbm9kZXMgJiBlZGdlc1xuICogYW5kIGFyZSBhbHNvIGFmZmVjdGVkIGJ5IHpvb21pbmcgYW5kIHBhbm5pbmdcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganN4XG4gKmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFZpZXdwb3J0UG9ydGFsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxWaWV3cG9ydFBvcnRhbD5cbiAqICAgICAgPGRpdlxuICogICAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMDBweCwgMTAwcHgpJywgcG9zaXRpb246ICdhYnNvbHV0ZScgfX1cbiAqICAgICAgPlxuICogICAgICAgIFRoaXMgZGl2IGlzIHBvc2l0aW9uZWQgYXQgWzEwMCwgMTAwXSBvbiB0aGUgZmxvdy5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8L1ZpZXdwb3J0UG9ydGFsPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIFZpZXdwb3J0UG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHZpZXdQb3J0YWxEaXYgPSB1c2VTdG9yZShzZWxlY3RvciQ1KTtcbiAgICBpZiAoIXZpZXdQb3J0YWxEaXYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHZpZXdQb3J0YWxEaXYpO1xufVxuXG4vKipcbiAqIFdoZW4geW91IHByb2dyYW1tYXRpY2FsbHkgYWRkIG9yIHJlbW92ZSBoYW5kbGVzIHRvIGEgbm9kZSBvciB1cGRhdGUgYSBub2RlJ3NcbiAqIGhhbmRsZSBwb3NpdGlvbiwgeW91IG5lZWQgdG8gbGV0IFJlYWN0IEZsb3cga25vdyBhYm91dCBpdCB1c2luZyB0aGlzIGhvb2suIFRoaXNcbiAqIHdpbGwgdXBkYXRlIHRoZSBpbnRlcm5hbCBkaW1lbnNpb25zIG9mIHRoZSBub2RlIGFuZCBwcm9wZXJseSByZXBvc2l0aW9uIGhhbmRsZXNcbiAqIG9uIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHRlbGwgUmVhY3QgRmxvdyB0byB1cGRhdGUgdGhlIGludGVybmFsIHN0YXRlIG9mIG9uZSBvciBtb3JlIG5vZGVzXG4gKiB0aGF0IHlvdSBoYXZlIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSYW5kb21IYW5kbGVOb2RlKHsgaWQgfSkge1xuICogIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCk7XG4gKiAgY29uc3QgW2hhbmRsZUNvdW50LCBzZXRIYW5kbGVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCByYW5kb21pemVIYW5kbGVDb3VudCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAqICAgc2V0SGFuZGxlQ291bnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApKTtcbiAqICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHMoaWQpO1xuICogIH0sIFtpZCwgdXBkYXRlTm9kZUludGVybmFsc10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAge0FycmF5LmZyb20oeyBsZW5ndGg6IGhhbmRsZUNvdW50IH0pLm1hcCgoXywgaW5kZXgpID0+IChcbiAqICAgICAgICA8SGFuZGxlXG4gKiAgICAgICAgICBrZXk9e2luZGV4fVxuICogICAgICAgICAgdHlwZT1cInRhcmdldFwiXG4gKiAgICAgICAgICBwb3NpdGlvbj1cImxlZnRcIlxuICogICAgICAgICAgaWQ9e2BoYW5kbGUtJHtpbmRleH1gfVxuICogICAgICAgIC8+XG4gKiAgICAgICkpfVxuICpcbiAqICAgICAgPGRpdj5cbiAqICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JhbmRvbWl6ZUhhbmRsZUNvdW50fT5SYW5kb21pemUgaGFuZGxlIGNvdW50PC9idXR0b24+XG4gKiAgICAgICAgPHA+VGhlcmUgYXJlIHtoYW5kbGVDb3VudH0gaGFuZGxlcyBvbiB0aGlzIG5vZGUuPC9wPlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgY2FuIG9ubHkgYmUgdXNlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGEgY2hpbGQgb2YgYVxuICp7QGxpbmsgUmVhY3RGbG93UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFJlYWN0Rmxvd30gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgdXBkYXRlTm9kZUludGVybmFscyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVwZGF0ZUlkcy5mb3JFYWNoKCh1cGRhdGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW1lbnQgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKGAucmVhY3QtZmxvd19fbm9kZVtkYXRhLWlkPVwiJHt1cGRhdGVJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KHVwZGF0ZUlkLCB7IGlkOiB1cGRhdGVJZCwgbm9kZUVsZW1lbnQsIGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgeyB0cmlnZ2VyRml0VmlldzogZmFsc2UgfSkpO1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3Qgbm9kZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUubm9kZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IG5vZGVzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgbm9kZSBjaGFuZ2VzKiosIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZFxuICogb3IgbW92ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG5vZGVzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAqICBjb25zdCBub2RlcyA9IHVzZU5vZGVzKCk7XG4gKlxuICogIHJldHVybiA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge25vZGVzLmxlbmd0aH0gbm9kZXMhPC9kaXY+O1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGVkZ2VzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgZWRnZSBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIGVkZ2VzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgZWRnZXMgPSB1c2VFZGdlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtlZGdlcy5sZW5ndGh9IGVkZ2VzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXMoKSB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZShlZGdlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZXM7XG59XG5cbmNvbnN0IHZpZXdwb3J0U2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG59KTtcbi8qKlxuICogVGhlIGB1c2VWaWV3cG9ydGAgaG9vayBpcyBhIGNvbnZlbmllbnQgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gKiB7QGxpbmsgVmlld3BvcnR9IGluIGEgY29tcG9uZW50LiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciB0aGUgdmlld3BvcnQgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlVmlld3BvcnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdwb3J0RGlzcGxheSgpIHtcbiAqICBjb25zdCB7IHgsIHksIHpvb20gfSA9IHVzZVZpZXdwb3J0KCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5cbiAqICAgICAgICBUaGUgdmlld3BvcnQgaXMgY3VycmVudGx5IGF0ICh7eH0sIHt5fSkgYW5kIHpvb21lZCB0byB7em9vbX0uXG4gKiAgICAgIDwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBub2Rlc2A6IFRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzLiBZb3UgbWlnaHQgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgbm9kZXNgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCwgb3IgeW91IG1heSB3YW50IHRvIG1hbmlwdWxhdGUgaXQgZmlyc3QgdG8gcGVyZm9ybSBzb21lIGxheW91dGluZyxcbiAqIGZvciBleGFtcGxlLlxuICogLSBgc2V0Tm9kZXNgOiBBIGZ1bmN0aW9uIHRoYXQgeW91IGNhbiB1c2UgdG8gdXBkYXRlIHRoZSBub2Rlcy4gWW91IGNhbiBwYXNzIGl0IGEgbmV3IGFycmF5IG9mXG4gKiBub2RlcyBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygbm9kZXMuXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdHVwbGUgcmV0dXJuZWQgYnkgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2suXG4gKiAtIGBvbk5vZGVzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBOb2RlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgbm9kZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uTm9kZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcykge1xuICAgIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAgICBjb25zdCBvbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldE5vZGVzKChuZHMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbmRzKSksIFtdKTtcbiAgICByZXR1cm4gW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV07XG59XG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgZWRnZXNgOiBUaGUgY3VycmVudCBhcnJheSBvZiBlZGdlcy4gWW91IG1pZ2h0IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYGVkZ2VzYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQsIG9yIHlvdSBtYXkgd2FudCB0byBtYW5pcHVsYXRlIGl0IGZpcnN0IHRvIHBlcmZvcm0gc29tZSBsYXlvdXRpbmcsXG4gKiBmb3IgZXhhbXBsZS5cbiAqXG4gKiAtIGBzZXRFZGdlc2A6IEEgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIHVzZSB0byB1cGRhdGUgdGhlIGVkZ2VzLiBZb3UgY2FuIHBhc3MgaXQgYSBuZXcgYXJyYXkgb2ZcbiAqIGVkZ2VzIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBhcnJheSBvZiBlZGdlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBlZGdlcy5cbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSB0dXBsZSByZXR1cm5lZCBieSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vay5cbiAqXG4gKiAtIGBvbkVkZ2VzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBFZGdlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgZWRnZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uRWRnZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcykge1xuICAgIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAgICBjb25zdCBvbkVkZ2VzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEVkZ2VzKChlZHMpID0+IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRzKSksIFtdKTtcbiAgICByZXR1cm4gW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV07XG59XG5cbi8qKlxuICogVGhlIGB1c2VPblZpZXdwb3J0Q2hhbmdlYCBob29rIGxldHMgeW91IGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgdmlld3BvcnQgc3VjaFxuICogYXMgcGFubmluZyBhbmQgem9vbWluZy4gWW91IGNhbiBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggcGhhc2Ugb2YgYSB2aWV3cG9ydFxuICogY2hhbmdlOiBgb25TdGFydGAsIGBvbkNoYW5nZWAsIGFuZCBgb25FbmRgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IHVzZU9uVmlld3BvcnRDaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFZpZXdwb3J0Q2hhbmdlTG9nZ2VyKCkge1xuICogIHVzZU9uVmlld3BvcnRDaGFuZ2Uoe1xuICogICAgb25TdGFydDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ3N0YXJ0Jywgdmlld3BvcnQpLFxuICogICAgb25DaGFuZ2U6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdjaGFuZ2UnLCB2aWV3cG9ydCksXG4gKiAgICBvbkVuZDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2VuZCcsIHZpZXdwb3J0KSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIG51bGw7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU9uVmlld3BvcnRDaGFuZ2UoeyBvblN0YXJ0LCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VTdGFydDogb25TdGFydCB9KTtcbiAgICB9LCBbb25TdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZTogb25DaGFuZ2UgfSk7XG4gICAgfSwgW29uQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlRW5kOiBvbkVuZCB9KTtcbiAgICB9LCBbb25FbmRdKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIGJvdGggbm9kZSBhbmQgZWRnZSBzZWxlY3Rpb24uIEFzIHRoZVxuICpuYW1lIGltcGxpZXMsIHRoZSBjYWxsYmFjayB5b3UgcHJvdmlkZSB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIG9mXG4gKl9laXRoZXJfIG5vZGVzIG9yIGVkZ2VzIGNoYW5nZXMuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VPblNlbGVjdGlvbkNoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gU2VsZWN0aW9uRGlzcGxheSgpIHtcbiAqICBjb25zdCBbc2VsZWN0ZWROb2Rlcywgc2V0U2VsZWN0ZWROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW3NlbGVjdGVkRWRnZXMsIHNldFNlbGVjdGVkRWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICpcbiAqICAvLyB0aGUgcGFzc2VkIGhhbmRsZXIgaGFzIHRvIGJlIG1lbW9pemVkLCBvdGhlcndpc2UgdGhlIGhvb2sgd2lsbCBub3Qgd29yayBjb3JyZWN0bHlcbiAqICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCh7IG5vZGVzLCBlZGdlcyB9KSA9PiB7XG4gKiAgICBzZXRTZWxlY3RlZE5vZGVzKG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICogICAgc2V0U2VsZWN0ZWRFZGdlcyhlZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAqICB9LCBbXSk7XG4gKlxuICogIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHtcbiAqICAgIG9uQ2hhbmdlLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+U2VsZWN0ZWQgbm9kZXM6IHtzZWxlY3RlZE5vZGVzLmpvaW4oJywgJyl9PC9wPlxuICogICAgICA8cD5TZWxlY3RlZCBlZGdlczoge3NlbGVjdGVkRWRnZXMuam9pbignLCAnKX08L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFlvdSBuZWVkIHRvIG1lbW9pemUgdGhlIHBhc3NlZCBgb25DaGFuZ2VgIGhhbmRsZXIsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gdXNlT25TZWxlY3Rpb25DaGFuZ2UoeyBvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IFsuLi5zdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMsIG9uQ2hhbmdlXTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGVycyA9IHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5maWx0ZXIoKGZuKSA9PiBmbiAhPT0gb25DaGFuZ2UpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0SGFuZGxlcnMgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW29uQ2hhbmdlXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDQgPSAob3B0aW9ucykgPT4gKHMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzKSB7XG4gICAgICAgIHJldHVybiBzLm5vZGVzSW5pdGlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmIChzLm5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgeyBpbnRlcm5hbHMgfV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQgfHwgIW5vZGVIYXNEaW1lbnNpb25zKGludGVybmFscy51c2VyTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFRoaXMgaG9vayB0ZWxscyB5b3Ugd2hldGhlciBhbGwgdGhlIG5vZGVzIGluIGEgZmxvdyBoYXZlIGJlZW4gbWVhc3VyZWQgYW5kIGdpdmVuXG4gKmEgd2lkdGggYW5kIGhlaWdodC4gV2hlbiB5b3UgYWRkIGEgbm9kZSB0byB0aGUgZmxvdywgdGhpcyBob29rIHdpbGwgcmV0dXJuXG4gKmBmYWxzZWAgYW5kIHRoZW4gYHRydWVgIGFnYWluIG9uY2UgdGhlIG5vZGUgaGFzIGJlZW4gbWVhc3VyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIG5vZGVzIGhhdmUgYmVlbiBpbml0aWFsaXplZCBieSB0aGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBhbmRcbiAqIGdpdmVuIGEgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVJlYWN0RmxvdywgdXNlTm9kZXNJbml0aWFsaXplZCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICppbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICpcbiAqY29uc3Qgb3B0aW9ucyA9IHtcbiAqICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTGF5b3V0KCkge1xuICogIGNvbnN0IHsgZ2V0Tm9kZXMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICogIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMpO1xuICogIGNvbnN0IFtsYXlvdXRlZE5vZGVzLCBzZXRMYXlvdXRlZE5vZGVzXSA9IHVzZVN0YXRlKGdldE5vZGVzKCkpO1xuICpcbiAqICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgaWYgKG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAqICAgICAgc2V0TGF5b3V0ZWROb2Rlcyh5b3VyTGF5b3V0aW5nRnVuY3Rpb24oZ2V0Tm9kZXMoKSkpO1xuICogICAgfVxuICogIH0sIFtub2Rlc0luaXRpYWxpemVkXSk7XG4gKlxuICogIHJldHVybiBsYXlvdXRlZE5vZGVzO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbn0pIHtcbiAgICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVN0b3JlKHNlbGVjdG9yJDQob3B0aW9ucykpO1xuICAgIHJldHVybiBpbml0aWFsaXplZDtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIGEgPEhhbmRsZSAvPiBpcyBjb25uZWN0ZWQgdG8gYW5vdGhlciA8SGFuZGxlIC8+IGFuZCBnZXQgdGhlIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBkZXByZWNhdGVkIFVzZSBgdXNlTm9kZUNvbm5lY3Rpb25zYCBpbnN0ZWFkLlxuICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBoYW5kbGUgY29ubmVjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUhhbmRsZUNvbm5lY3Rpb25zKHsgdHlwZSwgaWQsIG5vZGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0pIHtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgdXNlSGFuZGxlQ29ubmVjdGlvbnNgIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL2hvb2tzL3VzZU5vZGVDb25uZWN0aW9ucycpO1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbmNvbnN0IGVycm9yMDE0ID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMTQnXSgpO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiBjb25uZWN0aW9ucyBvbiBhIHNwZWNpZmljIG5vZGUsIGhhbmRsZSB0eXBlICgnc291cmNlJywgJ3RhcmdldCcpIG9yIGhhbmRsZSBJRC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUNvbm5lY3Rpb25zIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VOb2RlQ29ubmVjdGlvbnMoe1xuICogICAgaGFuZGxlVHlwZTogJ3RhcmdldCcsXG4gKiAgICBoYW5kbGVJZDogJ215LWhhbmRsZScsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2Nvbm5lY3Rpb25zLmxlbmd0aH0gaW5jb21pbmcgY29ubmVjdGlvbnMhPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZUNvbm5lY3Rpb25zKHsgaWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSA9IHt9KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IGlkID8/IG5vZGVJZDtcbiAgICBpZiAoIWN1cnJlbnROb2RlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yMDE0KTtcbiAgICB9XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfSR7aGFuZGxlVHlwZSA/IChoYW5kbGVJZCA/IGAtJHtoYW5kbGVUeXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7aGFuZGxlVHlwZX1gKSA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaXNjdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVzRGF0YShub2RlSWRzKSB7XG4gICAgY29uc3Qgbm9kZXNEYXRhID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBpc0FycmF5T2ZJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZHMpO1xuICAgICAgICBjb25zdCBfbm9kZUlkcyA9IGlzQXJyYXlPZklkcyA/IG5vZGVJZHMgOiBbbm9kZUlkc107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIF9ub2RlSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBub2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXlPZklkcyA/IGRhdGEgOiBkYXRhWzBdID8/IG51bGw7XG4gICAgfSwgW25vZGVJZHNdKSwgc2hhbGxvd05vZGVEYXRhKTtcbiAgICByZXR1cm4gbm9kZXNEYXRhO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHNwZWNpZmljIG5vZGUuXG4gKiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9vayB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSBub2RlIGNoYW5nZXMqKixcbiAqIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZCBvciBtb3ZlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgYSBub2RlIHlvdSB3YW50IHRvIG9ic2VydmUuXG4gKiBAcmV0dXJucyBUaGUgYEludGVybmFsTm9kZWAgb2JqZWN0IGZvciB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUludGVybmFsTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGludGVybmFsTm9kZSA9IHVzZUludGVybmFsTm9kZSgnbm9kZS0xJyk7XG4gKiAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpcyBhdDpcbiAqICAgICAgPHA+eDoge2Fic29sdXRlUG9zaXRpb24ueH08L3A+XG4gKiAgICAgIDxwPnk6IHthYnNvbHV0ZVBvc2l0aW9uLnl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlSW50ZXJuYWxOb2RlKGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiBzLm5vZGVMb29rdXAuZ2V0KGlkKSwgW2lkXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIG5vZGUgY2hhbmdlcy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gZm4gLSBNaWRkbGV3YXJlIGZ1bmN0aW9uLiBTaG91bGQgYmUgbWVtb2l6ZWQgd2l0aCB1c2VDYWxsYmFjayB0byBhdm9pZCByZS1yZWdpc3RyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF91c2VPbk5vZGVzQ2hhbmdlTWlkZGxld2FyZShmbikge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbc3ltYm9sXSA9IHVzZVN0YXRlKCgpID0+IFN5bWJvbCgpKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcC5zZXQoc3ltYm9sLCBmbik7XG4gICAgfSwgW2ZuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBlZGdlIGNoYW5nZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGZuIC0gTWlkZGxld2FyZSBmdW5jdGlvbi4gU2hvdWxkIGJlIG1lbW9pemVkIHdpdGggdXNlQ2FsbGJhY2sgdG8gYXZvaWQgcmUtcmVnaXN0cmF0aW9uLlxuICovXG5mdW5jdGlvbiBleHBlcmltZW50YWxfdXNlT25FZGdlc0NoYW5nZU1pZGRsZXdhcmUoZm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgW3N5bWJvbF0gPSB1c2VTdGF0ZSgoKSA9PiBTeW1ib2woKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkVkZ2VzQ2hhbmdlTWlkZGxld2FyZU1hcCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgb25FZGdlc0NoYW5nZU1pZGRsZXdhcmVNYXAuc2V0KHN5bWJvbCwgZm4pO1xuICAgIH0sIFtmbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25FZGdlc0NoYW5nZU1pZGRsZXdhcmVNYXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlTWlkZGxld2FyZU1hcC5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIExpbmVQYXR0ZXJuKHsgZGltZW5zaW9ucywgbGluZVdpZHRoLCB2YXJpYW50LCBjbGFzc05hbWUgfSkge1xuICAgIHJldHVybiAoanN4KFwicGF0aFwiLCB7IHN0cm9rZVdpZHRoOiBsaW5lV2lkdGgsIGQ6IGBNJHtkaW1lbnNpb25zWzBdIC8gMn0gMCBWJHtkaW1lbnNpb25zWzFdfSBNMCAke2RpbWVuc2lvbnNbMV0gLyAyfSBIJHtkaW1lbnNpb25zWzBdfWAsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kLXBhdHRlcm4nLCB2YXJpYW50LCBjbGFzc05hbWVdKSB9KSk7XG59XG5mdW5jdGlvbiBEb3RQYXR0ZXJuKHsgcmFkaXVzLCBjbGFzc05hbWUgfSkge1xuICAgIHJldHVybiAoanN4KFwiY2lyY2xlXCIsIHsgY3g6IHJhZGl1cywgY3k6IHJhZGl1cywgcjogcmFkaXVzLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgJ2RvdHMnLCBjbGFzc05hbWVdKSB9KSk7XG59XG5cbi8qKlxuICogVGhlIHRocmVlIHZhcmlhbnRzIGFyZSBleHBvcnRlZCBhcyBhbiBlbnVtIGZvciBjb252ZW5pZW5jZS4gWW91IGNhbiBlaXRoZXIgaW1wb3J0XG4gKiB0aGUgZW51bSBhbmQgdXNlIGl0IGxpa2UgYEJhY2tncm91bmRWYXJpYW50LkxpbmVzYCBvciB5b3UgY2FuIHVzZSB0aGUgcmF3IHN0cmluZ1xuICogdmFsdWUgZGlyZWN0bHkuXG4gKiBAcHVibGljXG4gKi9cbnZhciBCYWNrZ3JvdW5kVmFyaWFudDtcbihmdW5jdGlvbiAoQmFja2dyb3VuZFZhcmlhbnQpIHtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkxpbmVzXCJdID0gXCJsaW5lc1wiO1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiRG90c1wiXSA9IFwiZG90c1wiO1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiQ3Jvc3NcIl0gPSBcImNyb3NzXCI7XG59KShCYWNrZ3JvdW5kVmFyaWFudCB8fCAoQmFja2dyb3VuZFZhcmlhbnQgPSB7fSkpO1xuXG5jb25zdCBkZWZhdWx0U2l6ZSA9IHtcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuRG90c106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkxpbmVzXTogMSxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3NdOiA2LFxufTtcbmNvbnN0IHNlbGVjdG9yJDMgPSAocykgPT4gKHsgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSwgcGF0dGVybklkOiBgcGF0dGVybi0ke3MucmZJZH1gIH0pO1xuZnVuY3Rpb24gQmFja2dyb3VuZENvbXBvbmVudCh7IGlkLCB2YXJpYW50ID0gQmFja2dyb3VuZFZhcmlhbnQuRG90cywgXG4vLyBvbmx5IHVzZWQgZm9yIGRvdHMgYW5kIGNyb3NzXG5nYXAgPSAyMCwgXG4vLyBvbmx5IHVzZWQgZm9yIGxpbmVzIGFuZCBjcm9zc1xuc2l6ZSwgbGluZVdpZHRoID0gMSwgb2Zmc2V0ID0gMCwgY29sb3IsIGJnQ29sb3IsIHN0eWxlLCBjbGFzc05hbWUsIHBhdHRlcm5DbGFzc05hbWUsIH0pIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhdHRlcm5JZCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMywgc2hhbGxvdyk7XG4gICAgY29uc3QgcGF0dGVyblNpemUgPSBzaXplIHx8IGRlZmF1bHRTaXplW3ZhcmlhbnRdO1xuICAgIGNvbnN0IGlzRG90cyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkRvdHM7XG4gICAgY29uc3QgaXNDcm9zcyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkNyb3NzO1xuICAgIGNvbnN0IGdhcFhZID0gQXJyYXkuaXNBcnJheShnYXApID8gZ2FwIDogW2dhcCwgZ2FwXTtcbiAgICBjb25zdCBzY2FsZWRHYXAgPSBbZ2FwWFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSwgZ2FwWFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMV07XG4gICAgY29uc3Qgc2NhbGVkU2l6ZSA9IHBhdHRlcm5TaXplICogdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG9mZnNldFhZID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogW29mZnNldCwgb2Zmc2V0XTtcbiAgICBjb25zdCBwYXR0ZXJuRGltZW5zaW9ucyA9IGlzQ3Jvc3MgPyBbc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZV0gOiBzY2FsZWRHYXA7XG4gICAgY29uc3Qgc2NhbGVkT2Zmc2V0ID0gW1xuICAgICAgICBvZmZzZXRYWVswXSAqIHRyYW5zZm9ybVsyXSB8fCAxICsgcGF0dGVybkRpbWVuc2lvbnNbMF0gLyAyLFxuICAgICAgICBvZmZzZXRYWVsxXSAqIHRyYW5zZm9ybVsyXSB8fCAxICsgcGF0dGVybkRpbWVuc2lvbnNbMV0gLyAyLFxuICAgIF07XG4gICAgY29uc3QgX3BhdHRlcm5JZCA9IGAke3BhdHRlcm5JZH0ke2lkID8gaWQgOiAnJ31gO1xuICAgIHJldHVybiAoanN4cyhcInN2Z1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kJywgY2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmNvbnRhaW5lclN0eWxlLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IGJnQ29sb3IsXG4gICAgICAgICAgICAnLS14eS1iYWNrZ3JvdW5kLXBhdHRlcm4tY29sb3ItcHJvcHMnOiBjb2xvcixcbiAgICAgICAgfSwgcmVmOiByZWYsIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fYmFja2dyb3VuZFwiLCBjaGlsZHJlbjogW2pzeChcInBhdHRlcm5cIiwgeyBpZDogX3BhdHRlcm5JZCwgeDogdHJhbnNmb3JtWzBdICUgc2NhbGVkR2FwWzBdLCB5OiB0cmFuc2Zvcm1bMV0gJSBzY2FsZWRHYXBbMV0sIHdpZHRoOiBzY2FsZWRHYXBbMF0sIGhlaWdodDogc2NhbGVkR2FwWzFdLCBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiwgcGF0dGVyblRyYW5zZm9ybTogYHRyYW5zbGF0ZSgtJHtzY2FsZWRPZmZzZXRbMF19LC0ke3NjYWxlZE9mZnNldFsxXX0pYCwgY2hpbGRyZW46IGlzRG90cyA/IChqc3goRG90UGF0dGVybiwgeyByYWRpdXM6IHNjYWxlZFNpemUgLyAyLCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIDogKGpzeChMaW5lUGF0dGVybiwgeyBkaW1lbnNpb25zOiBwYXR0ZXJuRGltZW5zaW9ucywgbGluZVdpZHRoOiBsaW5lV2lkdGgsIHZhcmlhbnQ6IHZhcmlhbnQsIGNsYXNzTmFtZTogcGF0dGVybkNsYXNzTmFtZSB9KSkgfSksIGpzeChcInJlY3RcIiwgeyB4OiBcIjBcIiwgeTogXCIwXCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgZmlsbDogYHVybCgjJHtfcGF0dGVybklkfSlgIH0pXSB9KSk7XG59XG5CYWNrZ3JvdW5kQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0JhY2tncm91bmQnO1xuLyoqXG4gKiBUaGUgYDxCYWNrZ3JvdW5kIC8+YCBjb21wb25lbnQgbWFrZXMgaXQgY29udmVuaWVudCB0byByZW5kZXIgZGlmZmVyZW50IHR5cGVzIG9mIGJhY2tncm91bmRzIGNvbW1vbiBpbiBub2RlLWJhc2VkIFVJcy4gSXQgY29tZXMgd2l0aCB0aHJlZSB2YXJpYW50czogbGluZXMsIGRvdHMgYW5kIGNyb3NzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogQSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdG8gdXNlIHRoZSBCYWNrZ3JvdW5kIGNvbXBvbmVudC5cbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFJlYWN0RmxvdyBkZWZhdWx0Tm9kZXM9e1suLi5dfSBkZWZhdWx0RWRnZXM9e1suLi5dfT5cbiAqICAgICAgIDxCYWNrZ3JvdW5kIGNvbG9yPVwiI2NjY1wiIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkRvdHN9IC8+XG4gKiAgICAgPC9SZWFjdEZsb3c+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEluIHRoaXMgZXhhbXBsZSB5b3UgY2FuIHNlZSBob3cgdG8gY29tYmluZSBtdWx0aXBsZSBiYWNrZ3JvdW5kc1xuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICogaW1wb3J0ICdAeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzJztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZFxuICogICAgICAgICBpZD1cIjFcIlxuICogICAgICAgICBnYXA9ezEwfVxuICogICAgICAgICBjb2xvcj1cIiNmMWYxZjFcIlxuICogICAgICAgICB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc31cbiAqICAgICAgIC8+XG4gKiAgICAgICA8QmFja2dyb3VuZFxuICogICAgICAgICBpZD1cIjJcIlxuICogICAgICAgICBnYXA9ezEwMH1cbiAqICAgICAgICAgY29sb3I9XCIjY2NjXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBXaGVuIGNvbWJpbmluZyBtdWx0aXBsZSA8QmFja2dyb3VuZCAvPiBjb21wb25lbnRzIGl04oCZcyBpbXBvcnRhbnQgdG8gZ2l2ZSBlYWNoIG9mIHRoZW0gYSB1bmlxdWUgaWQgcHJvcCFcbiAqXG4gKi9cbmNvbnN0IEJhY2tncm91bmQgPSBtZW1vKEJhY2tncm91bmRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBQbHVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMzIgMTguMTMzSDE4LjEzM1YzMmgtNC4yNjZWMTguMTMzSDB2LTQuMjY2aDEzLjg2N1YwaDQuMjY2djEzLjg2N0gzMnpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIE1pbnVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDVcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0wIDBoMzJ2NC4ySDB6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBGaXRWaWV3SWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMwXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMy42OTIgNC42M2MwLS41My40LS45MzguOTM5LS45MzhoNS4yMTVWMEg0LjcwOEMyLjEzIDAgMCAyLjA1NCAwIDQuNjN2NS4yMTZoMy42OTJWNC42MzF6TTI3LjM1NCAwaC01LjJ2My42OTJoNS4xN2MuNTMgMCAuOTg0LjQuOTg0LjkzOXY1LjIxNUgzMlY0LjYzMUE0LjYyNCA0LjYyNCAwIDAwMjcuMzU0IDB6bS45NTQgMjQuODNjMCAuNTMyLS40Ljk0LS45MzkuOTRoLTUuMjE1djMuNzY4aDUuMjE1YzIuNTc3IDAgNC42MzEtMi4xMyA0LjYzMS00LjcwN3YtNS4xMzloLTMuNjkydjUuMTM5em0tMjMuNjc3Ljk0Yy0uNTMxIDAtLjkzOS0uNC0uOTM5LS45NHYtNS4xMzhIMHY1LjEzOWMwIDIuNTc3IDIuMTMgNC43MDcgNC43MDggNC43MDdoNS4xMzhWMjUuNzdINC42MzF6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBMb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDAgOCAwIDQuNTcxIDMuNDI5IDQuNTcxIDcuNjE5djMuMDQ4SDMuMDQ4QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3ptNC43MjQtMTMuODY2SDcuNDY3VjcuNjE5YzAtMi41OSAyLjEzMy00LjcyNCA0LjcyMy00LjcyNCAyLjU5MSAwIDQuNzI0IDIuMTMzIDQuNzI0IDQuNzI0djMuMDQ4elwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gVW5sb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDBjLTQuMTE0IDEuODI4LTEuMzcgMi4xMzMuMzA1IDIuNDM4IDEuNjc2LjMwNSA0LjQyIDIuNTkgNC40MiA1LjE4MXYzLjA0OEgzLjA0N0EzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6XCIgfSkgfSkpO1xufVxuXG4vKipcbiAqIFlvdSBjYW4gYWRkIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2wgcGFuZWwgYnkgdXNpbmcgdGhlIGA8Q29udHJvbEJ1dHRvbiAvPmAgY29tcG9uZW50XG4gKiBhbmQgcGFzcyBpdCBhcyBhIGNoaWxkIHRvIHRoZSBbYDxDb250cm9scyAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbHMpIGNvbXBvbmVudC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgTWFnaWNXYW5kIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWljb25zJ1xuICppbXBvcnQgeyBSZWFjdEZsb3csIENvbnRyb2xzLCBDb250cm9sQnV0dG9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dfSBlZGdlcz17Wy4uLl19PlxuICogICAgICA8Q29udHJvbHM+XG4gKiAgICAgICAgPENvbnRyb2xCdXR0b24gb25DbGljaz17KCkgPT4gYWxlcnQoJ1NvbWV0aGluZyBtYWdpY2FsIGp1c3QgaGFwcGVuZWQuIOKcqCcpfT5cbiAqICAgICAgICAgIDxNYWdpY1dhbmQgLz5cbiAqICAgICAgICA8L0NvbnRyb2xCdXR0b24+XG4gKiAgICAgIDwvQ29udHJvbHM+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xCdXR0b24oeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICByZXR1cm4gKGpzeChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scy1idXR0b24nLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkMiA9IChzKSA9PiAoe1xuICAgIGlzSW50ZXJhY3RpdmU6IHMubm9kZXNEcmFnZ2FibGUgfHwgcy5ub2Rlc0Nvbm5lY3RhYmxlIHx8IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG1pblpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA8PSBzLm1pblpvb20sXG4gICAgbWF4Wm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdID49IHMubWF4Wm9vbSxcbiAgICBhcmlhTGFiZWxDb25maWc6IHMuYXJpYUxhYmVsQ29uZmlnLFxufSk7XG5mdW5jdGlvbiBDb250cm9sc0NvbXBvbmVudCh7IHN0eWxlLCBzaG93Wm9vbSA9IHRydWUsIHNob3dGaXRWaWV3ID0gdHJ1ZSwgc2hvd0ludGVyYWN0aXZlID0gdHJ1ZSwgZml0Vmlld09wdGlvbnMsIG9uWm9vbUluLCBvblpvb21PdXQsIG9uRml0Vmlldywgb25JbnRlcmFjdGl2ZUNoYW5nZSwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSAnYm90dG9tLWxlZnQnLCBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkLCBhcmlhTGFiZWxDb25maWcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgem9vbUluLCB6b29tT3V0LCBmaXRWaWV3IH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBvblpvb21JbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21JbigpO1xuICAgICAgICBvblpvb21Jbj8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblpvb21PdXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tT3V0KCk7XG4gICAgICAgIG9uWm9vbU91dD8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpdFZpZXdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBmaXRWaWV3KGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgb25GaXRWaWV3Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSA9ICgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbm9kZXNEcmFnZ2FibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICB9KTtcbiAgICAgICAgb25JbnRlcmFjdGl2ZUNoYW5nZT8uKCFpc0ludGVyYWN0aXZlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWVudGF0aW9uQ2xhc3MgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICByZXR1cm4gKGpzeHMoUGFuZWwsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzJywgb3JpZW50YXRpb25DbGFzcywgY2xhc3NOYW1lXSksIHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2NvbnRyb2xzXCIsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwgPz8gYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy5hcmlhTGFiZWwnXSwgY2hpbGRyZW46IFtzaG93Wm9vbSAmJiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbUluSGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21pblwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21Jbi5hcmlhTGFiZWwnXSwgZGlzYWJsZWQ6IG1heFpvb21SZWFjaGVkLCBjaGlsZHJlbjoganN4KFBsdXNJY29uLCB7fSkgfSksIGpzeChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbU91dEhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29tb3V0XCIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtaW5ab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChNaW51c0ljb24sIHt9KSB9KV0gfSkpLCBzaG93Rml0VmlldyAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWZpdHZpZXdcIiwgb25DbGljazogb25GaXRWaWV3SGFuZGxlciwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnXSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnXSwgY2hpbGRyZW46IGpzeChGaXRWaWV3SWNvbiwge30pIH0pKSwgc2hvd0ludGVyYWN0aXZlICYmIChqc3goQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtaW50ZXJhY3RpdmVcIiwgb25DbGljazogb25Ub2dnbGVJbnRlcmFjdGl2aXR5LCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy5pbnRlcmFjdGl2ZS5hcmlhTGFiZWwnXSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBpc0ludGVyYWN0aXZlID8ganN4KFVubG9ja0ljb24sIHt9KSA6IGpzeChMb2NrSWNvbiwge30pIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn1cbkNvbnRyb2xzQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xzJztcbi8qKlxuICogVGhlIGA8Q29udHJvbHMgLz5gIGNvbXBvbmVudCByZW5kZXJzIGEgc21hbGwgcGFuZWwgdGhhdCBjb250YWlucyBjb252ZW5pZW50XG4gKiBidXR0b25zIHRvIHpvb20gaW4sIHpvb20gb3V0LCBmaXQgdGhlIHZpZXcsIGFuZCBsb2NrIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzIC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVG8gZXh0ZW5kIG9yIGN1c3RvbWlzZSB0aGUgY29udHJvbHMsIHlvdSBjYW4gdXNlIHRoZSBbYDxDb250cm9sQnV0dG9uIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9sLWJ1dHRvbikgY29tcG9uZW50XG4gKlxuICovXG5jb25zdCBDb250cm9scyA9IG1lbW8oQ29udHJvbHNDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBNaW5pTWFwTm9kZUNvbXBvbmVudCh7IGlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgY29sb3IsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCwgY2xhc3NOYW1lLCBib3JkZXJSYWRpdXMsIHNoYXBlUmVuZGVyaW5nLCBzZWxlY3RlZCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYmFja2dyb3VuZENvbG9yIH0gPSBzdHlsZSB8fCB7fTtcbiAgICBjb25zdCBmaWxsID0gKGNvbG9yIHx8IGJhY2tncm91bmQgfHwgYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4gKGpzeChcInJlY3RcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcC1ub2RlJywgeyBzZWxlY3RlZCB9LCBjbGFzc05hbWVdKSwgeDogeCwgeTogeSwgcng6IGJvcmRlclJhZGl1cywgcnk6IGJvcmRlclJhZGl1cywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljayA/IChldmVudCkgPT4gb25DbGljayhldmVudCwgaWQpIDogdW5kZWZpbmVkIH0pKTtcbn1cbmNvbnN0IE1pbmlNYXBOb2RlID0gbWVtbyhNaW5pTWFwTm9kZUNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yTm9kZUlkcyA9IChzKSA9PiBzLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG5jb25zdCBnZXRBdHRyRnVuY3Rpb24gPSAoZnVuYykgPT4gZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZnVuYyA6ICgpID0+IGZ1bmM7XG5mdW5jdGlvbiBNaW5pTWFwTm9kZXMoeyBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCA9IE1pbmlNYXBOb2RlLCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVN0b3JlKHNlbGVjdG9yTm9kZUlkcywgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVTdHJva2VDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZVN0cm9rZUNvbG9yKTtcbiAgICBjb25zdCBub2RlQ2xhc3NOYW1lRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBzaGFwZVJlbmRlcmluZyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEhd2luZG93LmNocm9tZSA/ICdjcmlzcEVkZ2VzJyA6ICdnZW9tZXRyaWNQcmVjaXNpb24nO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiAoXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBzcGxpdCBvZiByZXNwb25zaWJpbGl0aWVzIGJldHdlZW4gTWluaU1hcE5vZGVzIGFuZFxuICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgYSBzaW1pbGFyIGNvbW1pdCBpbiBgTm9kZVJlbmRlcmVyL2luZGV4LnRzeGAuXG4gICAgICAgICAqL1xuICAgICAgICBqc3goTm9kZUNvbXBvbmVudFdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZUNvbG9yRnVuYzogbm9kZUNvbG9yRnVuYywgbm9kZVN0cm9rZUNvbG9yRnVuYzogbm9kZVN0cm9rZUNvbG9yRnVuYywgbm9kZUNsYXNzTmFtZUZ1bmM6IG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgTm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCwgb25DbGljazogb25DbGljaywgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nIH0sIG5vZGVJZCkpKSB9KSk7XG59XG5mdW5jdGlvbiBOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyKHsgaWQsIG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nLCBOb2RlQ29tcG9uZW50LCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCB7IGludGVybmFscyB9ID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5oaWRkZW4gfHwgIW5vZGVIYXNEaW1lbnNpb25zKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb2RlQ29tcG9uZW50LCB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBjbGFzc05hbWU6IG5vZGVDbGFzc05hbWVGdW5jKG5vZGUpLCBjb2xvcjogbm9kZUNvbG9yRnVuYyhub2RlKSwgYm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBzdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yRnVuYyhub2RlKSwgc3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrLCBpZDogbm9kZS5pZCB9KSk7XG59XG5jb25zdCBOb2RlQ29tcG9uZW50V3JhcHBlciA9IG1lbW8oTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcik7XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbmNvbnN0IGRlZmF1bHRXaWR0aCA9IDIwMDtcbmNvbnN0IGRlZmF1bHRIZWlnaHQgPSAxNTA7XG5jb25zdCBmaWx0ZXJIaWRkZW4gPSAobm9kZSkgPT4gIW5vZGUuaGlkZGVuO1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiB7XG4gICAgY29uc3Qgdmlld0JCID0ge1xuICAgICAgICB4OiAtcy50cmFuc2Zvcm1bMF0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXMudHJhbnNmb3JtWzFdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiBzLndpZHRoIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogcy5oZWlnaHQgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZpZXdCQixcbiAgICAgICAgYm91bmRpbmdSZWN0OiBzLm5vZGVMb29rdXAuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gZ2V0Qm91bmRzT2ZSZWN0cyhnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwgeyBmaWx0ZXI6IGZpbHRlckhpZGRlbiB9KSwgdmlld0JCKVxuICAgICAgICAgICAgOiB2aWV3QkIsXG4gICAgICAgIHJmSWQ6IHMucmZJZCxcbiAgICAgICAgcGFuWm9vbTogcy5wYW5ab29tLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IHMudHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBmbG93V2lkdGg6IHMud2lkdGgsXG4gICAgICAgIGZsb3dIZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICBhcmlhTGFiZWxDb25maWc6IHMuYXJpYUxhYmVsQ29uZmlnLFxuICAgIH07XG59O1xuY29uc3QgQVJJQV9MQUJFTF9LRVkgPSAncmVhY3QtZmxvd19fbWluaW1hcC1kZXNjJztcbmZ1bmN0aW9uIE1pbmlNYXBDb21wb25lbnQoeyBzdHlsZSwgY2xhc3NOYW1lLCBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudCwgYmdDb2xvciwgbWFza0NvbG9yLCBtYXNrU3Ryb2tlQ29sb3IsIG1hc2tTdHJva2VXaWR0aCwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCwgaW52ZXJzZVBhbiwgem9vbVN0ZXAgPSAxLCBvZmZzZXRTY2FsZSA9IDUsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ZnID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgYm91bmRpbmdSZWN0LCB2aWV3QkIsIHJmSWQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0LCBhcmlhTGFiZWxDb25maWcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHN0eWxlPy53aWR0aCA/PyBkZWZhdWx0V2lkdGg7XG4gICAgY29uc3QgZWxlbWVudEhlaWdodCA9IHN0eWxlPy5oZWlnaHQgPz8gZGVmYXVsdEhlaWdodDtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCB2aWV3U2NhbGUgPSBNYXRoLm1heChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCB2aWV3V2lkdGggPSB2aWV3U2NhbGUgKiBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgdmlld0hlaWdodCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0U2NhbGUgKiB2aWV3U2NhbGU7XG4gICAgY29uc3QgeCA9IGJvdW5kaW5nUmVjdC54IC0gKHZpZXdXaWR0aCAtIGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHkgPSBib3VuZGluZ1JlY3QueSAtICh2aWV3SGVpZ2h0IC0gYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHdpZHRoID0gdmlld1dpZHRoICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBoZWlnaHQgPSB2aWV3SGVpZ2h0ICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBsYWJlbGxlZEJ5ID0gYCR7QVJJQV9MQUJFTF9LRVl9LSR7cmZJZH1gO1xuICAgIGNvbnN0IHZpZXdTY2FsZVJlZiA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBtaW5pbWFwSW5zdGFuY2UgPSB1c2VSZWYoKTtcbiAgICB2aWV3U2NhbGVSZWYuY3VycmVudCA9IHZpZXdTY2FsZTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3ZnLmN1cnJlbnQgJiYgcGFuWm9vbSkge1xuICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQgPSBYWU1pbmltYXAoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHN2Zy5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRWaWV3U2NhbGU6ICgpID0+IHZpZXdTY2FsZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW3Bhblpvb21dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8udXBkYXRlKHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgIHdpZHRoOiBmbG93V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGZsb3dIZWlnaHQsXG4gICAgICAgICAgICBpbnZlcnNlUGFuLFxuICAgICAgICAgICAgcGFubmFibGUsXG4gICAgICAgICAgICB6b29tU3RlcCxcbiAgICAgICAgICAgIHpvb21hYmxlLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFubmFibGUsIHpvb21hYmxlLCBpbnZlcnNlUGFuLCB6b29tU3RlcCwgdHJhbnNsYXRlRXh0ZW50LCBmbG93V2lkdGgsIGZsb3dIZWlnaHRdKTtcbiAgICBjb25zdCBvblN2Z0NsaWNrID0gb25DbGlja1xuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnBvaW50ZXIoZXZlbnQpIHx8IFswLCAwXTtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblN2Z05vZGVDbGljayA9IG9uTm9kZUNsaWNrXG4gICAgICAgID8gdXNlQ2FsbGJhY2soKGV2ZW50LCBub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCkuaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICAgICAgb25Ob2RlQ2xpY2soZXZlbnQsIG5vZGUpO1xuICAgICAgICB9LCBbXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgX2FyaWFMYWJlbCA9IGFyaWFMYWJlbCA/PyBhcmlhTGFiZWxDb25maWdbJ21pbmltYXAuYXJpYUxhYmVsJ107XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgYmdDb2xvciA9PT0gJ3N0cmluZycgPyBiZ0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza0NvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZVdpZHRoID09PSAnbnVtYmVyJyA/IG1hc2tTdHJva2VXaWR0aCAqIHZpZXdTY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBub2RlU3Ryb2tlV2lkdGggOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19taW5pbWFwJywgY2xhc3NOYW1lXSksIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fbWluaW1hcFwiLCBjaGlsZHJlbjoganN4cyhcInN2Z1wiLCB7IHdpZHRoOiBlbGVtZW50V2lkdGgsIGhlaWdodDogZWxlbWVudEhlaWdodCwgdmlld0JveDogYCR7eH0gJHt5fSAke3dpZHRofSAke2hlaWdodH1gLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWluaW1hcC1zdmdcIiwgcm9sZTogXCJpbWdcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSwgcmVmOiBzdmcsIG9uQ2xpY2s6IG9uU3ZnQ2xpY2ssIGNoaWxkcmVuOiBbX2FyaWFMYWJlbCAmJiBqc3goXCJ0aXRsZVwiLCB7IGlkOiBsYWJlbGxlZEJ5LCBjaGlsZHJlbjogX2FyaWFMYWJlbCB9KSwganN4KE1pbmlNYXBOb2RlcyQxLCB7IG9uQ2xpY2s6IG9uU3ZnTm9kZUNsaWNrLCBub2RlQ29sb3I6IG5vZGVDb2xvciwgbm9kZVN0cm9rZUNvbG9yOiBub2RlU3Ryb2tlQ29sb3IsIG5vZGVCb3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVDbGFzc05hbWU6IG5vZGVDbGFzc05hbWUsIG5vZGVTdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBub2RlQ29tcG9uZW50OiBub2RlQ29tcG9uZW50IH0pLCBqc3goXCJwYXRoXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtbWFza1wiLCBkOiBgTSR7eCAtIG9mZnNldH0sJHt5IC0gb2Zmc2V0fWgke3dpZHRoICsgb2Zmc2V0ICogMn12JHtoZWlnaHQgKyBvZmZzZXQgKiAyfWgkey13aWR0aCAtIG9mZnNldCAqIDJ9elxuICAgICAgICBNJHt2aWV3QkIueH0sJHt2aWV3QkIueX1oJHt2aWV3QkIud2lkdGh9diR7dmlld0JCLmhlaWdodH1oJHstdmlld0JCLndpZHRofXpgLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0pXSB9KSB9KSk7XG59XG5NaW5pTWFwQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ01pbmlNYXAnO1xuLyoqXG4gKiBUaGUgYDxNaW5pTWFwIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGFuIG92ZXJ2aWV3IG9mIHlvdXIgZmxvdy4gSXRcbiAqIHJlbmRlcnMgZWFjaCBub2RlIGFzIGFuIFNWRyBlbGVtZW50IGFuZCB2aXN1YWxpemVzIHdoZXJlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGlzXG4gKiBpbiByZWxhdGlvbiB0byB0aGUgcmVzdCBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIE1pbmlNYXAgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dXX0gZWRnZXM9e1suLi5dXX0+XG4gKiAgICAgIDxNaW5pTWFwIG5vZGVTdHJva2VXaWR0aD17M30gLz5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IE1pbmlNYXAgPSBtZW1vKE1pbmlNYXBDb21wb25lbnQpO1xuXG5jb25zdCBzY2FsZVNlbGVjdG9yID0gKGNhbGN1bGF0ZVNjYWxlKSA9PiAoc3RvcmUpID0+IGNhbGN1bGF0ZVNjYWxlID8gYCR7TWF0aC5tYXgoMSAvIHN0b3JlLnRyYW5zZm9ybVsyXSwgMSl9YCA6IHVuZGVmaW5lZDtcbmNvbnN0IGRlZmF1bHRQb3NpdGlvbnMgPSB7XG4gICAgW1Jlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmVdOiAncmlnaHQnLFxuICAgIFtSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGVdOiAnYm90dG9tLXJpZ2h0Jyxcbn07XG5mdW5jdGlvbiBSZXNpemVDb250cm9sKHsgbm9kZUlkLCBwb3NpdGlvbiwgdmFyaWFudCA9IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkhhbmRsZSwgY2xhc3NOYW1lLCBzdHlsZSA9IHVuZGVmaW5lZCwgY2hpbGRyZW4sIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgcmVzaXplRGlyZWN0aW9uLCBhdXRvU2NhbGUgPSB0cnVlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBub2RlSWQgPT09ICdzdHJpbmcnID8gbm9kZUlkIDogY29udGV4dE5vZGVJZDtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgcmVzaXplQ29udHJvbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc0hhbmRsZUNvbnRyb2wgPSB2YXJpYW50ID09PSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGU7XG4gICAgY29uc3Qgc2NhbGUgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzY2FsZVNlbGVjdG9yKGlzSGFuZGxlQ29udHJvbCAmJiBhdXRvU2NhbGUpLCBbaXNIYW5kbGVDb250cm9sLCBhdXRvU2NhbGVdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVzaXplciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb250cm9sUG9zaXRpb24gPSBwb3NpdGlvbiA/PyBkZWZhdWx0UG9zaXRpb25zW3ZhcmlhbnRdO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcmVzaXplQ29udHJvbFJlZi5jdXJyZW50IHx8ICFpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzaXplci5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXNpemVyLmN1cnJlbnQgPSBYWVJlc2l6ZXIoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lRG9tTm9kZTogZG9tTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoY2hhbmdlLCBjaGlsZENoYW5nZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VyTm9kZUNoYW5nZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IGNoYW5nZS54LCB5OiBjaGFuZ2UueSB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjaGFuZ2Uud2lkdGggPz8gbm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhbmdlLmhlaWdodCA/PyBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmFsdWF0ZUFic29sdXRlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hhbmdlLnggPz8gbm9kZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hhbmdlLnkgPz8gbm9kZS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7IHdpZHRoLCBoZWlnaHQgfSwgbm9kZS5wYXJlbnRJZCwgbm9kZUxvb2t1cCwgb3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQoW2NoaWxkXSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIHRoZSBwYXJlbnQgd2FzIGV4cGFuZGVkIGJ5IHRoZSBjaGlsZCBub2RlLCBpdHMgcG9zaXRpb24gd2lsbCBiZSBjbGFtcGVkIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAwLDAgd2hlbiBub2RlIG9yaWdpbiBpcyAwLDAgYW5kIHRvIHdpZHRoLCBoZWlnaHQgaWYgaXQncyAxLDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBjaGFuZ2UueCA/IE1hdGgubWF4KG9yaWdpblswXSAqIHdpZHRoLCBjaGFuZ2UueCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueSA9IGNoYW5nZS55ID8gTWF0aC5tYXgob3JpZ2luWzFdICogaGVpZ2h0LCBjaGFuZ2UueSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgbmV4dFBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5uZXh0UG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjaGFuZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAhcmVzaXplRGlyZWN0aW9uID8gdHJ1ZSA6IHJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNoYW5nZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjaGFuZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGRpbWVuc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZENoYW5nZSBvZiBjaGlsZENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnRyaWdnZXJOb2RlQ2hhbmdlcyhbZGltZW5zaW9uQ2hhbmdlXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZXIuY3VycmVudC51cGRhdGUoe1xuICAgICAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICAgICAgYm91bmRhcmllczoge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgcmVzaXplRGlyZWN0aW9uLFxuICAgICAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgICAgIG9uUmVzaXplLFxuICAgICAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgIG1pbldpZHRoLFxuICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgIG1heFdpZHRoLFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgb25SZXNpemUsXG4gICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgXSk7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc05hbWVzID0gY29udHJvbFBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcmVzaXplLWNvbnRyb2wnLCAnbm9kcmFnJywgLi4ucG9zaXRpb25DbGFzc05hbWVzLCB2YXJpYW50LCBjbGFzc05hbWVdKSwgcmVmOiByZXNpemVDb250cm9sUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIC4uLihjb2xvciAmJiB7IFtpc0hhbmRsZUNvbnRyb2wgPyAnYmFja2dyb3VuZENvbG9yJyA6ICdib3JkZXJDb2xvciddOiBjb2xvciB9KSxcbiAgICAgICAgfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVG8gY3JlYXRlIHlvdXIgb3duIHJlc2l6aW5nIFVJLCB5b3UgY2FuIHVzZSB0aGUgYE5vZGVSZXNpemVDb250cm9sYCBjb21wb25lbnQgd2hlcmUgeW91IGNhbiBwYXNzIGNoaWxkcmVuIChzdWNoIGFzIGljb25zKS5cbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmNvbnN0IE5vZGVSZXNpemVDb250cm9sID0gbWVtbyhSZXNpemVDb250cm9sKTtcblxuLyoqXG4gKiBUaGUgYDxOb2RlUmVzaXplciAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGFkZCBhIHJlc2l6ZSBmdW5jdGlvbmFsaXR5IHRvIHlvdXJcbiAqIG5vZGVzLiBJdCByZW5kZXJzIGRyYWdnYWJsZSBjb250cm9scyBhcm91bmQgdGhlIG5vZGUgdG8gcmVzaXplIGluIGFsbCBkaXJlY3Rpb25zLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKmBgYGpzeFxuICppbXBvcnQgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uLCBOb2RlUmVzaXplciB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gUmVzaXphYmxlTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8Tm9kZVJlc2l6ZXIgbWluV2lkdGg9ezEwMH0gbWluSGVpZ2h0PXszMH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogMTAgfX0+e2RhdGEubGFiZWx9PC9kaXY+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBtZW1vKFJlc2l6YWJsZU5vZGUpO1xuICpgYGBcbiAqL1xuZnVuY3Rpb24gTm9kZVJlc2l6ZXIoeyBub2RlSWQsIGlzVmlzaWJsZSA9IHRydWUsIGhhbmRsZUNsYXNzTmFtZSwgaGFuZGxlU3R5bGUsIGxpbmVDbGFzc05hbWUsIGxpbmVTdHlsZSwgY29sb3IsIG1pbldpZHRoID0gMTAsIG1pbkhlaWdodCA9IDEwLCBtYXhXaWR0aCA9IE51bWJlci5NQVhfVkFMVUUsIG1heEhlaWdodCA9IE51bWJlci5NQVhfVkFMVUUsIGtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlLCBhdXRvU2NhbGUgPSB0cnVlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBsaW5lQ2xhc3NOYW1lLCBzdHlsZTogbGluZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCB2YXJpYW50OiBSZXNpemVDb250cm9sVmFyaWFudC5MaW5lLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBhdXRvU2NhbGU6IGF1dG9TY2FsZSwgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGhhbmRsZUNsYXNzTmFtZSwgc3R5bGU6IGhhbmRsZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBhdXRvU2NhbGU6IGF1dG9TY2FsZSwgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcmVuZGVyZXInKTtcbmZ1bmN0aW9uIE5vZGVUb29sYmFyUG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VTdG9yZShzZWxlY3Rvcik7XG4gICAgaWYgKCF3cmFwcGVyUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB3cmFwcGVyUmVmKTtcbn1cblxuY29uc3Qgbm9kZUVxdWFsaXR5Rm4gPSAoYSwgYikgPT4gYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCB8fFxuICAgIGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgfHxcbiAgICBhPy5tZWFzdXJlZC53aWR0aCAhPT0gYj8ubWVhc3VyZWQud2lkdGggfHxcbiAgICBhPy5tZWFzdXJlZC5oZWlnaHQgIT09IGI/Lm1lYXN1cmVkLmhlaWdodCB8fFxuICAgIGE/LnNlbGVjdGVkICE9PSBiPy5zZWxlY3RlZCB8fFxuICAgIGE/LmludGVybmFscy56ICE9PSBiPy5pbnRlcm5hbHMuejtcbmNvbnN0IG5vZGVzRXF1YWxpdHlGbiA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBhKSB7XG4gICAgICAgIGlmIChub2RlRXF1YWxpdHlGbihub2RlLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IHN0b3JlU2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG4gICAgc2VsZWN0ZWROb2Rlc0NvdW50OiBzdGF0ZS5ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpLmxlbmd0aCxcbn0pO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gcmVuZGVyIGEgdG9vbGJhciBvciB0b29sdGlwIHRvIG9uZSBzaWRlIG9mIGEgY3VzdG9tIG5vZGUuIFRoaXNcbiAqIHRvb2xiYXIgZG9lc24ndCBzY2FsZSB3aXRoIHRoZSB2aWV3cG9ydCBzbyB0aGF0IHRoZSBjb250ZW50IGlzIGFsd2F5cyB2aXNpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVRvb2xiYXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEN1c3RvbU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVUb29sYmFyIGlzVmlzaWJsZT17ZGF0YS50b29sYmFyVmlzaWJsZX0gcG9zaXRpb249e2RhdGEudG9vbGJhclBvc2l0aW9ufT5cbiAqICAgICAgICA8YnV0dG9uPmRlbGV0ZTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+Y29weTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+ZXhwYW5kPC9idXR0b24+XG4gKiAgICAgIDwvTm9kZVRvb2xiYXI+XG4gKlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhDdXN0b21Ob2RlKTtcbiAqYGBgXG4gKiBAcmVtYXJrcyBCeSBkZWZhdWx0LCB0aGUgdG9vbGJhciBpcyBvbmx5IHZpc2libGUgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQuIElmIG11bHRpcGxlXG4gKiBub2RlcyBhcmUgc2VsZWN0ZWQgaXQgd2lsbCBub3QgYmUgdmlzaWJsZSB0byBwcmV2ZW50IG92ZXJsYXBwaW5nIHRvb2xiYXJzIG9yXG4gKiBjbHV0dGVyLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyB0aGUgYGlzVmlzaWJsZWAgcHJvcCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIE5vZGVUb29sYmFyKHsgbm9kZUlkLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgb2Zmc2V0ID0gMTAsIGFsaWduID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBub2Rlc1NlbGVjdG9yID0gdXNlQ2FsbGJhY2soKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZCkgPyBub2RlSWQgOiBbbm9kZUlkIHx8IGNvbnRleHROb2RlSWQgfHwgJyddO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gbm9kZUlkcy5yZWR1Y2UoKHJlcywgaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxOb2RlcztcbiAgICB9LCBbbm9kZUlkLCBjb250ZXh0Tm9kZUlkXSk7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBub2Rlc0VxdWFsaXR5Rm4pO1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSwgc2VsZWN0ZWROb2Rlc0NvdW50IH0gPSB1c2VTdG9yZShzdG9yZVNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICAvLyBpZiBpc1Zpc2libGUgaXMgbm90IHNldCwgd2Ugc2hvdyB0aGUgdG9vbGJhciBvbmx5IGlmIGl0cyBub2RlIGlzIHNlbGVjdGVkIGFuZCBubyBvdGhlciBub2RlIGlzIHNlbGVjdGVkXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0eXBlb2YgaXNWaXNpYmxlID09PSAnYm9vbGVhbidcbiAgICAgICAgPyBpc1Zpc2libGVcbiAgICAgICAgOiBub2Rlcy5zaXplID09PSAxICYmIG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZT8uc2VsZWN0ZWQgJiYgc2VsZWN0ZWROb2Rlc0NvdW50ID09PSAxO1xuICAgIGlmICghaXNBY3RpdmUgfHwgIW5vZGVzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVSZWN0ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlcyk7XG4gICAgY29uc3Qgbm9kZXNBcnJheSA9IEFycmF5LmZyb20obm9kZXMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHpJbmRleCA9IE1hdGgubWF4KC4uLm5vZGVzQXJyYXkubWFwKChub2RlKSA9PiBub2RlLmludGVybmFscy56ICsgMSkpO1xuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHsgeCwgeSwgem9vbSB9LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbiksXG4gICAgICAgIHpJbmRleCxcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChOb2RlVG9vbGJhclBvcnRhbCwgeyBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGUtdG9vbGJhcicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0LCBcImRhdGEtaWRcIjogbm9kZXNBcnJheS5yZWR1Y2UoKGFjYywgbm9kZSkgPT4gYCR7YWNjfSR7bm9kZS5pZH0gYCwgJycpLnRyaW0oKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuY29uc3Qgem9vbVNlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS50cmFuc2Zvcm1bMl07XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGNhbiByZW5kZXIgYSB0b29sYmFyIG9yIHRvb2x0aXAgdG8gb25lIHNpZGUgb2YgYSBjdXN0b20gZWRnZS4gVGhpc1xuICogdG9vbGJhciBkb2Vzbid0IHNjYWxlIHdpdGggdGhlIHZpZXdwb3J0IHNvIHRoYXQgdGhlIGNvbnRlbnQgc3RheXMgdGhlIHNhbWUgc2l6ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgeyBFZGdlVG9vbGJhciwgQmFzZUVkZ2UsIGdldEJlemllclBhdGgsIHR5cGUgRWRnZVByb3BzIH0gZnJvbSBcIkB4eWZsb3cvcmVhY3RcIjtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IGlkLCBkYXRhLCAuLi5wcm9wcyB9OiBFZGdlUHJvcHMpIHtcbiAqICAgY29uc3QgW2VkZ2VQYXRoLCBjZW50ZXJYLCBjZW50ZXJZXSA9IGdldEJlemllclBhdGgocHJvcHMpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8PlxuICogICAgICAgPEJhc2VFZGdlIGlkPXtpZH0gcGF0aD17ZWRnZVBhdGh9IC8+XG4gKiAgICAgICA8RWRnZVRvb2xiYXIgZWRnZUlkPXtpZH0geD17Y2VudGVyWH0geT17Y2VudGVyWX0gaXNWaXNpYmxlPlxuICogICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGNvbnNvbGUubG9nKCdlZGdlJywgaWQsICdjbGljaycpfX0+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqICAgICAgIDwvRWRnZVRvb2xiYXI+XG4gKiAgICAgPC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gRWRnZVRvb2xiYXIoeyBlZGdlSWQsIHgsIHksIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCBpc1Zpc2libGUsIGFsaWduWCA9ICdjZW50ZXInLCBhbGlnblkgPSAnY2VudGVyJywgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgZWRnZVNlbGVjdG9yID0gdXNlQ2FsbGJhY2soKHN0YXRlKSA9PiBzdGF0ZS5lZGdlTG9va3VwLmdldChlZGdlSWQpLCBbZWRnZUlkXSk7XG4gICAgY29uc3QgZWRnZSA9IHVzZVN0b3JlKGVkZ2VTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB0eXBlb2YgaXNWaXNpYmxlID09PSAnYm9vbGVhbicgPyBpc1Zpc2libGUgOiBlZGdlPy5zZWxlY3RlZDtcbiAgICBjb25zdCB6b29tID0gdXNlU3RvcmUoem9vbVNlbGVjdG9yKTtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB6SW5kZXggPSAoZWRnZT8uekluZGV4ID8/IDApICsgMTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRFZGdlVG9vbGJhclRyYW5zZm9ybSh4LCB5LCB6b29tLCBhbGlnblgsIGFsaWduWSk7XG4gICAgcmV0dXJuIChqc3goRWRnZUxhYmVsUmVuZGVyZXIsIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICcwIDAnLFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgfSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdG9vbGJhcicsIGNsYXNzTmFtZV0pLCBcImRhdGEtaWRcIjogZWRnZT8uaWQgPz8gJycsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmV4cG9ydCB7IEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50LCBCYXNlRWRnZSwgQmV6aWVyRWRnZSwgQ29udHJvbEJ1dHRvbiwgQ29udHJvbHMsIEVkZ2VMYWJlbFJlbmRlcmVyLCBFZGdlVGV4dCwgRWRnZVRvb2xiYXIsIEhhbmRsZSwgTWluaU1hcCwgTWluaU1hcE5vZGUsIE5vZGVSZXNpemVDb250cm9sLCBOb2RlUmVzaXplciwgTm9kZVRvb2xiYXIsIFBhbmVsLCBpbmRleCBhcyBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCBTaW1wbGVCZXppZXJFZGdlLCBTbW9vdGhTdGVwRWRnZSwgU3RlcEVkZ2UsIFN0cmFpZ2h0RWRnZSwgVmlld3BvcnRQb3J0YWwsIGFwcGx5RWRnZUNoYW5nZXMsIGFwcGx5Tm9kZUNoYW5nZXMsIGV4cGVyaW1lbnRhbF91c2VPbkVkZ2VzQ2hhbmdlTWlkZGxld2FyZSwgZXhwZXJpbWVudGFsX3VzZU9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlLCBnZXRTaW1wbGVCZXppZXJQYXRoLCBpc0VkZ2UsIGlzTm9kZSwgdXNlQ29ubmVjdGlvbiwgdXNlRWRnZXMsIHVzZUVkZ2VzU3RhdGUsIHVzZUhhbmRsZUNvbm5lY3Rpb25zLCB1c2VJbnRlcm5hbE5vZGUsIHVzZUtleVByZXNzLCB1c2VOb2RlQ29ubmVjdGlvbnMsIHVzZU5vZGVJZCwgdXNlTm9kZXMsIHVzZU5vZGVzRGF0YSwgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbImpzeHMiLCJGcmFnbWVudCIsImpzeCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwibWVtbyIsImNjIiwiZXJyb3JNZXNzYWdlcyIsIm1lcmdlQXJpYUxhYmVsQ29uZmlnIiwiaW5maW5pdGVFeHRlbnQiLCJpc0lucHV0RE9NTm9kZSIsImdldFZpZXdwb3J0Rm9yQm91bmRzIiwicG9pbnRUb1JlbmRlcmVyUG9pbnQiLCJyZW5kZXJlclBvaW50VG9Qb2ludCIsImlzTm9kZUJhc2UiLCJpc0VkZ2VCYXNlIiwiZ2V0RWxlbWVudHNUb1JlbW92ZSIsImlzUmVjdE9iamVjdCIsIm5vZGVUb1JlY3QiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJnZXROb2Rlc0JvdW5kcyIsIndpdGhSZXNvbHZlcnMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJnZXREaW1lbnNpb25zIiwiWFlQYW5ab29tIiwiUGFuT25TY3JvbGxNb2RlIiwiU2VsZWN0aW9uTW9kZSIsImdldEV2ZW50UG9zaXRpb24iLCJnZXROb2Rlc0luc2lkZSIsImFyZVNldHNFcXVhbCIsIlhZRHJhZyIsInNuYXBQb3NpdGlvbiIsImNhbGN1bGF0ZU5vZGVQb3NpdGlvbiIsIlBvc2l0aW9uIiwiQ29ubmVjdGlvbk1vZGUiLCJpc01vdXNlRXZlbnQiLCJYWUhhbmRsZSIsImdldEhvc3RGb3JFbGVtZW50IiwiYWRkRWRnZSIsImdldEludGVybmFsTm9kZXNCb3VuZHMiLCJpc051bWVyaWMiLCJub2RlSGFzRGltZW5zaW9ucyIsImdldE5vZGVEaW1lbnNpb25zIiwiZWxlbWVudFNlbGVjdGlvbktleXMiLCJpc0VkZ2VWaXNpYmxlIiwiTWFya2VyVHlwZSIsImNyZWF0ZU1hcmtlcklkcyIsImdldEJlemllckVkZ2VDZW50ZXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImdldFN0cmFpZ2h0UGF0aCIsImdldEJlemllclBhdGgiLCJnZXRFZGdlUG9zaXRpb24iLCJnZXRFbGV2YXRlZEVkZ2VaSW5kZXgiLCJnZXRNYXJrZXJJZCIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW9uTGluZVR5cGUiLCJ1cGRhdGVDb25uZWN0aW9uTG9va3VwIiwiYWRvcHRVc2VyTm9kZXMiLCJpbml0aWFsQ29ubmVjdGlvbiIsImRldldhcm4iLCJkZWZhdWx0QXJpYUxhYmVsQ29uZmlnIiwidXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUFic29sdXRlUG9zaXRpb25zIiwiZ2V0SGFuZGxlUG9zaXRpb24iLCJoYW5kbGVFeHBhbmRQYXJlbnQiLCJwYW5CeSIsImZpdFZpZXdwb3J0IiwiaXNNYWNPcyIsImFyZUNvbm5lY3Rpb25NYXBzRXF1YWwiLCJoYW5kbGVDb25uZWN0aW9uQ2hhbmdlIiwic2hhbGxvd05vZGVEYXRhIiwiWFlNaW5pbWFwIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsIlJlc2l6ZUNvbnRyb2xWYXJpYW50IiwiWFlSZXNpemVyIiwiWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyIsIlhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUyIsImdldE5vZGVUb29sYmFyVHJhbnNmb3JtIiwiZ2V0RWRnZVRvb2xiYXJUcmFuc2Zvcm0iLCJnZXRDb25uZWN0ZWRFZGdlcyIsImdldEVkZ2VDZW50ZXIiLCJnZXRJbmNvbWVycyIsImdldE91dGdvZXJzIiwicmVjb25uZWN0RWRnZSIsInVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4iLCJjcmVhdGVXaXRoRXF1YWxpdHlGbiIsInNoYWxsb3ciLCJjcmVhdGVQb3J0YWwiLCJTdG9yZUNvbnRleHQiLCJQcm92aWRlciQxIiwiUHJvdmlkZXIiLCJ6dXN0YW5kRXJyb3JNZXNzYWdlIiwidXNlU3RvcmUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJzdG9yZSIsIkVycm9yIiwidXNlU3RvcmVBcGkiLCJnZXRTdGF0ZSIsInNldFN0YXRlIiwic3Vic2NyaWJlIiwic3R5bGUiLCJkaXNwbGF5IiwiYXJpYUxpdmVTdHlsZSIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJjbGlwIiwiY2xpcFBhdGgiLCJBUklBX05PREVfREVTQ19LRVkiLCJBUklBX0VER0VfREVTQ19LRVkiLCJBUklBX0xJVkVfTUVTU0FHRSIsImFyaWFMaXZlU2VsZWN0b3IiLCJzIiwiYXJpYUxpdmVNZXNzYWdlIiwiYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IiLCJhcmlhTGFiZWxDb25maWciLCJBcmlhTGl2ZU1lc3NhZ2UiLCJyZklkIiwiaWQiLCJjaGlsZHJlbiIsIkExMXlEZXNjcmlwdGlvbnMiLCJkaXNhYmxlS2V5Ym9hcmRBMTF5IiwiUGFuZWwiLCJjbGFzc05hbWUiLCJyZXN0IiwicmVmIiwicG9zaXRpb25DbGFzc2VzIiwic3BsaXQiLCJkaXNwbGF5TmFtZSIsIkF0dHJpYnV0aW9uIiwicHJvT3B0aW9ucyIsImhpZGVBdHRyaWJ1dGlvbiIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJzZWxlY3RvciRtIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkRWRnZXMiLCJub2RlIiwibm9kZUxvb2t1cCIsInNlbGVjdGVkIiwicHVzaCIsImludGVybmFscyIsInVzZXJOb2RlIiwiZWRnZSIsImVkZ2VMb29rdXAiLCJzZWxlY3RJZCIsIm9iaiIsImFyZUVxdWFsIiwiYSIsImIiLCJtYXAiLCJTZWxlY3Rpb25MaXN0ZW5lcklubmVyIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJwYXJhbXMiLCJub2RlcyIsImVkZ2VzIiwib25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImZvckVhY2giLCJmbiIsImNoYW5nZVNlbGVjdG9yIiwiU2VsZWN0aW9uTGlzdGVuZXIiLCJzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZGVmYXVsdE5vZGVPcmlnaW4iLCJkZWZhdWx0Vmlld3BvcnQiLCJ4IiwieSIsInpvb20iLCJyZWFjdEZsb3dGaWVsZHNUb1RyYWNrIiwiZmllbGRzVG9UcmFjayIsInNlbGVjdG9yJGwiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwic2V0TWluWm9vbSIsInNldE1heFpvb20iLCJzZXRUcmFuc2xhdGVFeHRlbnQiLCJzZXROb2RlRXh0ZW50IiwicmVzZXQiLCJzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyIsImluaXRQcmV2VmFsdWVzIiwidHJhbnNsYXRlRXh0ZW50Iiwibm9kZU9yaWdpbiIsIm1pblpvb20iLCJtYXhab29tIiwiZWxlbWVudHNTZWxlY3RhYmxlIiwibm9QYW5DbGFzc05hbWUiLCJTdG9yZVVwZGF0ZXIiLCJwcm9wcyIsImRlZmF1bHROb2RlcyIsImRlZmF1bHRFZGdlcyIsInByZXZpb3VzRmllbGRzIiwiY3VycmVudCIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJwcmV2aW91c0ZpZWxkVmFsdWUiLCJmaXRWaWV3UXVldWVkIiwiZml0Vmlld09wdGlvbnMiLCJnZXRNZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsInVzZUNvbG9yTW9kZUNsYXNzIiwiY29sb3JNb2RlIiwiY29sb3JNb2RlQ2xhc3MiLCJzZXRDb2xvck1vZGVDbGFzcyIsIm1lZGlhUXVlcnkiLCJ1cGRhdGVDb2xvck1vZGVDbGFzcyIsIm1hdGNoZXMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHREb2MiLCJkb2N1bWVudCIsInVzZUtleVByZXNzIiwia2V5Q29kZSIsIm9wdGlvbnMiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJmaWx0ZXIiLCJrYyIsInJlcGxhY2UiLCJrZXlzRmxhdCIsInJlZHVjZSIsInJlcyIsIml0ZW0iLCJjb25jYXQiLCJkb3duSGFuZGxlciIsImV2ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsInByZXZlbnRBY3Rpb24iLCJrZXlPckNvZGUiLCJ1c2VLZXlPckNvZGUiLCJjb2RlIiwiYWRkIiwiaXNNYXRjaGluZ0tleSIsImNvbXBvc2VkUGF0aCIsImlzSW50ZXJhY3RpdmVFbGVtZW50Iiwibm9kZU5hbWUiLCJwcmV2ZW50RGVmYXVsdCIsInVwSGFuZGxlciIsImNsZWFyIiwiZGVsZXRlIiwia2V5IiwicmVzZXRIYW5kbGVyIiwiaXNVcCIsImxlbmd0aCIsInNpemUiLCJzb21lIiwiZXZlcnkiLCJrIiwiaGFzIiwiZXZlbnRDb2RlIiwiaW5jbHVkZXMiLCJ1c2VWaWV3cG9ydEhlbHBlciIsInpvb21JbiIsInBhblpvb20iLCJzY2FsZUJ5IiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInpvb21PdXQiLCJ6b29tVG8iLCJ6b29tTGV2ZWwiLCJzY2FsZVRvIiwiZ2V0Wm9vbSIsInRyYW5zZm9ybSIsInNldFZpZXdwb3J0Iiwidmlld3BvcnQiLCJ0WCIsInRZIiwidFpvb20iLCJnZXRWaWV3cG9ydCIsInNldENlbnRlciIsImZpdEJvdW5kcyIsImJvdW5kcyIsImVhc2UiLCJpbnRlcnBvbGF0ZSIsInNjcmVlblRvRmxvd1Bvc2l0aW9uIiwiY2xpZW50UG9zaXRpb24iLCJzbmFwR3JpZCIsInNuYXBUb0dyaWQiLCJkb21Ob2RlIiwiZG9tWCIsImRvbVkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3JyZWN0ZWRQb3NpdGlvbiIsIl9zbmFwR3JpZCIsIl9zbmFwVG9HcmlkIiwiZmxvd1RvU2NyZWVuUG9zaXRpb24iLCJmbG93UG9zaXRpb24iLCJyZW5kZXJlclBvc2l0aW9uIiwiYXBwbHlDaGFuZ2VzIiwiY2hhbmdlcyIsImVsZW1lbnRzIiwidXBkYXRlZEVsZW1lbnRzIiwiY2hhbmdlc01hcCIsIk1hcCIsImFkZEl0ZW1DaGFuZ2VzIiwiY2hhbmdlIiwidHlwZSIsInNldCIsImVsZW1lbnRDaGFuZ2VzIiwiZ2V0IiwiZWxlbWVudCIsInVwZGF0ZWRFbGVtZW50IiwiYXBwbHlDaGFuZ2UiLCJpbmRleCIsInVuZGVmaW5lZCIsInNwbGljZSIsImRyYWdnaW5nIiwiZGltZW5zaW9ucyIsIm1lYXN1cmVkIiwic2V0QXR0cmlidXRlcyIsInJlc2l6aW5nIiwiYXBwbHlOb2RlQ2hhbmdlcyIsImFwcGx5RWRnZUNoYW5nZXMiLCJjcmVhdGVTZWxlY3Rpb25DaGFuZ2UiLCJnZXRTZWxlY3Rpb25DaGFuZ2VzIiwiaXRlbXMiLCJzZWxlY3RlZElkcyIsIm11dGF0ZUl0ZW0iLCJ3aWxsQmVTZWxlY3RlZCIsImdldEVsZW1lbnRzRGlmZkNoYW5nZXMiLCJsb29rdXAiLCJpdGVtc0xvb2t1cCIsImVudHJpZXMiLCJsb29rdXBJdGVtIiwic3RvcmVJdGVtIiwibmV4dE5vZGUiLCJlbGVtZW50VG9SZW1vdmVDaGFuZ2UiLCJpc05vZGUiLCJpc0VkZ2UiLCJmaXhlZEZvcndhcmRSZWYiLCJyZW5kZXIiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlUXVldWUiLCJydW5RdWV1ZSIsInNlcmlhbCIsInNldFNlcmlhbCIsIkJpZ0ludCIsInF1ZXVlIiwiY3JlYXRlUXVldWUiLCJuIiwicXVldWVJdGVtcyIsImNiIiwiQmF0Y2hDb250ZXh0IiwiQmF0Y2hQcm92aWRlciIsIm5vZGVRdWV1ZUhhbmRsZXIiLCJoYXNEZWZhdWx0Tm9kZXMiLCJvbk5vZGVzQ2hhbmdlIiwib25Ob2Rlc0NoYW5nZU1pZGRsZXdhcmVNYXAiLCJuZXh0IiwicGF5bG9hZCIsIm1pZGRsZXdhcmUiLCJ2YWx1ZXMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub2RlUXVldWUiLCJlZGdlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdEVkZ2VzIiwib25FZGdlc0NoYW5nZSIsImVkZ2VRdWV1ZSIsInZhbHVlIiwidXNlQmF0Y2hDb250ZXh0IiwiYmF0Y2hDb250ZXh0Iiwic2VsZWN0b3IkayIsInVzZVJlYWN0RmxvdyIsInZpZXdwb3J0SGVscGVyIiwidmlld3BvcnRJbml0aWFsaXplZCIsImdlbmVyYWxIZWxwZXIiLCJnZXRJbnRlcm5hbE5vZGUiLCJnZXROb2RlUmVjdCIsIm5vZGVUb1VzZSIsInBhcmVudElkIiwibm9kZVdpdGhQb3NpdGlvbiIsInVwZGF0ZU5vZGUiLCJub2RlVXBkYXRlIiwicHJldk5vZGVzIiwidXBkYXRlRWRnZSIsImVkZ2VVcGRhdGUiLCJwcmV2RWRnZXMiLCJuZXh0RWRnZSIsImdldE5vZGVzIiwiZ2V0Tm9kZSIsImdldEVkZ2VzIiwiZSIsImdldEVkZ2UiLCJhZGROb2RlcyIsIm5ld05vZGVzIiwiYWRkRWRnZXMiLCJuZXdFZGdlcyIsInRvT2JqZWN0IiwiZGVsZXRlRWxlbWVudHMiLCJub2Rlc1RvUmVtb3ZlIiwiZWRnZXNUb1JlbW92ZSIsIm9uTm9kZXNEZWxldGUiLCJvbkVkZ2VzRGVsZXRlIiwidHJpZ2dlck5vZGVDaGFuZ2VzIiwidHJpZ2dlckVkZ2VDaGFuZ2VzIiwib25EZWxldGUiLCJvbkJlZm9yZURlbGV0ZSIsIm1hdGNoaW5nTm9kZXMiLCJtYXRjaGluZ0VkZ2VzIiwiaGFzTWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nTm9kZXMiLCJlZGdlQ2hhbmdlcyIsIm5vZGVDaGFuZ2VzIiwiZGVsZXRlZE5vZGVzIiwiZGVsZXRlZEVkZ2VzIiwiZ2V0SW50ZXJzZWN0aW5nTm9kZXMiLCJub2RlT3JSZWN0IiwicGFydGlhbGx5IiwiaXNSZWN0Iiwibm9kZVJlY3QiLCJoYXNOb2Rlc09wdGlvbiIsImludGVybmFsTm9kZSIsInBvc2l0aW9uQWJzb2x1dGUiLCJjdXJyTm9kZVJlY3QiLCJvdmVybGFwcGluZ0FyZWEiLCJwYXJ0aWFsbHlWaXNpYmxlIiwiaXNOb2RlSW50ZXJzZWN0aW5nIiwiYXJlYSIsInVwZGF0ZU5vZGVEYXRhIiwiZGF0YVVwZGF0ZSIsIm5leHREYXRhIiwiZGF0YSIsInVwZGF0ZUVkZ2VEYXRhIiwiZ2V0SGFuZGxlQ29ubmVjdGlvbnMiLCJub2RlSWQiLCJmcm9tIiwiY29ubmVjdGlvbkxvb2t1cCIsImdldE5vZGVDb25uZWN0aW9ucyIsImhhbmRsZUlkIiwiZml0VmlldyIsImZpdFZpZXdSZXNvbHZlciIsInByb21pc2UiLCJ3aW4kMSIsInVzZUdsb2JhbEtleUhhbmRsZXIiLCJkZWxldGVLZXlDb2RlIiwibXVsdGlTZWxlY3Rpb25LZXlDb2RlIiwiZGVsZXRlS2V5UHJlc3NlZCIsIm11bHRpU2VsZWN0aW9uS2V5UHJlc3NlZCIsIm5vZGVzU2VsZWN0aW9uQWN0aXZlIiwibXVsdGlTZWxlY3Rpb25BY3RpdmUiLCJ1c2VSZXNpemVIYW5kbGVyIiwidXBkYXRlRGltZW5zaW9ucyIsImNoZWNrVmlzaWJpbGl0eSIsIm9uRXJyb3IiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNvbnRhaW5lclN0eWxlIiwidG9wIiwibGVmdCIsInNlbGVjdG9yJGoiLCJ1c2VyU2VsZWN0aW9uQWN0aXZlIiwibGliIiwiY29ubmVjdGlvbkluUHJvZ3Jlc3MiLCJjb25uZWN0aW9uIiwiaW5Qcm9ncmVzcyIsIlpvb21QYW5lIiwib25QYW5lQ29udGV4dE1lbnUiLCJ6b29tT25TY3JvbGwiLCJ6b29tT25QaW5jaCIsInBhbk9uU2Nyb2xsIiwicGFuT25TY3JvbGxTcGVlZCIsInBhbk9uU2Nyb2xsTW9kZSIsIkZyZWUiLCJ6b29tT25Eb3VibGVDbGljayIsInBhbk9uRHJhZyIsInpvb21BY3RpdmF0aW9uS2V5Q29kZSIsInByZXZlbnRTY3JvbGxpbmciLCJub1doZWVsQ2xhc3NOYW1lIiwib25WaWV3cG9ydENoYW5nZSIsImlzQ29udHJvbGxlZFZpZXdwb3J0IiwicGFuZUNsaWNrRGlzdGFuY2UiLCJzZWxlY3Rpb25PbkRyYWciLCJ6b29tUGFuZSIsInpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIm9uVHJhbnNmb3JtQ2hhbmdlIiwib25EcmFnZ2luZ0NoYW5nZSIsInBhbmVEcmFnZ2luZyIsIm9uUGFuWm9vbVN0YXJ0IiwidnAiLCJvblZpZXdwb3J0Q2hhbmdlU3RhcnQiLCJvbk1vdmVTdGFydCIsIm9uUGFuWm9vbSIsIm9uTW92ZSIsIm9uUGFuWm9vbUVuZCIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJvbk1vdmVFbmQiLCJjbG9zZXN0IiwiZGVzdHJveSIsInVwZGF0ZSIsInNlbGVjdG9yJGkiLCJ1c2VyU2VsZWN0aW9uUmVjdCIsIlVzZXJTZWxlY3Rpb24iLCJpc0FjdGl2ZSIsIndyYXBIYW5kbGVyIiwiaGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJGgiLCJQYW5lIiwiaXNTZWxlY3RpbmciLCJzZWxlY3Rpb25LZXlQcmVzc2VkIiwic2VsZWN0aW9uTW9kZSIsIkZ1bGwiLCJvblNlbGVjdGlvblN0YXJ0Iiwib25TZWxlY3Rpb25FbmQiLCJvblBhbmVDbGljayIsIm9uUGFuZVNjcm9sbCIsIm9uUGFuZU1vdXNlRW50ZXIiLCJvblBhbmVNb3VzZU1vdmUiLCJvblBhbmVNb3VzZUxlYXZlIiwiaXNTZWxlY3Rpb25FbmFibGVkIiwiY29udGFpbmVyIiwiY29udGFpbmVyQm91bmRzIiwic2VsZWN0ZWROb2RlSWRzIiwic2VsZWN0ZWRFZGdlSWRzIiwic2VsZWN0aW9uSW5Qcm9ncmVzcyIsIm9uQ2xpY2siLCJyZXNldFNlbGVjdGVkRWxlbWVudHMiLCJvbkNvbnRleHRNZW51Iiwib25XaGVlbCIsIm9uQ2xpY2tDYXB0dXJlIiwic3RvcFByb3BhZ2F0aW9uIiwib25Qb2ludGVyRG93bkNhcHR1cmUiLCJldmVudFRhcmdldElzQ29udGFpbmVyIiwiaXNOb0tleUV2ZW50IiwiaXNTZWxlY3Rpb25BY3RpdmUiLCJidXR0b24iLCJpc1ByaW1hcnkiLCJzZXRQb2ludGVyQ2FwdHVyZSIsInBvaW50ZXJJZCIsIm5hdGl2ZUV2ZW50Iiwic3RhcnRYIiwic3RhcnRZIiwib25Qb2ludGVyTW92ZSIsImRlZmF1bHRFZGdlT3B0aW9ucyIsIm1vdXNlWCIsIm1vdXNlWSIsInJlcXVpcmVkRGlzdGFuY2UiLCJkaXN0YW5jZSIsIk1hdGgiLCJoeXBvdCIsIm5leHRVc2VyU2VsZWN0UmVjdCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwib25Qb2ludGVyRG93biIsImlzTW91c2VUcmlnZ2VyZWQiLCJjdXJyZW50U3RvcmUiLCJoYW5kbGVEb21Ob2RlIiwiY3VycmVudFRhcmdldCIsImF1dG9QYW5PbkNvbm5lY3QiLCJjb25uZWN0aW9uUmFkaXVzIiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0RW5kIiwidXBkYXRlQ29ubmVjdGlvbiIsImdldFRyYW5zZm9ybSIsImdldEZyb21IYW5kbGUiLCJhdXRvUGFuU3BlZWQiLCJkcmFnVGhyZXNob2xkIiwiY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQiLCJvbkNsaWNrQ29ubmVjdFN0YXJ0Iiwib25DbGlja0Nvbm5lY3RFbmQiLCJpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIiwiY29ubmVjdGlvblN0YXRlIiwiaGFuZGxlVHlwZSIsImRvYyIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImhhbmRsZSIsImZyb21Ob2RlSWQiLCJmcm9tSGFuZGxlSWQiLCJmcm9tVHlwZSIsImNvbm5lY3Rpb25DbG9uZSIsInN0cnVjdHVyZWRDbG9uZSIsInRvUG9zaXRpb24iLCJzb3VyY2UiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNsaWNrY29ubmVjdGluZyIsImNvbm5lY3Rpbmdmcm9tIiwiY29ubmVjdGluZ3RvIiwiY29ubmVjdGlvbmluZGljYXRvciIsIkhhbmRsZSIsIklucHV0Tm9kZSIsInNvdXJjZVBvc2l0aW9uIiwiQm90dG9tIiwibGFiZWwiLCJEZWZhdWx0Tm9kZSIsInRhcmdldFBvc2l0aW9uIiwiR3JvdXBOb2RlIiwiT3V0cHV0Tm9kZSIsImFycm93S2V5RGlmZnMiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiQXJyb3dMZWZ0IiwiQXJyb3dSaWdodCIsImJ1aWx0aW5Ob2RlVHlwZXMiLCJpbnB1dCIsImRlZmF1bHQiLCJvdXRwdXQiLCJncm91cCIsImdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMiLCJoYW5kbGVCb3VuZHMiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2VsZWN0b3IkZiIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9uS2V5RG93biIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRhYkluZGV4Iiwid2luIiwic2VsZWN0b3IkZSIsIkZsb3dSZW5kZXJlckNvbXBvbmVudCIsInNlbGVjdGlvbktleUNvZGUiLCJwYW5BY3RpdmF0aW9uS2V5Q29kZSIsIl9wYW5PblNjcm9sbCIsIl9wYW5PbkRyYWciLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIl9zZWxlY3Rpb25PbkRyYWciLCJGbG93UmVuZGVyZXIiLCJzZWxlY3RvciRkIiwib25seVJlbmRlclZpc2libGUiLCJ1c2VWaXNpYmxlTm9kZUlkcyIsIm5vZGVJZHMiLCJzZWxlY3RvciRjIiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1cGRhdGVzIiwiZW50cnkiLCJnZXRBdHRyaWJ1dGUiLCJub2RlRWxlbWVudCIsImZvcmNlIiwiZGlzY29ubmVjdCIsInVzZU5vZGVPYnNlcnZlciIsIm5vZGVUeXBlIiwiaGFzRGltZW5zaW9ucyIsIm9ic2VydmVkTm9kZSIsInByZXZTb3VyY2VQb3NpdGlvbiIsInByZXZUYXJnZXRQb3NpdGlvbiIsInByZXZUeXBlIiwiaXNJbml0aWFsaXplZCIsImhpZGRlbiIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJOb2RlV3JhcHBlciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsIm5vZGVUeXBlcyIsImlzUGFyZW50IiwicGFyZW50TG9va3VwIiwiTm9kZUNvbXBvbmVudCIsImlzRHJhZ2dhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJvbkZvY3VzIiwiYXV0b1Bhbk9uTm9kZUZvY3VzIiwid2l0aGluVmlld3BvcnQiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwicG9pbnRlckV2ZW50cyIsInZpc2liaWxpdHkiLCJyb2xlIiwiYXJpYVJvbGUiLCJhcmlhTGFiZWwiLCJkb21BdHRyaWJ1dGVzIiwicG9zaXRpb25BYnNvbHV0ZVgiLCJwb3NpdGlvbkFic29sdXRlWSIsImRlbGV0YWJsZSIsIk5vZGVXcmFwcGVyJDEiLCJzZWxlY3RvciRiIiwiTm9kZVJlbmRlcmVyQ29tcG9uZW50Iiwib25seVJlbmRlclZpc2libGVFbGVtZW50cyIsIm9uTm9kZUNsaWNrIiwib25Ob2RlTW91c2VFbnRlciIsIm9uTm9kZU1vdXNlTW92ZSIsIm9uTm9kZU1vdXNlTGVhdmUiLCJvbk5vZGVDb250ZXh0TWVudSIsIm9uTm9kZURvdWJsZUNsaWNrIiwiTm9kZVJlbmRlcmVyIiwidXNlVmlzaWJsZUVkZ2VJZHMiLCJlZGdlSWRzIiwidmlzaWJsZUVkZ2VJZHMiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIkFycm93U3ltYm9sIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJmaWxsIiwic3Ryb2tlTGluZWpvaW4iLCJwb2ludHMiLCJBcnJvd0Nsb3NlZFN5bWJvbCIsIk1hcmtlclN5bWJvbHMiLCJBcnJvdyIsIkFycm93Q2xvc2VkIiwidXNlTWFya2VyU3ltYm9sIiwic3ltYm9sIiwic3ltYm9sRXhpc3RzIiwiTWFya2VyIiwibWFya2VyVW5pdHMiLCJvcmllbnQiLCJTeW1ib2wiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsInZpZXdCb3giLCJyZWZYIiwicmVmWSIsIk1hcmtlckRlZmluaXRpb25zIiwiZGVmYXVsdENvbG9yIiwibWFya2VycyIsImRlZmF1bHRNYXJrZXJTdGFydCIsIm1hcmtlclN0YXJ0IiwiZGVmYXVsdE1hcmtlckVuZCIsIm1hcmtlckVuZCIsIm1hcmtlciIsIk1hcmtlckRlZmluaXRpb25zJDEiLCJFZGdlVGV4dENvbXBvbmVudCIsImxhYmVsU3R5bGUiLCJsYWJlbFNob3dCZyIsImxhYmVsQmdTdHlsZSIsImxhYmVsQmdQYWRkaW5nIiwibGFiZWxCZ0JvcmRlclJhZGl1cyIsImVkZ2VUZXh0QmJveCIsInNldEVkZ2VUZXh0QmJveCIsImVkZ2VUZXh0Q2xhc3NlcyIsImVkZ2VUZXh0UmVmIiwidGV4dEJib3giLCJnZXRCQm94IiwicngiLCJyeSIsImR5IiwiRWRnZVRleHQiLCJCYXNlRWRnZSIsInBhdGgiLCJsYWJlbFgiLCJsYWJlbFkiLCJpbnRlcmFjdGlvbldpZHRoIiwiZCIsInN0cm9rZU9wYWNpdHkiLCJnZXRDb250cm9sIiwicG9zIiwieDEiLCJ5MSIsIngyIiwieTIiLCJMZWZ0IiwiUmlnaHQiLCJnZXRTaW1wbGVCZXppZXJQYXRoIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInNvdXJjZUNvbnRyb2xYIiwic291cmNlQ29udHJvbFkiLCJ0YXJnZXRDb250cm9sWCIsInRhcmdldENvbnRyb2xZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJjcmVhdGVTaW1wbGVCZXppZXJFZGdlIiwiX2lkIiwiaXNJbnRlcm5hbCIsIlNpbXBsZUJlemllckVkZ2UiLCJTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwiLCJjcmVhdGVTbW9vdGhTdGVwRWRnZSIsInBhdGhPcHRpb25zIiwiYm9yZGVyUmFkaXVzIiwib2Zmc2V0Iiwic3RlcFBvc2l0aW9uIiwiU21vb3RoU3RlcEVkZ2UiLCJTbW9vdGhTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RlcEVkZ2UiLCJTdGVwRWRnZSIsIlN0ZXBFZGdlSW50ZXJuYWwiLCJjcmVhdGVTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2VJbnRlcm5hbCIsImNyZWF0ZUJlemllckVkZ2UiLCJjdXJ2YXR1cmUiLCJCZXppZXJFZGdlIiwiQmV6aWVyRWRnZUludGVybmFsIiwiYnVpbHRpbkVkZ2VUeXBlcyIsInN0cmFpZ2h0Iiwic3RlcCIsInNtb290aHN0ZXAiLCJzaW1wbGViZXppZXIiLCJudWxsUG9zaXRpb24iLCJzaGlmdFgiLCJzaGlmdCIsInNoaWZ0WSIsIkVkZ2VVcGRhdGVyQ2xhc3NOYW1lIiwiRWRnZUFuY2hvciIsImNlbnRlclgiLCJjZW50ZXJZIiwicmFkaXVzIiwib25Nb3VzZU91dCIsImN4IiwiY3kiLCJyIiwiRWRnZVVwZGF0ZUFuY2hvcnMiLCJpc1JlY29ubmVjdGFibGUiLCJyZWNvbm5lY3RSYWRpdXMiLCJvblJlY29ubmVjdCIsIm9uUmVjb25uZWN0U3RhcnQiLCJvblJlY29ubmVjdEVuZCIsInNldFJlY29ubmVjdGluZyIsInNldFVwZGF0ZUhvdmVyIiwiaGFuZGxlRWRnZVVwZGF0ZXIiLCJvcHBvc2l0ZUhhbmRsZSIsIl9vblJlY29ubmVjdEVuZCIsImV2dCIsIm9uQ29ubmVjdEVkZ2UiLCJfb25Db25uZWN0U3RhcnQiLCJfZXZlbnQiLCJlZGdlVXBkYXRlclR5cGUiLCJvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biIsInRhcmdldEhhbmRsZSIsIm9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duIiwic291cmNlSGFuZGxlIiwib25SZWNvbm5lY3RNb3VzZUVudGVyIiwib25SZWNvbm5lY3RNb3VzZU91dCIsIkVkZ2VXcmFwcGVyIiwiZWRnZXNGb2N1c2FibGUiLCJlZGdlc1JlY29ubmVjdGFibGUiLCJlZGdlVHlwZXMiLCJlZGdlVHlwZSIsIkVkZ2VDb21wb25lbnQiLCJyZWNvbm5lY3RhYmxlIiwiZWRnZVJlZiIsInVwZGF0ZUhvdmVyIiwicmVjb25uZWN0aW5nIiwiZWRnZVBvc2l0aW9uIiwiZWxldmF0ZU9uU2VsZWN0IiwiZWxldmF0ZUVkZ2VzT25TZWxlY3QiLCJ6SW5kZXhNb2RlIiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGljayIsIm9uRWRnZUNvbnRleHRNZW51Iiwib25FZGdlTW91c2VFbnRlciIsIm9uRWRnZU1vdXNlTW92ZSIsIm9uRWRnZU1vdXNlTGVhdmUiLCJhbmltYXRlZCIsImluYWN0aXZlIiwidXBkYXRpbmciLCJzb3VyY2VIYW5kbGVJZCIsInRhcmdldEhhbmRsZUlkIiwiRWRnZVdyYXBwZXIkMSIsInNlbGVjdG9yJGEiLCJFZGdlUmVuZGVyZXJDb21wb25lbnQiLCJkZWZhdWx0TWFya2VyQ29sb3IiLCJFZGdlUmVuZGVyZXIiLCJzZWxlY3RvciQ5IiwiVmlld3BvcnQiLCJ1c2VPbkluaXRIYW5kbGVyIiwib25Jbml0IiwicmZJbnN0YW5jZSIsInNldFRpbWVvdXQiLCJzZWxlY3RvciQ4Iiwic3luY1ZpZXdwb3J0IiwidXNlVmlld3BvcnRTeW5jIiwic3RvcmVTZWxlY3RvciQxIiwidG8iLCJnZXRTZWxlY3RvciIsImNvbm5lY3Rpb25TZWxlY3RvciIsImNvbWJpbmVkU2VsZWN0b3IiLCJ1c2VDb25uZWN0aW9uIiwic2VsZWN0b3IkNyIsIkNvbm5lY3Rpb25MaW5lV3JhcHBlciIsImNvbXBvbmVudCIsInJlbmRlckNvbm5lY3Rpb24iLCJDb25uZWN0aW9uTGluZSIsIkN1c3RvbUNvbXBvbmVudCIsIkJlemllciIsImZyb21Ob2RlIiwiZnJvbVBvc2l0aW9uIiwidG9Ob2RlIiwicG9pbnRlciIsImNvbm5lY3Rpb25MaW5lVHlwZSIsImNvbm5lY3Rpb25MaW5lU3R5bGUiLCJmcm9tWCIsImZyb21ZIiwidG9YIiwidG9ZIiwiY29ubmVjdGlvblN0YXR1cyIsInBhdGhQYXJhbXMiLCJTaW1wbGVCZXppZXIiLCJTdGVwIiwiU21vb3RoU3RlcCIsImVtcHR5VHlwZXMiLCJ1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nIiwibm9kZU9yRWRnZVR5cGVzIiwidHlwZXNSZWYiLCJwcm9jZXNzIiwidXNlZEtleXMiLCJ1c2VTdHlsZXNMb2FkZWRXYXJuaW5nIiwiY2hlY2tlZCIsInBhbmUiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIkdyYXBoVmlld0NvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29tcG9uZW50IiwiY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSIsIkdyYXBoVmlldyIsImdldEluaXRpYWxTdGF0ZSIsInN0b3JlRWRnZXMiLCJzdG9yZU5vZGVzIiwic3RvcmVOb2RlT3JpZ2luIiwic3RvcmVOb2RlRXh0ZW50Iiwibm9kZXNJbml0aWFsaXplZCIsImVsZXZhdGVOb2Rlc09uU2VsZWN0IiwiYXV0b1Bhbk9uTm9kZURyYWciLCJkZWJ1ZyIsIm9uRWRnZXNDaGFuZ2VNaWRkbGV3YXJlTWFwIiwiY3JlYXRlU3RvcmUiLCJyZXNvbHZlRml0VmlldyIsImNoZWNrRXF1YWxpdHkiLCJ1cGRhdGVkSW50ZXJuYWxzIiwiY29uc29sZSIsImxvZyIsIm5vZGVEcmFnSXRlbXMiLCJwYXJlbnRFeHBhbmRDaGlsZHJlbiIsImRyYWdJdGVtIiwiZXhwYW5kUGFyZW50IiwibWF4IiwidXBkYXRlZEZyb20iLCJyZWN0IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwibmV4dE5vZGVFeHRlbnQiLCJkZWx0YSIsIm5leHRab29tIiwiaXMiLCJSZWFjdEZsb3dQcm92aWRlciIsImluaXRpYWxOb2RlcyIsImluaXRpYWxFZGdlcyIsImluaXRpYWxNaW5ab29tIiwiaW5pdGlhbE1heFpvb20iLCJpbml0aWFsRml0Vmlld09wdGlvbnMiLCJXcmFwcGVyIiwiaXNXcmFwcGVkIiwid3JhcHBlclN0eWxlIiwiUmVhY3RGbG93Iiwib25Ob2RlRHJhZ1N0YXJ0Iiwib25Ob2RlRHJhZyIsIm9uTm9kZURyYWdTdG9wIiwib25TZWxlY3Rpb25EcmFnU3RhcnQiLCJvblNlbGVjdGlvbkRyYWciLCJvblNlbGVjdGlvbkRyYWdTdG9wIiwiZGVmYXVsdFZpZXdwb3J0JDEiLCJhdHRyaWJ1dGlvblBvc2l0aW9uIiwib25TY3JvbGwiLCJjb2xvck1vZGVDbGFzc05hbWUiLCJ3cmFwcGVyT25TY3JvbGwiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwic2VsZWN0b3IkNiIsIkVkZ2VMYWJlbFJlbmRlcmVyIiwiZWRnZUxhYmVsUmVuZGVyZXIiLCJzZWxlY3RvciQ1IiwiVmlld3BvcnRQb3J0YWwiLCJ2aWV3UG9ydGFsRGl2IiwidXNlVXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUlkcyIsInVwZGF0ZUlkIiwidHJpZ2dlckZpdFZpZXciLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJ1c2VOb2Rlc1N0YXRlIiwibmRzIiwidXNlRWRnZXNTdGF0ZSIsImVkcyIsInVzZU9uVmlld3BvcnRDaGFuZ2UiLCJvblN0YXJ0Iiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJuZXh0SGFuZGxlcnMiLCJzZWxlY3RvciQ0IiwiaW5jbHVkZUhpZGRlbk5vZGVzIiwidXNlTm9kZXNJbml0aWFsaXplZCIsImluaXRpYWxpemVkIiwidXNlSGFuZGxlQ29ubmVjdGlvbnMiLCJvbkRpc2Nvbm5lY3QiLCJ3YXJuIiwiX25vZGVJZCIsImN1cnJlbnROb2RlSWQiLCJwcmV2Q29ubmVjdGlvbnMiLCJfY29ubmVjdGlvbnMiLCJlcnJvcjAxNCIsInVzZU5vZGVDb25uZWN0aW9ucyIsInVzZU5vZGVzRGF0YSIsIm5vZGVzRGF0YSIsImlzQXJyYXlPZklkcyIsIl9ub2RlSWRzIiwidXNlSW50ZXJuYWxOb2RlIiwiZXhwZXJpbWVudGFsX3VzZU9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlIiwiZXhwZXJpbWVudGFsX3VzZU9uRWRnZXNDaGFuZ2VNaWRkbGV3YXJlIiwiTGluZVBhdHRlcm4iLCJsaW5lV2lkdGgiLCJ2YXJpYW50IiwiRG90UGF0dGVybiIsIkJhY2tncm91bmRWYXJpYW50IiwiZGVmYXVsdFNpemUiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsInNlbGVjdG9yJDMiLCJwYXR0ZXJuSWQiLCJCYWNrZ3JvdW5kQ29tcG9uZW50IiwiZ2FwIiwiYmdDb2xvciIsInBhdHRlcm5DbGFzc05hbWUiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJvZmZzZXRYWSIsInBhdHRlcm5EaW1lbnNpb25zIiwic2NhbGVkT2Zmc2V0IiwiX3BhdHRlcm5JZCIsInBhdHRlcm5Vbml0cyIsInBhdHRlcm5UcmFuc2Zvcm0iLCJCYWNrZ3JvdW5kIiwiUGx1c0ljb24iLCJ4bWxucyIsIk1pbnVzSWNvbiIsIkZpdFZpZXdJY29uIiwiTG9ja0ljb24iLCJVbmxvY2tJY29uIiwiQ29udHJvbEJ1dHRvbiIsInNlbGVjdG9yJDIiLCJpc0ludGVyYWN0aXZlIiwibWluWm9vbVJlYWNoZWQiLCJtYXhab29tUmVhY2hlZCIsIkNvbnRyb2xzQ29tcG9uZW50Iiwic2hvd1pvb20iLCJzaG93Rml0VmlldyIsInNob3dJbnRlcmFjdGl2ZSIsIm9uWm9vbUluIiwib25ab29tT3V0Iiwib25GaXRWaWV3Iiwib25JbnRlcmFjdGl2ZUNoYW5nZSIsIm9yaWVudGF0aW9uIiwib25ab29tSW5IYW5kbGVyIiwib25ab29tT3V0SGFuZGxlciIsIm9uRml0Vmlld0hhbmRsZXIiLCJvblRvZ2dsZUludGVyYWN0aXZpdHkiLCJvcmllbnRhdGlvbkNsYXNzIiwidGl0bGUiLCJDb250cm9scyIsIk1pbmlNYXBOb2RlQ29tcG9uZW50Iiwic3Ryb2tlQ29sb3IiLCJzaGFwZVJlbmRlcmluZyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJNaW5pTWFwTm9kZSIsInNlbGVjdG9yTm9kZUlkcyIsImdldEF0dHJGdW5jdGlvbiIsImZ1bmMiLCJGdW5jdGlvbiIsIk1pbmlNYXBOb2RlcyIsIm5vZGVTdHJva2VDb2xvciIsIm5vZGVDb2xvciIsIm5vZGVDbGFzc05hbWUiLCJub2RlQm9yZGVyUmFkaXVzIiwibm9kZVN0cm9rZVdpZHRoIiwibm9kZUNvbXBvbmVudCIsIm5vZGVDb2xvckZ1bmMiLCJub2RlU3Ryb2tlQ29sb3JGdW5jIiwibm9kZUNsYXNzTmFtZUZ1bmMiLCJjaHJvbWUiLCJOb2RlQ29tcG9uZW50V3JhcHBlciIsIk5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIiLCJNaW5pTWFwTm9kZXMkMSIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRIZWlnaHQiLCJmaWx0ZXJIaWRkZW4iLCJzZWxlY3RvciQxIiwidmlld0JCIiwiYm91bmRpbmdSZWN0IiwiZmxvd1dpZHRoIiwiZmxvd0hlaWdodCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcENvbXBvbmVudCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBhbm5hYmxlIiwiem9vbWFibGUiLCJpbnZlcnNlUGFuIiwiem9vbVN0ZXAiLCJvZmZzZXRTY2FsZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJsYWJlbGxlZEJ5Iiwidmlld1NjYWxlUmVmIiwibWluaW1hcEluc3RhbmNlIiwiZ2V0Vmlld1NjYWxlIiwib25TdmdDbGljayIsIm9uU3ZnTm9kZUNsaWNrIiwiX2FyaWFMYWJlbCIsImZpbGxSdWxlIiwiTWluaU1hcCIsInNjYWxlU2VsZWN0b3IiLCJjYWxjdWxhdGVTY2FsZSIsImRlZmF1bHRQb3NpdGlvbnMiLCJMaW5lIiwiUmVzaXplQ29udHJvbCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJtYXhIZWlnaHQiLCJrZWVwQXNwZWN0UmF0aW8iLCJyZXNpemVEaXJlY3Rpb24iLCJhdXRvU2NhbGUiLCJzaG91bGRSZXNpemUiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemUiLCJvblJlc2l6ZUVuZCIsImNvbnRleHROb2RlSWQiLCJyZXNpemVDb250cm9sUmVmIiwiaXNIYW5kbGVDb250cm9sIiwic2NhbGUiLCJyZXNpemVyIiwiY29udHJvbFBvc2l0aW9uIiwicGFuZURvbU5vZGUiLCJjaGlsZENoYW5nZXMiLCJvcmlnaW4iLCJjaGlsZCIsInBvc2l0aW9uQ2hhbmdlIiwiZGltZW5zaW9uQ2hhbmdlIiwiY2hpbGRDaGFuZ2UiLCJib3VuZGFyaWVzIiwicG9zaXRpb25DbGFzc05hbWVzIiwiTm9kZVJlc2l6ZUNvbnRyb2wiLCJOb2RlUmVzaXplciIsImlzVmlzaWJsZSIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZVN0eWxlIiwibGluZUNsYXNzTmFtZSIsImxpbmVTdHlsZSIsIk5vZGVUb29sYmFyUG9ydGFsIiwid3JhcHBlclJlZiIsIm5vZGVFcXVhbGl0eUZuIiwibm9kZXNFcXVhbGl0eUZuIiwic3RvcmVTZWxlY3RvciIsInNlbGVjdGVkTm9kZXNDb3VudCIsIk5vZGVUb29sYmFyIiwiYWxpZ24iLCJpbnRlcm5hbE5vZGVzIiwibm9kZXNBcnJheSIsImFjYyIsInRyaW0iLCJ6b29tU2VsZWN0b3IiLCJFZGdlVG9vbGJhciIsImFsaWduWCIsImFsaWduWSIsImVkZ2VTZWxlY3RvciIsInRyYW5zZm9ybU9yaWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@xyflow/react/dist/style.css":
/*!*****************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@xyflow/react/dist/style.css ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d393e6a432f7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crcmVhY3RAMTIuMTAuMF9AdHlwZXMrcmVhY3RAMTguMy4yN19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHJlcG8vZGV2LWNvbnNvbGUvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crcmVhY3RAMTIuMTAuMF9AdHlwZXMrcmVhY3RAMTguMy4yN19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzPzU4OGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkMzkzZTZhNDMyZjdcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@xyflow+react@12.10.0_@types+react@18.3.27_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@xyflow/react/dist/style.css\n");

/***/ })

};
;