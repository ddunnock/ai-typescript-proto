"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow+system@0.0.74";
exports.ids = ["vendor-chunks/@xyflow+system@0.0.74"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@xyflow+system@0.0.74/node_modules/@xyflow/system/dist/esm/index.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@xyflow+system@0.0.74/node_modules/@xyflow/system/dist/esm/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   defaultAriaLabelConfig: () => (/* binding */ defaultAriaLabelConfig),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgeId: () => (/* binding */ getEdgeId),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getEdgeToolbarTransform: () => (/* binding */ getEdgeToolbarTransform),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isManualZIndexMode: () => (/* binding */ isManualZIndexMode),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   mergeAriaLabelConfig: () => (/* binding */ mergeAriaLabelConfig),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/../../node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/../../node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/zoom.js\");\n\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n    'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n    // Control elements\n    'controls.ariaLabel': 'Control Panel',\n    'controls.zoomIn.ariaLabel': 'Zoom In',\n    'controls.zoomOut.ariaLabel': 'Zoom Out',\n    'controls.fitView.ariaLabel': 'Fit View',\n    'controls.interactive.ariaLabel': 'Toggle Interactivity',\n    // Mini map\n    'minimap.ariaLabel': 'Mini Map',\n    // Handle\n    'handle.ariaLabel': 'Handle',\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n    pointer: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    let hasVisibleNodes = false;\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            box = getBoundsOfBoxes(box, nodeToBox(node));\n            hasVisibleNodes = true;\n        }\n    });\n    return hasVisibleNodes ? boxToRect(box) : { x: 0, y: 0, width: 0, height: 0 };\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate,\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return { ...defaultAriaLabelConfig, ...(partial || {}) };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false, zIndexMode = 'basic', }) {\n    if (zIndexMode === 'manual') {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? zIndex + 1000 : zIndex;\n    const nodeZ = Math.max(sourceNode.parentId || (elevateOnSelect && sourceNode.selected) ? sourceNode.internals.z : 0, targetNode.parentId || (elevateOnSelect && targetNode.selected) ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\n/**\n * The default edge ID generator function. Generates an ID based on the source, target, and handles.\n * @public\n * @param params - The connection or edge to generate an ID for.\n * @returns The generated edge ID.\n */\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @param options - Optional configuration object.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges, options = {}) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const edgeIdGenerator = options.getEdgeId || getEdgeId;\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: edgeIdGenerator(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    const edgeIdGenerator = options.getEdgeId || getEdgeId;\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? edgeIdGenerator(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === 'x') {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? (sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition);\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        }\n        else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? (sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n        stepPosition,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst alignXToPercent = {\n    left: 0,\n    center: 50,\n    right: 100,\n};\nconst alignYToPercent = {\n    top: 0,\n    center: 50,\n    bottom: 100,\n};\nfunction getEdgeToolbarTransform(x, y, zoom, alignX = 'center', alignY = 'center') {\n    return `translate(${x}px, ${y}px) scale(${1 / zoom}) translate(${-(alignXToPercent[alignX] ?? 50)}%, ${-(alignYToPercent[alignY] ?? 50)}%)`;\n}\n\nconst SELECTED_NODE_Z = 1000;\nconst ROOT_PARENT_Z_INCREMENT = 10;\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    zIndexMode: 'basic',\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction parseHandles(userNode, internalNode) {\n    if (!userNode.handles) {\n        return !userNode.measured ? undefined : internalNode?.internals.handleBounds;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of userNode.handles) {\n        const handleBounds = {\n            id: handle.id,\n            width: handle.width ?? 1,\n            height: handle.height ?? 1,\n            nodeId: userNode.id,\n            x: handle.x,\n            y: handle.y,\n            position: handle.position,\n            type: handle.type,\n        };\n        if (handle.type === 'source') {\n            source.push(handleBounds);\n        }\n        else if (handle.type === 'target') {\n            target.push(handleBounds);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction isManualZIndexMode(zIndexMode) {\n    return zIndexMode === 'manual';\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options = {}) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    const rootParentIndex = { i: 0 };\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect && !isManualZIndexMode(_options.zIndexMode) ? SELECTED_NODE_Z : 0;\n    let nodesInitialized = nodes.length > 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: parseHandles(userNode, internalNode),\n                    z: calculateZ(userNode, selectedNodeZ, _options.zIndexMode),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options, rootParentIndex);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options, rootParentIndex) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent, zIndexMode } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    // We just want to set the rootParentIndex for the first child\n    if (rootParentIndex &&\n        !parentNode.parentId &&\n        parentNode.internals.rootParentIndex === undefined &&\n        zIndexMode === 'auto') {\n        parentNode.internals.rootParentIndex = ++rootParentIndex.i;\n        parentNode.internals.z = parentNode.internals.z + rootParentIndex.i * ROOT_PARENT_Z_INCREMENT;\n    }\n    // But we need to update rootParentIndex.i also when parent has not been updated\n    if (rootParentIndex && parentNode.internals.rootParentIndex !== undefined) {\n        rootParentIndex.i = parentNode.internals.rootParentIndex;\n    }\n    const selectedNodeZ = elevateNodesOnSelect && !isManualZIndexMode(zIndexMode) ? SELECTED_NODE_Z : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ, zIndexMode) {\n    const zIndex = isNumeric(node.zIndex) ? node.zIndex : 0;\n    if (isManualZIndexMode(zIndexMode)) {\n        return zIndex;\n    }\n    return zIndex + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ, zIndexMode);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, zIndexMode) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin, zIndexMode });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({ dragItems, snapGrid, x, y, }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y,\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid\n                ? calculateSnapOffset({\n                    dragItems,\n                    snapGrid,\n                    x,\n                    y,\n                })\n                : null;\n            for (const [id, dragItem] of dragItems) {\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */\n                if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset\n                        ? {\n                            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                            y: Math.round(nextPosition.y + multiDragSnapOffset.y),\n                        }\n                        : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            dragEvent = event.sourceEvent;\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                // Calculate distance in client coordinates for consistent drag threshold behavior across zoom levels\n                const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                const x = currentMousePosition.x - mousePosition.x;\n                const y = currentMousePosition.y - mousePosition.y;\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromInternalNode = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromInternalNode, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromInternalNode,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n        pointer: position,\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, { nodeId, handleId, handleType });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const fromInternalNode = nodeLookup.get(nodeId);\n        const from = fromInternalNode\n            ? getHandlePosition(fromInternalNode, fromHandle, Position.Left, true)\n            : previousConnection.from;\n        const newConnection = {\n            ...previousConnection,\n            from,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n            pointer: position,\n        };\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        // Prevent multi-touch aborting connection\n        if ('touches' in event && event.touches.length > 0) {\n            return;\n        }\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            if (event.ctrlKey) {\n                event.preventDefault(); // stop native page zoom for pinch zooming\n            }\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        else {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        const isWheelEvent = event.type === 'wheel';\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // we want to disable pinch-zooming while making a connection\n        if (connectionInProgress && !isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (!isWheelEvent || (panOnScroll && isWheelEvent && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && isWheelEvent) {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || isWheelEvent) && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress, paneClickDistance, selectionOnDrag, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        d3ZoomInstance.clickDistance(selectionOnDrag ? Infinity : !isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance);\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n            connectionInProgress,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    let params = {\n        controlDirection: getControlDirection('bottom-right'),\n        boundaries: {\n            minWidth: 0,\n            minHeight: 0,\n            maxWidth: Number.MAX_VALUE,\n            maxHeight: Number.MAX_VALUE,\n        },\n        resizeDirection: undefined,\n        keepAspectRatio: false,\n    };\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        params = {\n            boundaries,\n            resizeDirection,\n            keepAspectRatio,\n            controlDirection: getControlDirection(controlPosition),\n        };\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        // we only want to trigger onResizeEnd if onResize was actually called\n        let resizeDetected = false;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, params.controlDirection, pointerPosition, params.boundaries, params.keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!params.resizeDirection || params.resizeDirection === 'horizontal')\n                        ? width\n                        : prevValues.width;\n                change.height =\n                    isHeightChange && (!params.resizeDirection || params.resizeDirection === 'vertical')\n                        ? height\n                        : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: params.controlDirection.affectsX,\n                affectsY: params.controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            resizeDetected = true;\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            if (!resizeDetected) {\n                return;\n            }\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n            resizeDetected = false;\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crc3lzdGVtQDAuMC43NC9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2dCO0FBQ2E7QUFDRTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQiw0QkFBNEIsVUFBVSxxQkFBcUIsRUFBRSxPQUFPLEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsOEJBQThCLDJEQUEyRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQixZQUFZLDJCQUEyQjtBQUN2QztBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksMkNBQTJDO0FBQ3ZELFlBQVksNEVBQTRFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFpRDtBQUN0RSxzQkFBc0Isd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9IQUFvSDtBQUMxSSwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtREFBSTtBQUNoQztBQUNBLG9CQUFvQix1RUFBdUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLCtEQUErRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUEyRDtBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQsc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1rRCIsInNvdXJjZXMiOlsid2VicGFjazovL0ByZXBvL2Rldi1jb25zb2xlLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AeHlmbG93K3N5c3RlbUAwLjAuNzQvbm9kZV9tb2R1bGVzL0B4eWZsb3cvc3lzdGVtL2Rpc3QvZXNtL2luZGV4LmpzP2ZjZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgc2VsZWN0LCBwb2ludGVyIH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IHpvb20sIHpvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSB9IGZyb20gJ2QzLXpvb20nO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVab29tLCBpbnRlcnBvbGF0ZSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcblxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBlcnJvcjAwMTogKCkgPT4gJ1tSZWFjdCBGbG93XTogU2VlbXMgbGlrZSB5b3UgaGF2ZSBub3QgdXNlZCB6dXN0YW5kIHByb3ZpZGVyIGFzIGFuIGFuY2VzdG9yLiBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjMDAxJyxcbiAgICBlcnJvcjAwMjogKCkgPT4gXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBjcmVhdGVkIGEgbmV3IG5vZGVUeXBlcyBvciBlZGdlVHlwZXMgb2JqZWN0LiBJZiB0aGlzIHdhc24ndCBvbiBwdXJwb3NlIHBsZWFzZSBkZWZpbmUgdGhlIG5vZGVUeXBlcy9lZGdlVHlwZXMgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50IG9yIG1lbW9pemUgdGhlbS5cIixcbiAgICBlcnJvcjAwMzogKG5vZGVUeXBlKSA9PiBgTm9kZSB0eXBlIFwiJHtub2RlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAwNDogKCkgPT4gJ1RoZSBSZWFjdCBGbG93IHBhcmVudCBjb250YWluZXIgbmVlZHMgYSB3aWR0aCBhbmQgYSBoZWlnaHQgdG8gcmVuZGVyIHRoZSBncmFwaC4nLFxuICAgIGVycm9yMDA1OiAoKSA9PiAnT25seSBjaGlsZCBub2RlcyBjYW4gdXNlIGEgcGFyZW50IGV4dGVudC4nLFxuICAgIGVycm9yMDA2OiAoKSA9PiBcIkNhbid0IGNyZWF0ZSBlZGdlLiBBbiBlZGdlIG5lZWRzIGEgc291cmNlIGFuZCBhIHRhcmdldC5cIixcbiAgICBlcnJvcjAwNzogKGlkKSA9PiBgVGhlIG9sZCBlZGdlIHdpdGggaWQ9JHtpZH0gZG9lcyBub3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwOTogKHR5cGUpID0+IGBNYXJrZXIgdHlwZSBcIiR7dHlwZX1cIiBkb2Vzbid0IGV4aXN0LmAsXG4gICAgZXJyb3IwMDg6IChoYW5kbGVUeXBlLCB7IGlkLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9KSA9PiBgQ291bGRuJ3QgY3JlYXRlIGVkZ2UgZm9yICR7aGFuZGxlVHlwZX0gaGFuZGxlIGlkOiBcIiR7aGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScgPyBzb3VyY2VIYW5kbGUgOiB0YXJnZXRIYW5kbGV9XCIsIGVkZ2UgaWQ6ICR7aWR9LmAsXG4gICAgZXJyb3IwMTA6ICgpID0+ICdIYW5kbGU6IE5vIG5vZGUgaWQgZm91bmQuIE1ha2Ugc3VyZSB0byBvbmx5IHVzZSBhIEhhbmRsZSBpbnNpZGUgYSBjdXN0b20gTm9kZS4nLFxuICAgIGVycm9yMDExOiAoZWRnZVR5cGUpID0+IGBFZGdlIHR5cGUgXCIke2VkZ2VUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDEyOiAoaWQpID0+IGBOb2RlIHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0LCBpdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgbm9kZSBpcyBkZWxldGVkIGJlZm9yZSB0aGUgXCJvbk5vZGVDbGlja1wiIGhhbmRsZXIgaXMgY2FsbGVkLmAsXG4gICAgZXJyb3IwMTM6IChsaWIgPSAncmVhY3QnKSA9PiBgSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZW4ndCBsb2FkZWQgdGhlIHN0eWxlcy4gUGxlYXNlIGltcG9ydCAnQHh5Zmxvdy8ke2xpYn0vZGlzdC9zdHlsZS5jc3MnIG9yIGJhc2UuY3NzIHRvIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHdvcmtpbmcgcHJvcGVybHkuYCxcbiAgICBlcnJvcjAxNDogKCkgPT4gJ3VzZU5vZGVDb25uZWN0aW9uczogTm8gbm9kZSBJRCBmb3VuZC4gQ2FsbCB1c2VOb2RlQ29ubmVjdGlvbnMgaW5zaWRlIGEgY3VzdG9tIE5vZGUgb3IgcHJvdmlkZSBhIG5vZGUgSUQuJyxcbiAgICBlcnJvcjAxNTogKCkgPT4gJ0l0IHNlZW1zIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZHJhZyBhIG5vZGUgdGhhdCBpcyBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSB1c2Ugb25Ob2Rlc0NoYW5nZSBhcyBleHBsYWluZWQgaW4gdGhlIGRvY3MuJyxcbn07XG5jb25zdCBpbmZpbml0ZUV4dGVudCA9IFtcbiAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldLFxuICAgIFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXG5dO1xuY29uc3QgZWxlbWVudFNlbGVjdGlvbktleXMgPSBbJ0VudGVyJywgJyAnLCAnRXNjYXBlJ107XG5jb25zdCBkZWZhdWx0QXJpYUxhYmVsQ29uZmlnID0ge1xuICAgICdub2RlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0JzogJ1ByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhIG5vZGUuIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAnbm9kZS5hMTF5RGVzY3JpcHRpb24ua2V5Ym9hcmREaXNhYmxlZCc6ICdQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLiBZb3UgY2FuIHRoZW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIG5vZGUgYXJvdW5kLiBQcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IGFuZCBlc2NhcGUgdG8gY2FuY2VsLicsXG4gICAgJ25vZGUuYTExeURlc2NyaXB0aW9uLmFyaWFMaXZlTWVzc2FnZSc6ICh7IGRpcmVjdGlvbiwgeCwgeSB9KSA9PiBgTW92ZWQgc2VsZWN0ZWQgbm9kZSAke2RpcmVjdGlvbn0uIE5ldyBwb3NpdGlvbiwgeDogJHt4fSwgeTogJHt5fWAsXG4gICAgJ2VkZ2UuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnOiAnUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGFuIGVkZ2UuIFlvdSBjYW4gdGhlbiBwcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IG9yIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAvLyBDb250cm9sIGVsZW1lbnRzXG4gICAgJ2NvbnRyb2xzLmFyaWFMYWJlbCc6ICdDb250cm9sIFBhbmVsJyxcbiAgICAnY29udHJvbHMuem9vbUluLmFyaWFMYWJlbCc6ICdab29tIEluJyxcbiAgICAnY29udHJvbHMuem9vbU91dC5hcmlhTGFiZWwnOiAnWm9vbSBPdXQnLFxuICAgICdjb250cm9scy5maXRWaWV3LmFyaWFMYWJlbCc6ICdGaXQgVmlldycsXG4gICAgJ2NvbnRyb2xzLmludGVyYWN0aXZlLmFyaWFMYWJlbCc6ICdUb2dnbGUgSW50ZXJhY3Rpdml0eScsXG4gICAgLy8gTWluaSBtYXBcbiAgICAnbWluaW1hcC5hcmlhTGFiZWwnOiAnTWluaSBNYXAnLFxuICAgIC8vIEhhbmRsZVxuICAgICdoYW5kbGUuYXJpYUxhYmVsJzogJ0hhbmRsZScsXG59O1xuXG4vKipcbiAqIFRoZSBgQ29ubmVjdGlvbk1vZGVgIGlzIHVzZWQgdG8gc2V0IHRoZSBtb2RlIG9mIGNvbm5lY3Rpb24gYmV0d2VlbiBub2Rlcy5cbiAqIFRoZSBgU3RyaWN0YCBtb2RlIGlzIHRoZSBkZWZhdWx0IG9uZSBhbmQgb25seSBhbGxvd3Mgc291cmNlIHRvIHRhcmdldCBlZGdlcy5cbiAqIGBMb29zZWAgbW9kZSBhbGxvd3Mgc291cmNlIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IHRvIHRhcmdldCBlZGdlcyBhcyB3ZWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIENvbm5lY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTW9kZSkge1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiU3RyaWN0XCJdID0gXCJzdHJpY3RcIjtcbiAgICBDb25uZWN0aW9uTW9kZVtcIkxvb3NlXCJdID0gXCJsb29zZVwiO1xufSkoQ29ubmVjdGlvbk1vZGUgfHwgKENvbm5lY3Rpb25Nb2RlID0ge30pKTtcbi8qKlxuICogVGhpcyBlbnVtIGlzIHVzZWQgdG8gc2V0IHRoZSBkaWZmZXJlbnQgbW9kZXMgb2YgcGFubmluZyB0aGUgdmlld3BvcnQgd2hlbiB0aGVcbiAqIHVzZXIgc2Nyb2xscy4gVGhlIGBGcmVlYCBtb2RlIGFsbG93cyB0aGUgdXNlciB0byBwYW4gaW4gYW55IGRpcmVjdGlvbiBieSBzY3JvbGxpbmdcbiAqIHdpdGggYSBkZXZpY2UgbGlrZSBhIHRyYWNrcGFkLiBUaGUgYFZlcnRpY2FsYCBhbmQgYEhvcml6b250YWxgIG1vZGVzIHJlc3RyaWN0XG4gKiBzY3JvbGwgcGFubmluZyB0byBvbmx5IHRoZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGF4aXMsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBQYW5PblNjcm9sbE1vZGU7XG4oZnVuY3Rpb24gKFBhbk9uU2Nyb2xsTW9kZSkge1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkZyZWVcIl0gPSBcImZyZWVcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJWZXJ0aWNhbFwiXSA9IFwidmVydGljYWxcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJIb3Jpem9udGFsXCJdID0gXCJob3Jpem9udGFsXCI7XG59KShQYW5PblNjcm9sbE1vZGUgfHwgKFBhbk9uU2Nyb2xsTW9kZSA9IHt9KSk7XG52YXIgU2VsZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uTW9kZSkge1xuICAgIFNlbGVjdGlvbk1vZGVbXCJQYXJ0aWFsXCJdID0gXCJwYXJ0aWFsXCI7XG4gICAgU2VsZWN0aW9uTW9kZVtcIkZ1bGxcIl0gPSBcImZ1bGxcIjtcbn0pKFNlbGVjdGlvbk1vZGUgfHwgKFNlbGVjdGlvbk1vZGUgPSB7fSkpO1xuY29uc3QgaW5pdGlhbENvbm5lY3Rpb24gPSB7XG4gICAgaW5Qcm9ncmVzczogZmFsc2UsXG4gICAgaXNWYWxpZDogbnVsbCxcbiAgICBmcm9tOiBudWxsLFxuICAgIGZyb21IYW5kbGU6IG51bGwsXG4gICAgZnJvbVBvc2l0aW9uOiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvOiBudWxsLFxuICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIHRvUG9zaXRpb246IG51bGwsXG4gICAgdG9Ob2RlOiBudWxsLFxuICAgIHBvaW50ZXI6IG51bGwsXG59O1xuXG4vKipcbiAqIElmIHlvdSBzZXQgdGhlIGBjb25uZWN0aW9uTGluZVR5cGVgIHByb3Agb24geW91ciBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93I2Nvbm5lY3Rpb24tY29ubmVjdGlvbkxpbmVUeXBlKVxuICpjb21wb25lbnQsIGl0IHdpbGwgZGljdGF0ZSB0aGUgc3R5bGUgb2YgY29ubmVjdGlvbiBsaW5lIHJlbmRlcmVkIHdoZW4gY3JlYXRpbmdcbiAqbmV3IGVkZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UgY2hvb3NlIHRvIHJlbmRlciBhIGN1c3RvbSBjb25uZWN0aW9uIGxpbmUgY29tcG9uZW50LCB0aGlzIHZhbHVlIHdpbGwgYmVcbiAqcGFzc2VkIHRvIHlvdXIgY29tcG9uZW50IGFzIHBhcnQgb2YgaXRzIFtgQ29ubmVjdGlvbkxpbmVDb21wb25lbnRQcm9wc2BdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2Nvbm5lY3Rpb24tbGluZS1jb21wb25lbnQtcHJvcHMpLlxuICovXG52YXIgQ29ubmVjdGlvbkxpbmVUeXBlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTGluZVR5cGUpIHtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJCZXppZXJcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdHJhaWdodFwiXSA9IFwic3RyYWlnaHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdGVwXCJdID0gXCJzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU21vb3RoU3RlcFwiXSA9IFwic21vb3Roc3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNpbXBsZUJlemllclwiXSA9IFwic2ltcGxlYmV6aWVyXCI7XG59KShDb25uZWN0aW9uTGluZVR5cGUgfHwgKENvbm5lY3Rpb25MaW5lVHlwZSA9IHt9KSk7XG4vKipcbiAqIEVkZ2VzIG1heSBvcHRpb25hbGx5IGhhdmUgYSBtYXJrZXIgb24gZWl0aGVyIGVuZC4gVGhlIE1hcmtlclR5cGUgdHlwZSBlbnVtZXJhdGVzXG4gKiB0aGUgb3B0aW9ucyBhdmFpbGFibGUgdG8geW91IHdoZW4gY29uZmlndXJpbmcgYSBnaXZlbiBtYXJrZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgTWFya2VyVHlwZTtcbihmdW5jdGlvbiAoTWFya2VyVHlwZSkge1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd1wiXSA9IFwiYXJyb3dcIjtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dDbG9zZWRcIl0gPSBcImFycm93Y2xvc2VkXCI7XG59KShNYXJrZXJUeXBlIHx8IChNYXJrZXJUeXBlID0ge30pKTtcblxuLyoqXG4gKiBXaGlsZSBbYFBhbmVsUG9zaXRpb25gXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9wYW5lbC1wb3NpdGlvbikgY2FuIGJlIHVzZWQgdG8gcGxhY2UgYVxuICogY29tcG9uZW50IGluIHRoZSBjb3JuZXJzIG9mIGEgY29udGFpbmVyLCB0aGUgYFBvc2l0aW9uYCBlbnVtIGlzIGxlc3MgcHJlY2lzZSBhbmQgdXNlZFxuICogcHJpbWFyaWx5IGluIHJlbGF0aW9uIHRvIGVkZ2VzIGFuZCBoYW5kbGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xuICAgIFBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIFBvc2l0aW9uW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgICBQb3NpdGlvbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG5jb25zdCBvcHBvc2l0ZVBvc2l0aW9uID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogUG9zaXRpb24uUmlnaHQsXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogUG9zaXRpb24uTGVmdCxcbiAgICBbUG9zaXRpb24uVG9wXTogUG9zaXRpb24uQm90dG9tLFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiBQb3NpdGlvbi5Ub3AsXG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYSB8fCAhYiB8fCBhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYS5zaXplICYmICFiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXZSBjYWxsIHRoZSBjYWxsYmFjayBmb3IgYWxsIGNvbm5lY3Rpb25zIGluIGEgdGhhdCBhcmUgbm90IGluIGJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShhLCBiLCBjYikge1xuICAgIGlmICghY2IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gW107XG4gICAgYS5mb3JFYWNoKChjb25uZWN0aW9uLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFiPy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlmZi5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRpZmYubGVuZ3RoKSB7XG4gICAgICAgIGNiKGRpZmYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCkge1xuICAgIHJldHVybiBpc1ZhbGlkID09PSBudWxsID8gbnVsbCA6IGlzVmFsaWQgPyAndmFsaWQnIDogJ2ludmFsaWQnO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhIE5vZGVcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIE5vZGVcbiAqL1xuY29uc3QgaXNOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3Bvc2l0aW9uJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbmNvbnN0IGlzSW50ZXJuYWxOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ2ludGVybmFscycgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF90YXJnZXRfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSBzb3VyY2UgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldE91dGdvZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3Qgb3V0Z29lcnMgPSBnZXRPdXRnb2VycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE91dGdvZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG91dGdvZXJJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS5zb3VyY2UgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIG91dGdvZXJJZHMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IG91dGdvZXJJZHMuaGFzKG4uaWQpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF9zb3VyY2VfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldEluY29tZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3QgaW5jb21lcnMgPSBnZXRJbmNvbWVycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldEluY29tZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluY29tZXJzSWRzID0gbmV3IFNldCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UudGFyZ2V0ID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICBpbmNvbWVyc0lkcy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gaW5jb21lcnNJZHMuaGFzKG4uaWQpKTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgY29uc3Qgb2Zmc2V0WCA9IHdpZHRoICogb3JpZ2luWzBdO1xuICAgIGNvbnN0IG9mZnNldFkgPSBoZWlnaHQgKiBvcmlnaW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54IC0gb2Zmc2V0WCxcbiAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55IC0gb2Zmc2V0WSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIHRoZSBnaXZlbiBub2RlcyBpbiBhbiBhcnJheS4gVGhpcyBjYW5cbiAqIGJlIHVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGggW2BnZXRWaWV3cG9ydEZvckJvdW5kc2BdKC9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzKVxuICogdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBVc2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBnZXRWaWV3cG9ydEZvckJvdW5kc30gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBmb3IuXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggZW5jbG9zaW5nIGFsbCBub2Rlcy5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCBgZ2V0UmVjdE9mTm9kZXNgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldE5vZGVzQm91bmRzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7XG4gKiAgICBpZDogJ2EnLFxuICogICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICogICAgZGF0YTogeyBsYWJlbDogJ2EnIH0sXG4gKiAgICB3aWR0aDogNTAsXG4gKiAgICBoZWlnaHQ6IDI1LFxuICogIH0sXG4gKiAge1xuICogICAgaWQ6ICdiJyxcbiAqICAgIHBvc2l0aW9uOiB7IHg6IDEwMCwgeTogMTAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYicgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGJvdW5kcyA9IGdldE5vZGVzQm91bmRzKG5vZGVzKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBwYXJhbXMgPSB7IG5vZGVPcmlnaW46IFswLCAwXSB9KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgYGdldE5vZGVzQm91bmRzYCBmcm9tIGB1c2VSZWFjdEZsb3dgL2B1c2VTdmVsdGVGbG93YCBob29rIHRvIGVuc3VyZSBjb3JyZWN0IHZhbHVlcyBmb3Igc3ViIGZsb3dzLiBJZiBub3QgcG9zc2libGUsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYSBub2RlTG9va3VwIHRvIHN1cHBvcnQgc3ViIGZsb3dzLicpO1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gbm9kZXMucmVkdWNlKChjdXJyQm94LCBub2RlT3JJZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0lkID0gdHlwZW9mIG5vZGVPcklkID09PSAnc3RyaW5nJztcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gIXBhcmFtcy5ub2RlTG9va3VwICYmICFpc0lkID8gbm9kZU9ySWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBpc0lkXG4gICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgOiAhaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGVPcklkKVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZC5pZClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlT3JJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlQm94ID0gY3VycmVudE5vZGUgPyBub2RlVG9Cb3goY3VycmVudE5vZGUsIHBhcmFtcy5ub2RlT3JpZ2luKSA6IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHNPZkJveGVzKGN1cnJCb3gsIG5vZGVCb3gpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vKipcbiAqIERldGVybWluZXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXlcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzID0gKG5vZGVMb29rdXAsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgbGV0IGJveCA9IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG4gICAgbGV0IGhhc1Zpc2libGVOb2RlcyA9IGZhbHNlO1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAocGFyYW1zLmZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5maWx0ZXIobm9kZSkpIHtcbiAgICAgICAgICAgIGJveCA9IGdldEJvdW5kc09mQm94ZXMoYm94LCBub2RlVG9Cb3gobm9kZSkpO1xuICAgICAgICAgICAgaGFzVmlzaWJsZU5vZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoYXNWaXNpYmxlTm9kZXMgPyBib3hUb1JlY3QoYm94KSA6IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xufTtcbmNvbnN0IGdldE5vZGVzSW5zaWRlID0gKG5vZGVzLCByZWN0LCBbdHgsIHR5LCB0U2NhbGVdID0gWzAsIDAsIDFdLCBwYXJ0aWFsbHkgPSBmYWxzZSwgXG4vLyBzZXQgZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyBpZiB5b3Ugd2FudCB0byBwYXkgYXR0ZW50aW9uIHRvIHRoZSBub2RlcyBcInNlbGVjdGFibGVcIiBhdHRyaWJ1dGVcbmV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHBhbmVSZWN0ID0ge1xuICAgICAgICAuLi5wb2ludFRvUmVuZGVyZXJQb2ludChyZWN0LCBbdHgsIHR5LCB0U2NhbGVdKSxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLyB0U2NhbGUsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyB0U2NhbGUsXG4gICAgfTtcbiAgICBjb25zdCB2aXNpYmxlTm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3QgeyBtZWFzdXJlZCwgc2VsZWN0YWJsZSA9IHRydWUsIGhpZGRlbiA9IGZhbHNlIH0gPSBub2RlO1xuICAgICAgICBpZiAoKGV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgJiYgIXNlbGVjdGFibGUpIHx8IGhpZGRlbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkdGggPSBtZWFzdXJlZC53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IG51bGw7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gbnVsbDtcbiAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKHBhbmVSZWN0LCBub2RlVG9SZWN0KG5vZGUpKTtcbiAgICAgICAgY29uc3QgYXJlYSA9ICh3aWR0aCA/PyAwKSAqIChoZWlnaHQgPz8gMCk7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxseVZpc2libGUgPSBwYXJ0aWFsbHkgJiYgb3ZlcmxhcHBpbmdBcmVhID4gMDtcbiAgICAgICAgY29uc3QgZm9yY2VJbml0aWFsUmVuZGVyID0gIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZm9yY2VJbml0aWFsUmVuZGVyIHx8IHBhcnRpYWxseVZpc2libGUgfHwgb3ZlcmxhcHBpbmdBcmVhID49IGFyZWE7XG4gICAgICAgIGlmIChpc1Zpc2libGUgfHwgbm9kZS5kcmFnZ2luZykge1xuICAgICAgICAgICAgdmlzaWJsZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZpc2libGVOb2Rlcztcbn07XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBmaWx0ZXJzIGFuIGFycmF5IG9mIGVkZ2VzLCBrZWVwaW5nIG9ubHkgdGhvc2Ugd2hlcmUgZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0XG4gKiBub2RlIGlzIHByZXNlbnQgaW4gdGhlIGdpdmVuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGVzIC0gTm9kZXMgeW91IHdhbnQgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgZWRnZXMgZm9yLlxuICogQHBhcmFtIGVkZ2VzIC0gQWxsIGVkZ2VzLlxuICogQHJldHVybnMgQXJyYXkgb2YgZWRnZXMgdGhhdCBjb25uZWN0IGFueSBvZiB0aGUgZ2l2ZW4gbm9kZXMgd2l0aCBlYWNoIG90aGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBnZXRDb25uZWN0ZWRFZGdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3Qgbm9kZXMgPSBbXG4gKiAgeyBpZDogJ2EnLCBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0gfSxcbiAqICB7IGlkOiAnYicsIHBvc2l0aW9uOiB7IHg6IDEwMCwgeTogMCB9IH0sXG4gKl07XG4gKlxuICpjb25zdCBlZGdlcyA9IFtcbiAqICB7IGlkOiAnYS0+YycsIHNvdXJjZTogJ2EnLCB0YXJnZXQ6ICdjJyB9LFxuICogIHsgaWQ6ICdjLT5kJywgc291cmNlOiAnYycsIHRhcmdldDogJ2QnIH0sXG4gKl07XG4gKlxuICpjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG5vZGVzLCBlZGdlcyk7XG4gKiAvLyA9PiBbeyBpZDogJ2EtPmMnLCBzb3VyY2U6ICdhJywgdGFyZ2V0OiAnYycgfV1cbiAqYGBgXG4gKi9cbmNvbnN0IGdldENvbm5lY3RlZEVkZ2VzID0gKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KCk7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlSWRzLmFkZChub2RlLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBub2RlSWRzLmhhcyhlZGdlLnNvdXJjZSkgfHwgbm9kZUlkcy5oYXMoZWRnZS50YXJnZXQpKTtcbn07XG5mdW5jdGlvbiBnZXRGaXRWaWV3Tm9kZXMobm9kZUxvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBvcHRpb25Ob2RlSWRzID0gb3B0aW9ucz8ubm9kZXMgPyBuZXcgU2V0KG9wdGlvbnMubm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKSkgOiBudWxsO1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBuLm1lYXN1cmVkLndpZHRoICYmIG4ubWVhc3VyZWQuaGVpZ2h0ICYmIChvcHRpb25zPy5pbmNsdWRlSGlkZGVuTm9kZXMgfHwgIW4uaGlkZGVuKTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiAoIW9wdGlvbk5vZGVJZHMgfHwgb3B0aW9uTm9kZUlkcy5oYXMobi5pZCkpKSB7XG4gICAgICAgICAgICBmaXRWaWV3Tm9kZXMuc2V0KG4uaWQsIG4pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpdFZpZXdOb2Rlcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpdFZpZXdwb3J0KHsgbm9kZXMsIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIG1pblpvb20sIG1heFpvb20gfSwgb3B0aW9ucykge1xuICAgIGlmIChub2Rlcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzVG9GaXQgPSBnZXRGaXRWaWV3Tm9kZXMobm9kZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXNUb0ZpdCk7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnM/Lm1pblpvb20gPz8gbWluWm9vbSwgb3B0aW9ucz8ubWF4Wm9vbSA/PyBtYXhab29tLCBvcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh2aWV3cG9ydCwge1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IG9wdGlvbnM/LmVhc2UsXG4gICAgICAgIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIG5leHQgcG9zaXRpb24gb2YgYSBub2RlLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBub2RlJ3MgZXh0ZW50LCBwYXJlbnQgbm9kZSwgYW5kIG9yaWdpbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7IG5vZGVJZCwgbmV4dFBvc2l0aW9uLCBub2RlTG9va3VwLCBub2RlT3JpZ2luID0gWzAsIDBdLCBub2RlRXh0ZW50LCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50SWQgPyBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIDogeyB4OiAwLCB5OiAwIH07XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICBsZXQgZXh0ZW50ID0gbm9kZS5leHRlbnQgfHwgbm9kZUV4dGVudDtcbiAgICBpZiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnICYmICFub2RlLmV4cGFuZFBhcmVudCkge1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3I/LignMDA1JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDUnXSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFdpZHRoID0gcGFyZW50Tm9kZS5tZWFzdXJlZC53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudE5vZGUubWVhc3VyZWQuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHBhcmVudFdpZHRoICYmIHBhcmVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudE5vZGUgJiYgaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSkge1xuICAgICAgICBleHRlbnQgPSBbXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMF1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFswXVsxXSArIHBhcmVudFldLFxuICAgICAgICAgICAgW25vZGUuZXh0ZW50WzFdWzBdICsgcGFyZW50WCwgbm9kZS5leHRlbnRbMV1bMV0gKyBwYXJlbnRZXSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpXG4gICAgICAgID8gY2xhbXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIGV4dGVudCwgbm9kZS5tZWFzdXJlZClcbiAgICAgICAgOiBuZXh0UG9zaXRpb247XG4gICAgaWYgKG5vZGUubWVhc3VyZWQud2lkdGggPT09IHVuZGVmaW5lZCB8fCBub2RlLm1lYXN1cmVkLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDE1JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTUnXSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uQWJzb2x1dGUueCAtIHBhcmVudFggKyAobm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwKSAqIG9yaWdpblswXSxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uQWJzb2x1dGUueSAtIHBhcmVudFkgKyAobm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCkgKiBvcmlnaW5bMV0sXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgfTtcbn1cbi8qKlxuICogUGFzcyBpbiBub2RlcyAmIGVkZ2VzIHRvIGRlbGV0ZSwgZ2V0IGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMgdGhhdCBhY3R1YWxseSBjYW4gYmUgZGVsZXRlZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXNUb1JlbW92ZSAtIFRoZSBub2RlcyB0byByZW1vdmVcbiAqIEBwYXJhbSBwYXJhbS5lZGdlc1RvUmVtb3ZlIC0gVGhlIGVkZ2VzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLm5vZGVzIC0gQWxsIG5vZGVzXG4gKiBAcGFyYW0gcGFyYW0uZWRnZXMgLSBBbGwgZWRnZXNcbiAqIEBwYXJhbSBwYXJhbS5vbkJlZm9yZURlbGV0ZSAtIENhbGxiYWNrIHRvIGNoZWNrIHdoaWNoIG5vZGVzIGFuZCBlZGdlcyBjYW4gYmUgZGVsZXRlZFxuICogQHJldHVybnMgbm9kZXM6IG5vZGVzIHRoYXQgY2FuIGJlIGRlbGV0ZWQsIGVkZ2VzOiBlZGdlcyB0aGF0IGNhbiBiZSBkZWxldGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEVsZW1lbnRzVG9SZW1vdmUoeyBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzVG9SZW1vdmUgPSBbXSwgbm9kZXMsIGVkZ2VzLCBvbkJlZm9yZURlbGV0ZSwgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmUubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgY29uc3QgbWF0Y2hpbmdOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZS5kZWxldGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gbm9kZUlkcy5oYXMobm9kZS5pZCk7XG4gICAgICAgIGNvbnN0IHBhcmVudEhpdCA9ICFpc0luY2x1ZGVkICYmIG5vZGUucGFyZW50SWQgJiYgbWF0Y2hpbmdOb2Rlcy5maW5kKChuKSA9PiBuLmlkID09PSBub2RlLnBhcmVudElkKTtcbiAgICAgICAgaWYgKGlzSW5jbHVkZWQgfHwgcGFyZW50SGl0KSB7XG4gICAgICAgICAgICBtYXRjaGluZ05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRnZUlkcyA9IG5ldyBTZXQoZWRnZXNUb1JlbW92ZS5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAgICBjb25zdCBkZWxldGFibGVFZGdlcyA9IGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5kZWxldGFibGUgIT09IGZhbHNlKTtcbiAgICBjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG1hdGNoaW5nTm9kZXMsIGRlbGV0YWJsZUVkZ2VzKTtcbiAgICBjb25zdCBtYXRjaGluZ0VkZ2VzID0gY29ubmVjdGVkRWRnZXM7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGRlbGV0YWJsZUVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBlZGdlSWRzLmhhcyhlZGdlLmlkKTtcbiAgICAgICAgaWYgKGlzSW5jbHVkZWQgJiYgIW1hdGNoaW5nRWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gZWRnZS5pZCkpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9uQmVmb3JlRGVsZXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGdlczogbWF0Y2hpbmdFZGdlcyxcbiAgICAgICAgICAgIG5vZGVzOiBtYXRjaGluZ05vZGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9IGF3YWl0IG9uQmVmb3JlRGVsZXRlKHtcbiAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygb25CZWZvcmVEZWxldGVSZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gb25CZWZvcmVEZWxldGVSZXN1bHQgPyB7IGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLCBub2RlczogbWF0Y2hpbmdOb2RlcyB9IDogeyBlZGdlczogW10sIG5vZGVzOiBbXSB9O1xuICAgIH1cbiAgICByZXR1cm4gb25CZWZvcmVEZWxldGVSZXN1bHQ7XG59XG5cbmNvbnN0IGNsYW1wID0gKHZhbCwgbWluID0gMCwgbWF4ID0gMSkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xuY29uc3QgY2xhbXBQb3NpdGlvbiA9IChwb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9LCBleHRlbnQsIGRpbWVuc2lvbnMpID0+ICh7XG4gICAgeDogY2xhbXAocG9zaXRpb24ueCwgZXh0ZW50WzBdWzBdLCBleHRlbnRbMV1bMF0gLSAoZGltZW5zaW9ucz8ud2lkdGggPz8gMCkpLFxuICAgIHk6IGNsYW1wKHBvc2l0aW9uLnksIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzFdIC0gKGRpbWVuc2lvbnM/LmhlaWdodCA/PyAwKSksXG59KTtcbmZ1bmN0aW9uIGNsYW1wUG9zaXRpb25Ub1BhcmVudChjaGlsZFBvc2l0aW9uLCBjaGlsZERpbWVuc2lvbnMsIHBhcmVudCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHBhcmVudFdpZHRoLCBoZWlnaHQ6IHBhcmVudEhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMocGFyZW50KTtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICByZXR1cm4gY2xhbXBQb3NpdGlvbihjaGlsZFBvc2l0aW9uLCBbXG4gICAgICAgIFtwYXJlbnRYLCBwYXJlbnRZXSxcbiAgICAgICAgW3BhcmVudFggKyBwYXJlbnRXaWR0aCwgcGFyZW50WSArIHBhcmVudEhlaWdodF0sXG4gICAgXSwgY2hpbGREaW1lbnNpb25zKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgdmVsb2NpdHkgb2YgcGFubmluZyB3aGVuIHRoZSBtb3VzZSBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB2YWx1ZSAtIE9uZSBkaW1lbnNpb25hbCBwb2l0aW9uIG9mIHRoZSBtb3VzZSAoeCBvciB5KVxuICogQHBhcmFtIG1pbiAtIE1pbmltYWwgcG9zaXRpb24gb24gY2FudmFzIGJlZm9yZSBwYW5uaW5nIHN0YXJ0c1xuICogQHBhcmFtIG1heCAtIE1heGltYWwgcG9zaXRpb24gb24gY2FudmFzIGJlZm9yZSBwYW5uaW5nIHN0YXJ0c1xuICogQHJldHVybnMgLSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgdGhhdCByZXByZXNlbnRzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nXG4gKi9cbmNvbnN0IGNhbGNBdXRvUGFuVmVsb2NpdHkgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1pbiksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHJldHVybiAtY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtYXgpLCAxLCBtaW4pIC8gbWluO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBjYWxjQXV0b1BhbiA9IChwb3MsIGJvdW5kcywgc3BlZWQgPSAxNSwgZGlzdGFuY2UgPSA0MCkgPT4ge1xuICAgIGNvbnN0IHhNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLngsIGRpc3RhbmNlLCBib3VuZHMud2lkdGggLSBkaXN0YW5jZSkgKiBzcGVlZDtcbiAgICBjb25zdCB5TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy55LCBkaXN0YW5jZSwgYm91bmRzLmhlaWdodCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIHJldHVybiBbeE1vdmVtZW50LCB5TW92ZW1lbnRdO1xufTtcbmNvbnN0IGdldEJvdW5kc09mQm94ZXMgPSAoYm94MSwgYm94MikgPT4gKHtcbiAgICB4OiBNYXRoLm1pbihib3gxLngsIGJveDIueCksXG4gICAgeTogTWF0aC5taW4oYm94MS55LCBib3gyLnkpLFxuICAgIHgyOiBNYXRoLm1heChib3gxLngyLCBib3gyLngyKSxcbiAgICB5MjogTWF0aC5tYXgoYm94MS55MiwgYm94Mi55MiksXG59KTtcbmNvbnN0IHJlY3RUb0JveCA9ICh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgeDI6IHggKyB3aWR0aCxcbiAgICB5MjogeSArIGhlaWdodCxcbn0pO1xuY29uc3QgYm94VG9SZWN0ID0gKHsgeCwgeSwgeDIsIHkyIH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgaGVpZ2h0OiB5MiAtIHksXG59KTtcbmNvbnN0IG5vZGVUb1JlY3QgPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGUpXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZVxuICAgICAgICA6IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn07XG5jb25zdCBub2RlVG9Cb3ggPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGUpXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZVxuICAgICAgICA6IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeDI6IHggKyAobm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwKSxcbiAgICAgICAgeTI6IHkgKyAobm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwKSxcbiAgICB9O1xufTtcbmNvbnN0IGdldEJvdW5kc09mUmVjdHMgPSAocmVjdDEsIHJlY3QyKSA9PiBib3hUb1JlY3QoZ2V0Qm91bmRzT2ZCb3hlcyhyZWN0VG9Cb3gocmVjdDEpLCByZWN0VG9Cb3gocmVjdDIpKSk7XG5jb25zdCBnZXRPdmVybGFwcGluZ0FyZWEgPSAocmVjdEEsIHJlY3RCKSA9PiB7XG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS54ICsgcmVjdEEud2lkdGgsIHJlY3RCLnggKyByZWN0Qi53aWR0aCkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS55ICsgcmVjdEEuaGVpZ2h0LCByZWN0Qi55ICsgcmVjdEIuaGVpZ2h0KSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHhPdmVybGFwICogeU92ZXJsYXApO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBpc1JlY3RPYmplY3QgPSAob2JqKSA9PiBpc051bWVyaWMob2JqLndpZHRoKSAmJiBpc051bWVyaWMob2JqLmhlaWdodCkgJiYgaXNOdW1lcmljKG9iai54KSAmJiBpc051bWVyaWMob2JqLnkpO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGlzTnVtZXJpYyA9IChuKSA9PiAhaXNOYU4obikgJiYgaXNGaW5pdGUobik7XG4vLyB1c2VkIGZvciBhMTF5IGtleSBib2FyZCBjb250cm9scyBmb3Igbm9kZXMgYW5kIGVkZ2VzXG5jb25zdCBkZXZXYXJuID0gKGlkLCBtZXNzYWdlKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1JlYWN0IEZsb3ddOiAke21lc3NhZ2V9IEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMke2lkfWApO1xuICAgIH1cbn07XG5jb25zdCBzbmFwUG9zaXRpb24gPSAocG9zaXRpb24sIHNuYXBHcmlkID0gWzEsIDFdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogc25hcEdyaWRbMF0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyBzbmFwR3JpZFswXSksXG4gICAgICAgIHk6IHNuYXBHcmlkWzFdICogTWF0aC5yb3VuZChwb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pLFxuICAgIH07XG59O1xuY29uc3QgcG9pbnRUb1JlbmRlcmVyUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHggLSB0eCkgLyB0U2NhbGUsXG4gICAgICAgIHk6ICh5IC0gdHkpIC8gdFNjYWxlLFxuICAgIH07XG4gICAgcmV0dXJuIHNuYXBUb0dyaWQgPyBzbmFwUG9zaXRpb24ocG9zaXRpb24sIHNuYXBHcmlkKSA6IHBvc2l0aW9uO1xufTtcbmNvbnN0IHJlbmRlcmVyUG9pbnRUb1BvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRTY2FsZSArIHR4LFxuICAgICAgICB5OiB5ICogdFNjYWxlICsgdHksXG4gICAgfTtcbn07XG4vKipcbiAqIFBhcnNlcyBhIHNpbmdsZSBwYWRkaW5nIHZhbHVlIHRvIGEgbnVtYmVyXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyB0byBwYXJzZVxuICogQHBhcmFtIHZpZXdwb3J0IC0gV2lkdGggb3IgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgaW4gcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWRkaW5nLCB2aWV3cG9ydCkge1xuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHZpZXdwb3J0IC0gdmlld3BvcnQgLyAoMSArIHBhZGRpbmcpKSAqIDAuNSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ3N0cmluZycgJiYgcGFkZGluZy5lbmRzV2l0aCgncHgnKSkge1xuICAgICAgICBjb25zdCBwYWRkaW5nVmFsdWUgPSBwYXJzZUZsb2F0KHBhZGRpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYWRkaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwYWRkaW5nVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ3N0cmluZycgJiYgcGFkZGluZy5lbmRzV2l0aCgnJScpKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdWYWx1ZSA9IHBhcnNlRmxvYXQocGFkZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhZGRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZpZXdwb3J0ICogcGFkZGluZ1ZhbHVlICogMC4wMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihgW1JlYWN0IEZsb3ddIFRoZSBwYWRkaW5nIHZhbHVlIFwiJHtwYWRkaW5nfVwiIGlzIGludmFsaWQuIFBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIHdpdGggYSB2YWxpZCB1bml0IChweCBvciAlKS5gKTtcbiAgICByZXR1cm4gMDtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBwYWRkaW5ncyB0byBhbiBvYmplY3Qgd2l0aCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHggYW5kIHkgcGFkZGluZ3NcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgcGFkZGluZ3MgaW4gcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFkZGluZ3MocGFkZGluZywgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdZID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdYID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogcGFkZGluZ1ksXG4gICAgICAgICAgICByaWdodDogcGFkZGluZ1gsXG4gICAgICAgICAgICBib3R0b206IHBhZGRpbmdZLFxuICAgICAgICAgICAgbGVmdDogcGFkZGluZ1gsXG4gICAgICAgICAgICB4OiBwYWRkaW5nWCAqIDIsXG4gICAgICAgICAgICB5OiBwYWRkaW5nWSAqIDIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgdG9wID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcudG9wID8/IHBhZGRpbmcueSA/PyAwLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBib3R0b20gPSBwYXJzZVBhZGRpbmcocGFkZGluZy5ib3R0b20gPz8gcGFkZGluZy55ID8/IDAsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZVBhZGRpbmcocGFkZGluZy5sZWZ0ID8/IHBhZGRpbmcueCA/PyAwLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcucmlnaHQgPz8gcGFkZGluZy54ID8/IDAsIHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB4OiBsZWZ0ICsgcmlnaHQsIHk6IHRvcCArIGJvdHRvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHg6IDAsIHk6IDAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcmVzdWx0aW5nIHBhZGRpbmdzIGlmIHRoZSBuZXcgdmlld3BvcnQgaXMgYXBwbGllZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGZpdCBpbnNpZGUgdmlld3BvcnRcbiAqIEBwYXJhbSB4IC0gWCBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB5IC0gWSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB6b29tIC0gWm9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgdG8gZml0IHRoZSBib3VuZHMgaW5zaWRlIHRoZSB2aWV3cG9ydFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVBcHBsaWVkUGFkZGluZ3MoYm91bmRzLCB4LCB5LCB6b29tLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeyB4OiBsZWZ0LCB5OiB0b3AgfSA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGJvdW5kcywgW3gsIHksIHpvb21dKTtcbiAgICBjb25zdCB7IHg6IGJvdW5kUmlnaHQsIHk6IGJvdW5kQm90dG9tIH0gPSByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IGJvdW5kcy54ICsgYm91bmRzLndpZHRoLCB5OiBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgfSwgW3gsIHksIHpvb21dKTtcbiAgICBjb25zdCByaWdodCA9IHdpZHRoIC0gYm91bmRSaWdodDtcbiAgICBjb25zdCBib3R0b20gPSBoZWlnaHQgLSBib3VuZEJvdHRvbTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLmZsb29yKGxlZnQpLFxuICAgICAgICB0b3A6IE1hdGguZmxvb3IodG9wKSxcbiAgICAgICAgcmlnaHQ6IE1hdGguZmxvb3IocmlnaHQpLFxuICAgICAgICBib3R0b206IE1hdGguZmxvb3IoYm90dG9tKSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmlld3BvcnQgdGhhdCBlbmNsb3NlcyB0aGUgZ2l2ZW4gYm91bmRzIHdpdGggcGFkZGluZy5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFlvdSBjYW4gZGV0ZXJtaW5lIGJvdW5kcyBvZiBub2RlcyB3aXRoIHtAbGluayBnZXROb2Rlc0JvdW5kc30gYW5kIHtAbGluayBnZXRCb3VuZHNPZlJlY3RzfVxuICogQHBhcmFtIGJvdW5kcyAtIEJvdW5kcyB0byBmaXQgaW5zaWRlIHZpZXdwb3J0LlxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIGhlaWdodCAgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIG1pblpvb20gLSBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydC5cbiAqIEBwYXJhbSBtYXhab29tIC0gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSByZXN1bHRpbmcgdmlld3BvcnQuXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgYXJvdW5kIHRoZSBib3VuZHMuXG4gKiBAcmV0dXJucyBBIHRyYW5zZm9ybWVkIHtAbGluayBWaWV3cG9ydH0gdGhhdCBlbmNsb3NlcyB0aGUgZ2l2ZW4gYm91bmRzIHdoaWNoIHlvdSBjYW4gcGFzcyB0byBlLmcuIHtAbGluayBzZXRWaWV3cG9ydH0uXG4gKiBAZXhhbXBsZVxuICogY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhcbiAqIHsgeDogMCwgeTogMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9LFxuICogMTIwMCwgODAwLCAwLjUsIDIpO1xuICovXG5jb25zdCBnZXRWaWV3cG9ydEZvckJvdW5kcyA9IChib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhZGRpbmcpID0+IHtcbiAgICAvLyBGaXJzdCB3ZSByZXNvbHZlIGFsbCB0aGUgcGFkZGluZ3MgdG8gYWN0dWFsIHBpeGVsIHZhbHVlc1xuICAgIGNvbnN0IHAgPSBwYXJzZVBhZGRpbmdzKHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHhab29tID0gKHdpZHRoIC0gcC54KSAvIGJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5Wm9vbSA9IChoZWlnaHQgLSBwLnkpIC8gYm91bmRzLmhlaWdodDtcbiAgICAvLyBXZSBjYWxjdWxhdGUgdGhlIG5ldyB4LCB5LCB6b29tIGZvciBhIGNlbnRlcmVkIHZpZXdcbiAgICBjb25zdCB6b29tID0gTWF0aC5taW4oeFpvb20sIHlab29tKTtcbiAgICBjb25zdCBjbGFtcGVkWm9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclggPSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDI7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWSA9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgeCA9IHdpZHRoIC8gMiAtIGJvdW5kc0NlbnRlclggKiBjbGFtcGVkWm9vbTtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC8gMiAtIGJvdW5kc0NlbnRlclkgKiBjbGFtcGVkWm9vbTtcbiAgICAvLyBUaGVuIHdlIGNhbGN1bGF0ZSB0aGUgbWluaW11bSBwYWRkaW5nLCB0byByZXNwZWN0IGFzeW1tZXRyaWMgcGFkZGluZ3NcbiAgICBjb25zdCBuZXdQYWRkaW5nID0gY2FsY3VsYXRlQXBwbGllZFBhZGRpbmdzKGJvdW5kcywgeCwgeSwgY2xhbXBlZFpvb20sIHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIFdlIG9ubHkgd2FudCB0byBoYXZlIGFuIG9mZnNldCBpZiB0aGUgbmV3UGFkZGluZyBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlcXVpcmVkIHBhZGRpbmdcbiAgICBjb25zdCBvZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgubWluKG5ld1BhZGRpbmcubGVmdCAtIHAubGVmdCwgMCksXG4gICAgICAgIHRvcDogTWF0aC5taW4obmV3UGFkZGluZy50b3AgLSBwLnRvcCwgMCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihuZXdQYWRkaW5nLnJpZ2h0IC0gcC5yaWdodCwgMCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5taW4obmV3UGFkZGluZy5ib3R0b20gLSBwLmJvdHRvbSwgMCksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC0gb2Zmc2V0LmxlZnQgKyBvZmZzZXQucmlnaHQsXG4gICAgICAgIHk6IHkgLSBvZmZzZXQudG9wICsgb2Zmc2V0LmJvdHRvbSxcbiAgICAgICAgem9vbTogY2xhbXBlZFpvb20sXG4gICAgfTtcbn07XG5jb25zdCBpc01hY09zID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluZGV4T2YoJ01hYycpID49IDA7XG5mdW5jdGlvbiBpc0Nvb3JkaW5hdGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGV4dGVudCAhPT0gdW5kZWZpbmVkICYmIGV4dGVudCAhPT0gbnVsbCAmJiBleHRlbnQgIT09ICdwYXJlbnQnO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwLFxuICAgIH07XG59XG5mdW5jdGlvbiBub2RlSGFzRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAobm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCkgIT09IHVuZGVmaW5lZCk7XG59XG4vKipcbiAqIENvbnZlcnQgY2hpbGQgcG9zaXRpb24gdG8gYWJvc2x1dGUgcG9zaXRpb25cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwb3NpdGlvblxuICogQHBhcmFtIHBhcmVudElkXG4gKiBAcGFyYW0gbm9kZUxvb2t1cFxuICogQHBhcmFtIG5vZGVPcmlnaW5cbiAqIEByZXR1cm5zIGFuIGludGVybmFsIG5vZGUgd2l0aCBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24ocG9zaXRpb24sIGRpbWVuc2lvbnMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSwgcGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0geyAuLi5wb3NpdGlvbiB9O1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGVMb29rdXAuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHBhcmVudC5vcmlnaW4gfHwgbm9kZU9yaWdpbjtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS54ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54IC0gKGRpbWVuc2lvbnMud2lkdGggPz8gMCkgKiBvcmlnaW5bMF07XG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUueSArPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSAtIChkaW1lbnNpb25zLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uQWJzb2x1dGU7XG59XG5mdW5jdGlvbiBhcmVTZXRzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUG9seWZpbGwgZm9yIFByb21pc2Uud2l0aFJlc29sdmVycyB1bnRpbCB3ZSBjYW4gdXNlIGl0IGluIGFsbCBicm93c2Vyc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHdpdGhSZXNvbHZlcnMoKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHJlamVjdDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlQXJpYUxhYmVsQ29uZmlnKHBhcnRpYWwpIHtcbiAgICByZXR1cm4geyAuLi5kZWZhdWx0QXJpYUxhYmVsQ29uZmlnLCAuLi4ocGFydGlhbCB8fCB7fSkgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LCB7IHNuYXBHcmlkID0gWzAsIDBdLCBzbmFwVG9HcmlkID0gZmFsc2UsIHRyYW5zZm9ybSwgY29udGFpbmVyQm91bmRzIH0pIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBwb2ludFRvUmVuZGVyZXJQb2ludCh7IHg6IHggLSAoY29udGFpbmVyQm91bmRzPy5sZWZ0ID8/IDApLCB5OiB5IC0gKGNvbnRhaW5lckJvdW5kcz8udG9wID8/IDApIH0sIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgeyB4OiB4U25hcHBlZCwgeTogeVNuYXBwZWQgfSA9IHNuYXBUb0dyaWQgPyBzbmFwUG9zaXRpb24ocG9pbnRlclBvcywgc25hcEdyaWQpIDogcG9pbnRlclBvcztcbiAgICAvLyB3ZSBuZWVkIHRoZSBzbmFwcGVkIHBvc2l0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2tpcCB1bm5lY2Vzc2FyeSBkcmFnIGV2ZW50c1xuICAgIHJldHVybiB7XG4gICAgICAgIHhTbmFwcGVkLFxuICAgICAgICB5U25hcHBlZCxcbiAgICAgICAgLi4ucG9pbnRlclBvcyxcbiAgICB9O1xufVxuY29uc3QgZ2V0RGltZW5zaW9ucyA9IChub2RlKSA9PiAoe1xuICAgIHdpZHRoOiBub2RlLm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogbm9kZS5vZmZzZXRIZWlnaHQsXG59KTtcbmNvbnN0IGdldEhvc3RGb3JFbGVtZW50ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQ/LmdldFJvb3ROb2RlPy4oKSB8fCB3aW5kb3c/LmRvY3VtZW50O1xuY29uc3QgaW5wdXRUYWdzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbmZ1bmN0aW9uIGlzSW5wdXRET01Ob2RlKGV2ZW50KSB7XG4gICAgLy8gdXNpbmcgY29tcG9zZWQgcGF0aCBmb3IgaGFuZGxpbmcgc2hhZG93IGRvbVxuICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Py5ub2RlVHlwZSAhPT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGlzSW5wdXQgPSBpbnB1dFRhZ3MuaW5jbHVkZXModGFyZ2V0Lm5vZGVOYW1lKSB8fCB0YXJnZXQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAvLyB3aGVuIGFuIGlucHV0IGZpZWxkIGlzIGZvY3VzZWQgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGRlbGV0aW9uIG9yIG1vdmVtZW50IG9mIG5vZGVzXG4gICAgcmV0dXJuIGlzSW5wdXQgfHwgISF0YXJnZXQuY2xvc2VzdCgnLm5va2V5Jyk7XG59XG5jb25zdCBpc01vdXNlRXZlbnQgPSAoZXZlbnQpID0+ICdjbGllbnRYJyBpbiBldmVudDtcbmNvbnN0IGdldEV2ZW50UG9zaXRpb24gPSAoZXZlbnQsIGJvdW5kcykgPT4ge1xuICAgIGNvbnN0IGlzTW91c2UgPSBpc01vdXNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGV2dFggPSBpc01vdXNlID8gZXZlbnQuY2xpZW50WCA6IGV2ZW50LnRvdWNoZXM/LlswXS5jbGllbnRYO1xuICAgIGNvbnN0IGV2dFkgPSBpc01vdXNlID8gZXZlbnQuY2xpZW50WSA6IGV2ZW50LnRvdWNoZXM/LlswXS5jbGllbnRZO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2dFggLSAoYm91bmRzPy5sZWZ0ID8/IDApLFxuICAgICAgICB5OiBldnRZIC0gKGJvdW5kcz8udG9wID8/IDApLFxuICAgIH07XG59O1xuLypcbiAqIFRoZSBoYW5kbGUgYm91bmRzIGFyZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIHRoZSBub2RlIGVsZW1lbnQuXG4gKiBXZSBzdG9yZSB0aGVtIGluIHRoZSBpbnRlcm5hbHMgb2JqZWN0IG9mIHRoZSBub2RlIGluIG9yZGVyIHRvIGF2b2lkXG4gKiB1bm5lY2Vzc2FyeSByZWNhbGN1bGF0aW9ucy5cbiAqL1xuY29uc3QgZ2V0SGFuZGxlQm91bmRzID0gKHR5cGUsIG5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlSWQpID0+IHtcbiAgICBjb25zdCBoYW5kbGVzID0gbm9kZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7dHlwZX1gKTtcbiAgICBpZiAoIWhhbmRsZXMgfHwgIWhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShoYW5kbGVzKS5tYXAoKGhhbmRsZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVCb3VuZHMgPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaGFuZGxlLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXBvcycpLFxuICAgICAgICAgICAgeDogKGhhbmRsZUJvdW5kcy5sZWZ0IC0gbm9kZUJvdW5kcy5sZWZ0KSAvIHpvb20sXG4gICAgICAgICAgICB5OiAoaGFuZGxlQm91bmRzLnRvcCAtIG5vZGVCb3VuZHMudG9wKSAvIHpvb20sXG4gICAgICAgICAgICAuLi5nZXREaW1lbnNpb25zKGhhbmRsZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBnZXRCZXppZXJFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZLCB0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFksIH0pIHtcbiAgICAvKlxuICAgICAqIGN1YmljIGJlemllciB0PTAuNSBtaWQgcG9pbnQsIG5vdCB0aGUgYWN0dWFsIG1pZCBwb2ludCwgYnV0IGVhc3kgdG8gY2FsY3VsYXRlXG4gICAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc1MTYxMDEvaG93LXRvLWZpbmQtZGlzdGFuY2UtbWlkLXBvaW50LW9mLWJlemllci1jdXJ2ZVxuICAgICAqL1xuICAgIGNvbnN0IGNlbnRlclggPSBzb3VyY2VYICogMC4xMjUgKyBzb3VyY2VDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFggKiAwLjM3NSArIHRhcmdldFggKiAwLjEyNTtcbiAgICBjb25zdCBjZW50ZXJZID0gc291cmNlWSAqIDAuMTI1ICsgc291cmNlQ29udHJvbFkgKiAwLjM3NSArIHRhcmdldENvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRZICogMC4xMjU7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguYWJzKGNlbnRlclggLSBzb3VyY2VYKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5hYnMoY2VudGVyWSAtIHNvdXJjZVkpO1xuICAgIHJldHVybiBbY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KGRpc3RhbmNlLCBjdXJ2YXR1cmUpIHtcbiAgICBpZiAoZGlzdGFuY2UgPj0gMCkge1xuICAgICAgICByZXR1cm4gMC41ICogZGlzdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2YXR1cmUgKiAyNSAqIE1hdGguc3FydCgtZGlzdGFuY2UpO1xufVxuZnVuY3Rpb24gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoeyBwb3MsIHgxLCB5MSwgeDIsIHkyLCBjIH0pIHtcbiAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MSAtIHgyLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDIgLSB4MSwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTEgLSB5MiwgYyldO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MiAtIHkxLCBjKV07XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgYGdldEJlemllclBhdGhgIHV0aWwgcmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHJlbmRlciBhIGJlemllciBlZGdlXG4gKmJldHdlZW4gdHdvIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAgY29uc3Qgc291cmNlID0geyB4OiAwLCB5OiAyMCB9O1xuICogIGNvbnN0IHRhcmdldCA9IHsgeDogMTUwLCB5OiAxMDAgfTtcbiAqXG4gKiAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllclBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqfSk7XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIChha2EgYSBmaXhlZC1zaXplIGFycmF5KSB0byBtYWtlIGl0IGVhc2llciB0b1xuICp3b3JrIHdpdGggbXVsdGlwbGUgZWRnZSBwYXRocyBhdCBvbmNlLlxuICovXG5mdW5jdGlvbiBnZXRCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjdXJ2YXR1cmUgPSAwLjI1LCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7XG4gICAgICAgIHBvczogc291cmNlUG9zaXRpb24sXG4gICAgICAgIHgxOiBzb3VyY2VYLFxuICAgICAgICB5MTogc291cmNlWSxcbiAgICAgICAgeDI6IHRhcmdldFgsXG4gICAgICAgIHkyOiB0YXJnZXRZLFxuICAgICAgICBjOiBjdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7XG4gICAgICAgIHBvczogdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHgxOiB0YXJnZXRYLFxuICAgICAgICB5MTogdGFyZ2V0WSxcbiAgICAgICAgeDI6IHNvdXJjZVgsXG4gICAgICAgIHkyOiBzb3VyY2VZLFxuICAgICAgICBjOiBjdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cblxuLy8gdGhpcyBpcyB1c2VkIGZvciBzdHJhaWdodCBlZGdlcyBhbmQgc2ltcGxlIHNtb290aHN0ZXAgZWRnZXMgKExUUiwgUlRMLCBCVFQsIFRUQilcbmZ1bmN0aW9uIGdldEVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCB9KSB7XG4gICAgY29uc3QgeE9mZnNldCA9IE1hdGguYWJzKHRhcmdldFggLSBzb3VyY2VYKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWCA9IHRhcmdldFggPCBzb3VyY2VYID8gdGFyZ2V0WCArIHhPZmZzZXQgOiB0YXJnZXRYIC0geE9mZnNldDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WSAtIHNvdXJjZVkpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gdGFyZ2V0WSA8IHNvdXJjZVkgPyB0YXJnZXRZICsgeU9mZnNldCA6IHRhcmdldFkgLSB5T2Zmc2V0O1xuICAgIHJldHVybiBbY2VudGVyWCwgY2VudGVyWSwgeE9mZnNldCwgeU9mZnNldF07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHotaW5kZXggZm9yIGFuIGVkZ2UgYmFzZWQgb24gdGhlIG5vZGUgaXQgY29ubmVjdHMgYW5kIHdoZXRoZXIgaXQgaXMgc2VsZWN0ZWQuXG4gKiBCeSBkZWZhdWx0LCBlZGdlcyBhcmUgcmVuZGVyZWQgYmVsb3cgbm9kZXMuIFRoaXMgYmVoYXZpb3VyIGlzIGRpZmZlcmVudCBmb3IgZWRnZXMgdGhhdCBhcmVcbiAqIGNvbm5lY3RlZCB0byBub2RlcyB3aXRoIGEgcGFyZW50LCBhcyB0aGV5IGFyZSByZW5kZXJlZCBhYm92ZSB0aGUgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldEVsZXZhdGVkRWRnZVpJbmRleCh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHNlbGVjdGVkID0gZmFsc2UsIHpJbmRleCA9IDAsIGVsZXZhdGVPblNlbGVjdCA9IGZhbHNlLCB6SW5kZXhNb2RlID0gJ2Jhc2ljJywgfSkge1xuICAgIGlmICh6SW5kZXhNb2RlID09PSAnbWFudWFsJykge1xuICAgICAgICByZXR1cm4gekluZGV4O1xuICAgIH1cbiAgICBjb25zdCBlZGdlWiA9IGVsZXZhdGVPblNlbGVjdCAmJiBzZWxlY3RlZCA/IHpJbmRleCArIDEwMDAgOiB6SW5kZXg7XG4gICAgY29uc3Qgbm9kZVogPSBNYXRoLm1heChzb3VyY2VOb2RlLnBhcmVudElkIHx8IChlbGV2YXRlT25TZWxlY3QgJiYgc291cmNlTm9kZS5zZWxlY3RlZCkgPyBzb3VyY2VOb2RlLmludGVybmFscy56IDogMCwgdGFyZ2V0Tm9kZS5wYXJlbnRJZCB8fCAoZWxldmF0ZU9uU2VsZWN0ICYmIHRhcmdldE5vZGUuc2VsZWN0ZWQpID8gdGFyZ2V0Tm9kZS5pbnRlcm5hbHMueiA6IDApO1xuICAgIHJldHVybiBlZGdlWiArIG5vZGVaO1xufVxuZnVuY3Rpb24gaXNFZGdlVmlzaWJsZSh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgZWRnZUJveCA9IGdldEJvdW5kc09mQm94ZXMobm9kZVRvQm94KHNvdXJjZU5vZGUpLCBub2RlVG9Cb3godGFyZ2V0Tm9kZSkpO1xuICAgIGlmIChlZGdlQm94LnggPT09IGVkZ2VCb3gueDIpIHtcbiAgICAgICAgZWRnZUJveC54MiArPSAxO1xuICAgIH1cbiAgICBpZiAoZWRnZUJveC55ID09PSBlZGdlQm94LnkyKSB7XG4gICAgICAgIGVkZ2VCb3gueTIgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld1JlY3QgPSB7XG4gICAgICAgIHg6IC10cmFuc2Zvcm1bMF0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC10cmFuc2Zvcm1bMV0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiB3aWR0aCAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyB0cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0T3ZlcmxhcHBpbmdBcmVhKHZpZXdSZWN0LCBib3hUb1JlY3QoZWRnZUJveCkpID4gMDtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZWRnZSBJRCBnZW5lcmF0b3IgZnVuY3Rpb24uIEdlbmVyYXRlcyBhbiBJRCBiYXNlZCBvbiB0aGUgc291cmNlLCB0YXJnZXQsIGFuZCBoYW5kbGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHBhcmFtcyAtIFRoZSBjb25uZWN0aW9uIG9yIGVkZ2UgdG8gZ2VuZXJhdGUgYW4gSUQgZm9yLlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBlZGdlIElELlxuICovXG5jb25zdCBnZXRFZGdlSWQgPSAoeyBzb3VyY2UsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0LCB0YXJnZXRIYW5kbGUgfSkgPT4gYHh5LWVkZ2VfXyR7c291cmNlfSR7c291cmNlSGFuZGxlIHx8ICcnfS0ke3RhcmdldH0ke3RhcmdldEhhbmRsZSB8fCAnJ31gO1xuY29uc3QgY29ubmVjdGlvbkV4aXN0cyA9IChlZGdlLCBlZGdlcykgPT4ge1xuICAgIHJldHVybiBlZGdlcy5zb21lKChlbCkgPT4gZWwuc291cmNlID09PSBlZGdlLnNvdXJjZSAmJlxuICAgICAgICBlbC50YXJnZXQgPT09IGVkZ2UudGFyZ2V0ICYmXG4gICAgICAgIChlbC5zb3VyY2VIYW5kbGUgPT09IGVkZ2Uuc291cmNlSGFuZGxlIHx8ICghZWwuc291cmNlSGFuZGxlICYmICFlZGdlLnNvdXJjZUhhbmRsZSkpICYmXG4gICAgICAgIChlbC50YXJnZXRIYW5kbGUgPT09IGVkZ2UudGFyZ2V0SGFuZGxlIHx8ICghZWwudGFyZ2V0SGFuZGxlICYmICFlZGdlLnRhcmdldEhhbmRsZSkpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBFZGdlIHRvIGFuIGFycmF5IG9mIGVkZ2VzLiBJdCBhbHNvIHBlcmZvcm1zIHNvbWUgdmFsaWRhdGlvbiB0byBtYWtlIHN1cmUgeW91IGRvbid0IGFkZCBhbiBpbnZhbGlkIGVkZ2Ugb3IgZHVwbGljYXRlIGFuIGV4aXN0aW5nIG9uZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBlZGdlUGFyYW1zIC0gRWl0aGVyIGFuIGBFZGdlYCBvciBhIGBDb25uZWN0aW9uYCB5b3Ugd2FudCB0byBhZGQuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMgQSBuZXcgYXJyYXkgb2YgZWRnZXMgd2l0aCB0aGUgbmV3IGVkZ2UgYWRkZWQuXG4gKlxuICogQHJlbWFya3MgSWYgYW4gZWRnZSB3aXRoIHRoZSBzYW1lIGB0YXJnZXRgIGFuZCBgc291cmNlYCBhbHJlYWR5IGV4aXN0cyAoYW5kIHRoZSBzYW1lXG4gKmB0YXJnZXRIYW5kbGVgIGFuZCBgc291cmNlSGFuZGxlYCBpZiB0aG9zZSBhcmUgc2V0KSwgdGhlbiB0aGlzIHV0aWwgd29uJ3QgYWRkXG4gKmEgbmV3IGVkZ2UgZXZlbiBpZiB0aGUgYGlkYCBwcm9wZXJ0eSBpcyBkaWZmZXJlbnQuXG4gKlxuICovXG5jb25zdCBhZGRFZGdlID0gKGVkZ2VQYXJhbXMsIGVkZ2VzLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIWVkZ2VQYXJhbXMuc291cmNlIHx8ICFlZGdlUGFyYW1zLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VJZEdlbmVyYXRvciA9IG9wdGlvbnMuZ2V0RWRnZUlkIHx8IGdldEVkZ2VJZDtcbiAgICBsZXQgZWRnZTtcbiAgICBpZiAoaXNFZGdlQmFzZShlZGdlUGFyYW1zKSkge1xuICAgICAgICBlZGdlID0geyAuLi5lZGdlUGFyYW1zIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGdlID0ge1xuICAgICAgICAgICAgLi4uZWRnZVBhcmFtcyxcbiAgICAgICAgICAgIGlkOiBlZGdlSWRHZW5lcmF0b3IoZWRnZVBhcmFtcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb25uZWN0aW9uRXhpc3RzKGVkZ2UsIGVkZ2VzKSkge1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGlmIChlZGdlLnNvdXJjZUhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgZWRnZS5zb3VyY2VIYW5kbGU7XG4gICAgfVxuICAgIGlmIChlZGdlLnRhcmdldEhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgZWRnZS50YXJnZXRIYW5kbGU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlcy5jb25jYXQoZWRnZSk7XG59O1xuLyoqXG4gKiBBIGhhbmR5IHV0aWxpdHkgdG8gdXBkYXRlIGFuIGV4aXN0aW5nIFtgRWRnZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UpIHdpdGggbmV3IHByb3BlcnRpZXMuXG4gKlRoaXMgc2VhcmNoZXMgeW91ciBlZGdlIGFycmF5IGZvciBhbiBlZGdlIHdpdGggYSBtYXRjaGluZyBgaWRgIGFuZCB1cGRhdGVzIGl0c1xuICpwcm9wZXJ0aWVzIHdpdGggdGhlIGNvbm5lY3Rpb24geW91IHByb3ZpZGUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gb2xkRWRnZSAtIFRoZSBlZGdlIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSBuZXdDb25uZWN0aW9uIC0gVGhlIG5ldyBjb25uZWN0aW9uIHlvdSB3YW50IHRvIHVwZGF0ZSB0aGUgZWRnZSB3aXRoLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBjdXJyZW50IGVkZ2VzLlxuICogQHJldHVybnMgVGhlIHVwZGF0ZWQgZWRnZXMgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmNvbnN0IG9uUmVjb25uZWN0ID0gdXNlQ2FsbGJhY2soXG4gKiAgKG9sZEVkZ2U6IEVkZ2UsIG5ld0Nvbm5lY3Rpb246IENvbm5lY3Rpb24pID0+IHNldEVkZ2VzKChlbHMpID0+IHJlY29ubmVjdEVkZ2Uob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWxzKSksW10pO1xuICpgYGBcbiAqL1xuY29uc3QgcmVjb25uZWN0RWRnZSA9IChvbGRFZGdlLCBuZXdDb25uZWN0aW9uLCBlZGdlcywgb3B0aW9ucyA9IHsgc2hvdWxkUmVwbGFjZUlkOiB0cnVlIH0pID0+IHtcbiAgICBjb25zdCB7IGlkOiBvbGRFZGdlSWQsIC4uLnJlc3QgfSA9IG9sZEVkZ2U7XG4gICAgaWYgKCFuZXdDb25uZWN0aW9uLnNvdXJjZSB8fCAhbmV3Q29ubmVjdGlvbi50YXJnZXQpIHtcbiAgICAgICAgZGV2V2FybignMDA2JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDYnXSgpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBjb25zdCBmb3VuZEVkZ2UgPSBlZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBvbGRFZGdlLmlkKTtcbiAgICBpZiAoIWZvdW5kRWRnZSkge1xuICAgICAgICBkZXZXYXJuKCcwMDcnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNyddKG9sZEVkZ2VJZCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VJZEdlbmVyYXRvciA9IG9wdGlvbnMuZ2V0RWRnZUlkIHx8IGdldEVkZ2VJZDtcbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGVkZ2VJZEdlbmVyYXRvcihuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzdHJhaWdodCBsaW5lIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtgTSAke3NvdXJjZVh9LCR7c291cmNlWX1MICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuY29uc3QgaGFuZGxlRGlyZWN0aW9ucyA9IHtcbiAgICBbUG9zaXRpb24uTGVmdF06IHsgeDogLTEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiB7IHg6IDEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uVG9wXTogeyB4OiAwLCB5OiAtMSB9LFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiB7IHg6IDAsIHk6IDEgfSxcbn07XG5jb25zdCBnZXREaXJlY3Rpb24gPSAoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIH0pID0+IHtcbiAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQgfHwgc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UueCA8IHRhcmdldC54ID8geyB4OiAxLCB5OiAwIH0gOiB7IHg6IC0xLCB5OiAwIH07XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UueSA8IHRhcmdldC55ID8geyB4OiAwLCB5OiAxIH0gOiB7IHg6IDAsIHk6IC0xIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KE1hdGgucG93KGIueCAtIGEueCwgMikgKyBNYXRoLnBvdyhiLnkgLSBhLnksIDIpKTtcbi8qXG4gKiBXaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGFuIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nIGJlaGF2aW91clxuICogSXQncyBub3QgYXMgZ29vZCBhcyBhIHJlYWwgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcsIGJ1dCBpdCdzIGZhc3RlciBhbmQgZ29vZCBlbm91Z2ggYXMgYSBkZWZhdWx0IGZvciBzdGVwIGFuZCBzbW9vdGggc3RlcCBlZGdlc1xuICovXG5mdW5jdGlvbiBnZXRQb2ludHMoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjZW50ZXIsIG9mZnNldCwgc3RlcFBvc2l0aW9uLCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbLCAsIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbCwgc28gc3RlcFBvc2l0aW9uIGFmZmVjdHMgWCBjb29yZGluYXRlXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgKHRhcmdldEdhcHBlZC54IC0gc291cmNlR2FwcGVkLngpICogc3RlcFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyB0YXJnZXRHYXBwZWQueSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgdmVydGljYWwsIHNvIHN0ZXBQb3NpdGlvbiBhZmZlY3RzIFkgY29vcmRpbmF0ZSAgXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgdGFyZ2V0R2FwcGVkLngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyAodGFyZ2V0R2FwcGVkLnkgLSBzb3VyY2VHYXBwZWQueSkgKiBzdGVwUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIC0tLT5cbiAgICAgICAgICogICAgfFxuICAgICAgICAgKiA+LS0tXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiBzb3VyY2VHYXBwZWQueSB9LFxuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiB0YXJnZXRHYXBwZWQueSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqICAtLS1cbiAgICAgICAgICogIHxcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogc291cmNlR2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyB2ZXJ0aWNhbFNwbGl0IDogaG9yaXpvbnRhbFNwbGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IGhvcml6b250YWxTcGxpdCA6IHZlcnRpY2FsU3BsaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNvdXJjZVRhcmdldCBtZWFucyB3ZSB0YWtlIHggZnJvbSBzb3VyY2UgYW5kIHkgZnJvbSB0YXJnZXQsIHRhcmdldFNvdXJjZSBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgY29uc3Qgc291cmNlVGFyZ2V0ID0gW3sgeDogc291cmNlR2FwcGVkLngsIHk6IHRhcmdldEdhcHBlZC55IH1dO1xuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBbeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogc291cmNlR2FwcGVkLnkgfV07XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlcyBlZGdlcyB3aXRoIHNhbWUgaGFuZGxlIHBvc2l0aW9uc1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnggPT09IGN1cnJEaXIgPyB0YXJnZXRTb3VyY2UgOiBzb3VyY2VUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueSA9PT0gY3VyckRpciA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoc291cmNlW2RpckFjY2Vzc29yXSAtIHRhcmdldFtkaXJBY2Nlc3Nvcl0pO1xuICAgICAgICAgICAgLy8gaWYgYW4gZWRnZSBnb2VzIGZyb20gcmlnaHQgdG8gcmlnaHQgZm9yIGV4YW1wbGUgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikgYW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZS54IGFuZCB0YXJnZXQueCBpcyBsZXNzIHRoYW4gdGhlIG9mZnNldCwgdGhlIGFkZGVkIHBvaW50IGFuZCB0aGUgZ2FwcGVkIHNvdXJjZS90YXJnZXQgd2lsbCBvdmVybGFwLiBUaGlzIGxlYWRzIHRvIGEgd2VpcmQgZWRnZSBwYXRoLiBUbyBhdm9pZCB0aGlzIHdlIGFkZCBhIGdhcE9mZnNldCB0byB0aGUgc291cmNlL3RhcmdldFxuICAgICAgICAgICAgaWYgKGRpZmYgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwT2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0IC0gMSwgb2Zmc2V0IC0gZGlmZik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlR2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9IChzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JdID4gc291cmNlW2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiB0YXJnZXRbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgYXJlIGNvbmRpdGlvbnMgZm9yIGhhbmRsaW5nIG1peGVkIGhhbmRsZSBwb3NpdGlvbnMgbGlrZSBSaWdodCAtPiBCb3R0b20gZm9yIGV4YW1wbGVcbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uICE9PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlyQWNjZXNzb3JPcHBvc2l0ZSA9IGRpckFjY2Vzc29yID09PSAneCcgPyAneScgOiAneCc7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWVEaXIgPSBzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSB0YXJnZXREaXJbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VHdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPiB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPCB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBmbGlwU291cmNlVGFyZ2V0ID0gKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pKSkgfHxcbiAgICAgICAgICAgICAgICAoc291cmNlRGlyW2RpckFjY2Vzc29yXSAhPT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykpKTtcbiAgICAgICAgICAgIGlmIChmbGlwU291cmNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VHYXBQb2ludCA9IHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCB0YXJnZXRHYXBQb2ludCA9IHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCBtYXhYRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpKTtcbiAgICAgICAgY29uc3QgbWF4WURpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueSAtIHBvaW50c1swXS55KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueSAtIHBvaW50c1swXS55KSk7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcGxhY2UgdGhlIGxhYmVsIG9uIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG1heFhEaXN0YW5jZSA+PSBtYXhZRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNlbnRlclggPSAoc291cmNlR2FwUG9pbnQueCArIHRhcmdldEdhcFBvaW50LngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBwb2ludHNbMF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbnRlclggPSBwb2ludHNbMF0ueDtcbiAgICAgICAgICAgIGNlbnRlclkgPSAoc291cmNlR2FwUG9pbnQueSArIHRhcmdldEdhcFBvaW50LnkpIC8gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXRoUG9pbnRzID0gW1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9LFxuICAgICAgICAuLi5wb2ludHMsXG4gICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9LFxuICAgICAgICB0YXJnZXQsXG4gICAgXTtcbiAgICByZXR1cm4gW3BhdGhQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV07XG59XG5mdW5jdGlvbiBnZXRCZW5kKGEsIGIsIGMsIHNpemUpIHtcbiAgICBjb25zdCBiZW5kU2l6ZSA9IE1hdGgubWluKGRpc3RhbmNlKGEsIGIpIC8gMiwgZGlzdGFuY2UoYiwgYykgLyAyLCBzaXplKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGI7XG4gICAgLy8gbm8gYmVuZFxuICAgIGlmICgoYS54ID09PSB4ICYmIHggPT09IGMueCkgfHwgKGEueSA9PT0geSAmJiB5ID09PSBjLnkpKSB7XG4gICAgICAgIHJldHVybiBgTCR7eH0gJHt5fWA7XG4gICAgfVxuICAgIC8vIGZpcnN0IHNlZ21lbnQgaXMgaG9yaXpvbnRhbFxuICAgIGlmIChhLnkgPT09IHkpIHtcbiAgICAgICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIGBMICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fVEgJHt4fSwke3l9ICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfWA7XG4gICAgfVxuICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAxIDogLTE7XG4gICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IC0xIDogMTtcbiAgICByZXR1cm4gYEwgJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9USAke3h9LCR7eX0gJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9YDtcbn1cbi8qKlxuICogVGhlIGBnZXRTbW9vdGhTdGVwUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc3RlcHBlZCBwYXRoXG4gKiBiZXR3ZWVuIHR3byBub2Rlcy4gVGhlIGBib3JkZXJSYWRpdXNgIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGNob29zZSBob3cgcm91bmRlZFxuICogdGhlIGNvcm5lcnMgb2YgdGhvc2Ugc3RlcHMgYXJlLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICogIH0pO1xuICogYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoU3RlcFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGJvcmRlclJhZGl1cyA9IDUsIGNlbnRlclgsIGNlbnRlclksIG9mZnNldCA9IDIwLCBzdGVwUG9zaXRpb24gPSAwLjUsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgc3RlcFBvc2l0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvKlxuICAgICAqIHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3BcbiAgICAgKiB3ZSBzZXQgdGhlIHggYW55IHkgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgYmFzZWQgb24gdGhlIG5vZGVzIHBvc2l0aW9uXG4gICAgICovXG4gICAgbGV0IHBvcyA9IFtcbiAgICAgICAgKG5vZGVSZWN0LnggKyBub2RlUmVjdC53aWR0aCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCxcbiAgICAgICAgbm9kZVJlY3QueSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55IC0gb2Zmc2V0LFxuICAgIF07XG4gICAgLy8gYW5kIHRoYW4gc2hpZnQgaXQgYmFzZWQgb24gdGhlIGFsaWdubWVudC4gVGhlIHNoaWZ0IHZhbHVlcyBhcmUgaW4gJS5cbiAgICBsZXQgc2hpZnQgPSBbLTEwMCAqIGFsaWdubWVudE9mZnNldCwgLTEwMF07XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGgpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQgKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc2hpZnQgPSBbMCwgLTEwMCAqIGFsaWdubWVudE9mZnNldF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICBwb3NbMV0gPSAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSArIG9mZnNldDtcbiAgICAgICAgICAgIHNoaWZ0WzFdID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbm9kZVJlY3QueCAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54IC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWy0xMDAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgdHJhbnNsYXRlKCR7c2hpZnRbMF19JSwgJHtzaGlmdFsxXX0lKWA7XG59XG5cbmNvbnN0IGFsaWduWFRvUGVyY2VudCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIGNlbnRlcjogNTAsXG4gICAgcmlnaHQ6IDEwMCxcbn07XG5jb25zdCBhbGlnbllUb1BlcmNlbnQgPSB7XG4gICAgdG9wOiAwLFxuICAgIGNlbnRlcjogNTAsXG4gICAgYm90dG9tOiAxMDAsXG59O1xuZnVuY3Rpb24gZ2V0RWRnZVRvb2xiYXJUcmFuc2Zvcm0oeCwgeSwgem9vbSwgYWxpZ25YID0gJ2NlbnRlcicsIGFsaWduWSA9ICdjZW50ZXInKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpIHNjYWxlKCR7MSAvIHpvb219KSB0cmFuc2xhdGUoJHstKGFsaWduWFRvUGVyY2VudFthbGlnblhdID8/IDUwKX0lLCAkey0oYWxpZ25ZVG9QZXJjZW50W2FsaWduWV0gPz8gNTApfSUpYDtcbn1cblxuY29uc3QgU0VMRUNURURfTk9ERV9aID0gMTAwMDtcbmNvbnN0IFJPT1RfUEFSRU5UX1pfSU5DUkVNRU5UID0gMTA7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgekluZGV4TW9kZTogJ2Jhc2ljJyxcbiAgICBkZWZhdWx0czoge30sXG59O1xuY29uc3QgYWRvcHRVc2VyTm9kZXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICBjaGVja0VxdWFsaXR5OiB0cnVlLFxufTtcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhiYXNlLCBpbmNvbWluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluY29taW5nKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHR5cGVjYXN0IGlzIHNhZmUgaGVyZSwgYmVjYXVzZSB3ZSBjaGVjayBmb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGluY29taW5nW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxvb2t1cC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyhub2RlKSk7XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gY2xhbXBlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VIYW5kbGVzKHVzZXJOb2RlLCBpbnRlcm5hbE5vZGUpIHtcbiAgICBpZiAoIXVzZXJOb2RlLmhhbmRsZXMpIHtcbiAgICAgICAgcmV0dXJuICF1c2VyTm9kZS5tZWFzdXJlZCA/IHVuZGVmaW5lZCA6IGludGVybmFsTm9kZT8uaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gW107XG4gICAgY29uc3QgdGFyZ2V0ID0gW107XG4gICAgZm9yIChjb25zdCBoYW5kbGUgb2YgdXNlck5vZGUuaGFuZGxlcykge1xuICAgICAgICBjb25zdCBoYW5kbGVCb3VuZHMgPSB7XG4gICAgICAgICAgICBpZDogaGFuZGxlLmlkLFxuICAgICAgICAgICAgd2lkdGg6IGhhbmRsZS53aWR0aCA/PyAxLFxuICAgICAgICAgICAgaGVpZ2h0OiBoYW5kbGUuaGVpZ2h0ID8/IDEsXG4gICAgICAgICAgICBub2RlSWQ6IHVzZXJOb2RlLmlkLFxuICAgICAgICAgICAgeDogaGFuZGxlLngsXG4gICAgICAgICAgICB5OiBoYW5kbGUueSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUucG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlOiBoYW5kbGUudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhbmRsZS50eXBlID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgc291cmNlLnB1c2goaGFuZGxlQm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGUudHlwZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGhhbmRsZUJvdW5kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzTWFudWFsWkluZGV4TW9kZSh6SW5kZXhNb2RlKSB7XG4gICAgcmV0dXJuIHpJbmRleE1vZGUgPT09ICdtYW51YWwnO1xufVxuZnVuY3Rpb24gYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgX29wdGlvbnMgPSBtZXJnZU9iamVjdHMoYWRvcHRVc2VyTm9kZXNEZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3Qgcm9vdFBhcmVudEluZGV4ID0geyBpOiAwIH07XG4gICAgY29uc3QgdG1wTG9va3VwID0gbmV3IE1hcChub2RlTG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gX29wdGlvbnM/LmVsZXZhdGVOb2Rlc09uU2VsZWN0ICYmICFpc01hbnVhbFpJbmRleE1vZGUoX29wdGlvbnMuekluZGV4TW9kZSkgPyBTRUxFQ1RFRF9OT0RFX1ogOiAwO1xuICAgIGxldCBub2Rlc0luaXRpYWxpemVkID0gbm9kZXMubGVuZ3RoID4gMDtcbiAgICBub2RlTG9va3VwLmNsZWFyKCk7XG4gICAgcGFyZW50TG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB1c2VyTm9kZSBvZiBub2Rlcykge1xuICAgICAgICBsZXQgaW50ZXJuYWxOb2RlID0gdG1wTG9va3VwLmdldCh1c2VyTm9kZS5pZCk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5jaGVja0VxdWFsaXR5ICYmIHVzZXJOb2RlID09PSBpbnRlcm5hbE5vZGU/LmludGVybmFscy51c2VyTm9kZSkge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHVzZXJOb2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudCh1c2VyTm9kZS5leHRlbnQpID8gdXNlck5vZGUuZXh0ZW50IDogX29wdGlvbnMubm9kZUV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBleHRlbnQsIGdldE5vZGVEaW1lbnNpb25zKHVzZXJOb2RlKSk7XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX29wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4udXNlck5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHVzZXJOb2RlLm1lYXN1cmVkPy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB1c2VyTm9kZS5tZWFzdXJlZD8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGNsYW1wZWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlciByZS1pbml0aWFsaXplcyB0aGUgbm9kZSBvciByZW1vdmVzIGBtZWFzdXJlZGAgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgcmVzZXQgdGhlIGhhbmRsZUJvdW5kcyBzbyB0aGF0IHRoZSBub2RlIGdldHMgcmUtbWVhc3VyZWRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiBwYXJzZUhhbmRsZXModXNlck5vZGUsIGludGVybmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgIHo6IGNhbGN1bGF0ZVoodXNlck5vZGUsIHNlbGVjdGVkTm9kZVosIF9vcHRpb25zLnpJbmRleE1vZGUpLFxuICAgICAgICAgICAgICAgICAgICB1c2VyTm9kZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaW50ZXJuYWxOb2RlLm1lYXN1cmVkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxOb2RlLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyTm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKGludGVybmFsTm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zLCByb290UGFyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlc0luaXRpYWxpemVkO1xufVxuZnVuY3Rpb24gdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwYXJlbnRMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50TG9va3VwLnNldChub2RlLnBhcmVudElkLCBuZXcgTWFwKFtbbm9kZS5pZCwgbm9kZV1dKSk7XG4gICAgfVxufVxuLyoqXG4gKiBVcGRhdGVzIHBvc2l0aW9uQWJzb2x1dGUgYW5kIHpJbmRleCBvZiBhIGNoaWxkIG5vZGUgYW5kIHRoZSBwYXJlbnRMb29rdXAuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMsIHJvb3RQYXJlbnRJbmRleCkge1xuICAgIGNvbnN0IHsgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUgfSA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFyZW50IG5vZGUgJHtwYXJlbnRJZH0gbm90IGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgcGFyZW50IG5vZGVzIGFyZSBpbiBmcm9udCBvZiB0aGVpciBjaGlsZCBub2RlcyBpbiB0aGUgbm9kZXMgYXJyYXkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCk7XG4gICAgLy8gV2UganVzdCB3YW50IHRvIHNldCB0aGUgcm9vdFBhcmVudEluZGV4IGZvciB0aGUgZmlyc3QgY2hpbGRcbiAgICBpZiAocm9vdFBhcmVudEluZGV4ICYmXG4gICAgICAgICFwYXJlbnROb2RlLnBhcmVudElkICYmXG4gICAgICAgIHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHpJbmRleE1vZGUgPT09ICdhdXRvJykge1xuICAgICAgICBwYXJlbnROb2RlLmludGVybmFscy5yb290UGFyZW50SW5kZXggPSArK3Jvb3RQYXJlbnRJbmRleC5pO1xuICAgICAgICBwYXJlbnROb2RlLmludGVybmFscy56ID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMueiArIHJvb3RQYXJlbnRJbmRleC5pICogUk9PVF9QQVJFTlRfWl9JTkNSRU1FTlQ7XG4gICAgfVxuICAgIC8vIEJ1dCB3ZSBuZWVkIHRvIHVwZGF0ZSByb290UGFyZW50SW5kZXguaSBhbHNvIHdoZW4gcGFyZW50IGhhcyBub3QgYmVlbiB1cGRhdGVkXG4gICAgaWYgKHJvb3RQYXJlbnRJbmRleCAmJiBwYXJlbnROb2RlLmludGVybmFscy5yb290UGFyZW50SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByb290UGFyZW50SW5kZXguaSA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlWiA9IGVsZXZhdGVOb2Rlc09uU2VsZWN0ICYmICFpc01hbnVhbFpJbmRleE1vZGUoekluZGV4TW9kZSkgPyBTRUxFQ1RFRF9OT0RFX1ogOiAwO1xuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gY2FsY3VsYXRlQ2hpbGRYWVoobm9kZSwgcGFyZW50Tm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgc2VsZWN0ZWROb2RlWiwgekluZGV4TW9kZSk7XG4gICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBub2RlLmludGVybmFscztcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB4ICE9PSBwb3NpdGlvbkFic29sdXRlLnggfHwgeSAhPT0gcG9zaXRpb25BYnNvbHV0ZS55O1xuICAgIGlmIChwb3NpdGlvbkNoYW5nZWQgfHwgeiAhPT0gbm9kZS5pbnRlcm5hbHMueikge1xuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIG1hcmsgdGhlIG5vZGUgYXMgdXBkYXRlZFxuICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogcG9zaXRpb25DaGFuZ2VkID8geyB4LCB5IH0gOiBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgIHosXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVaKG5vZGUsIHNlbGVjdGVkTm9kZVosIHpJbmRleE1vZGUpIHtcbiAgICBjb25zdCB6SW5kZXggPSBpc051bWVyaWMobm9kZS56SW5kZXgpID8gbm9kZS56SW5kZXggOiAwO1xuICAgIGlmIChpc01hbnVhbFpJbmRleE1vZGUoekluZGV4TW9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHpJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHpJbmRleCArIChub2RlLnNlbGVjdGVkID8gc2VsZWN0ZWROb2RlWiA6IDApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hpbGRYWVooY2hpbGROb2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaLCB6SW5kZXhNb2RlKSB7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIGNvbnN0IGNoaWxkRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKGNoaWxkTm9kZSk7XG4gICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihjaGlsZE5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGlzQ29vcmRpbmF0ZUV4dGVudChjaGlsZE5vZGUuZXh0ZW50KVxuICAgICAgICA/IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBjaGlsZE5vZGUuZXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpXG4gICAgICAgIDogcG9zaXRpb25XaXRoT3JpZ2luO1xuICAgIGxldCBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbih7IHg6IHBhcmVudFggKyBjbGFtcGVkUG9zaXRpb24ueCwgeTogcGFyZW50WSArIGNsYW1wZWRQb3NpdGlvbi55IH0sIG5vZGVFeHRlbnQsIGNoaWxkRGltZW5zaW9ucyk7XG4gICAgaWYgKGNoaWxkTm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoYWJzb2x1dGVQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnROb2RlKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRaID0gY2FsY3VsYXRlWihjaGlsZE5vZGUsIHNlbGVjdGVkTm9kZVosIHpJbmRleE1vZGUpO1xuICAgIGNvbnN0IHBhcmVudFogPSBwYXJlbnROb2RlLmludGVybmFscy56ID8/IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYWJzb2x1dGVQb3NpdGlvbi54LFxuICAgICAgICB5OiBhYnNvbHV0ZVBvc2l0aW9uLnksXG4gICAgICAgIHo6IHBhcmVudFogPj0gY2hpbGRaID8gcGFyZW50WiArIDEgOiBjaGlsZFosXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUV4cGFuZFBhcmVudChjaGlsZHJlbiwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luID0gWzAsIDBdKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHBhcmVudEV4cGFuc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBleHBhbmRlZCByZWN0YW5nbGUgdGhlIGNoaWxkIG5vZGVzIHdvdWxkIHRha2UgZm9yIGVhY2ggcGFyZW50XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlTG9va3VwLmdldChjaGlsZC5wYXJlbnRJZCk7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50RXhwYW5zaW9ucy5nZXQoY2hpbGQucGFyZW50SWQpPy5leHBhbmRlZFJlY3QgPz8gbm9kZVRvUmVjdChwYXJlbnQpO1xuICAgICAgICBjb25zdCBleHBhbmRlZFJlY3QgPSBnZXRCb3VuZHNPZlJlY3RzKHBhcmVudFJlY3QsIGNoaWxkLnJlY3QpO1xuICAgICAgICBwYXJlbnRFeHBhbnNpb25zLnNldChjaGlsZC5wYXJlbnRJZCwgeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmVudEV4cGFuc2lvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5mb3JFYWNoKCh7IGV4cGFuZGVkUmVjdCwgcGFyZW50IH0sIHBhcmVudElkKSA9PiB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHBvc2l0aW9uICYgZGltZW5zaW9ucyBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBwYXJlbnQub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaG93IG11Y2ggdGhlIHBhcmVudCBleHBhbmRzIGluIHdpZHRoIGFuZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgeENoYW5nZSA9IGV4cGFuZGVkUmVjdC54IDwgcG9zaXRpb25BYnNvbHV0ZS54ID8gTWF0aC5yb3VuZChNYXRoLmFicyhwb3NpdGlvbkFic29sdXRlLnggLSBleHBhbmRlZFJlY3QueCkpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IHlDaGFuZ2UgPSBleHBhbmRlZFJlY3QueSA8IHBvc2l0aW9uQWJzb2x1dGUueSA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS55IC0gZXhwYW5kZWRSZWN0LnkpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KGRpbWVuc2lvbnMud2lkdGgsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LndpZHRoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heChkaW1lbnNpb25zLmhlaWdodCwgTWF0aC5yb3VuZChleHBhbmRlZFJlY3QuaGVpZ2h0KSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aENoYW5nZSA9IChuZXdXaWR0aCAtIGRpbWVuc2lvbnMud2lkdGgpICogb3JpZ2luWzBdO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0Q2hhbmdlID0gKG5ld0hlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0KSAqIG9yaWdpblsxXTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIHBhcmVudCBub2RlIGlmIHRoZSBvcmlnaW4gaXMgbm90IFswLDBdXG4gICAgICAgICAgICBpZiAoeENoYW5nZSA+IDAgfHwgeUNoYW5nZSA+IDAgfHwgd2lkdGhDaGFuZ2UgfHwgaGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcGFyZW50LnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgd2lkdGhDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwYXJlbnQucG9zaXRpb24ueSAtIHlDaGFuZ2UgKyBoZWlnaHRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBXZSBtb3ZlIGFsbCBjaGlsZCBub2RlcyBpbiB0aGUgb3Bwc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBzbyB0aGUgeCx5IGNoYW5nZXMgb2YgdGhlIHBhcmVudCBkbyBub3QgbW92ZSB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwYXJlbnRMb29rdXAuZ2V0KHBhcmVudElkKT8uZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4uc29tZSgoY2hpbGQpID0+IGNoaWxkLmlkID09PSBjaGlsZE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZE5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGlsZE5vZGUucG9zaXRpb24ueCArIHhDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoaWxkTm9kZS5wb3NpdGlvbi55ICsgeUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcGFyZW50IG5vZGUgaWYgdGhlIG9yaWdpbiBpcyBub3QgWzAsMF1cbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgZXhwYW5kZWRSZWN0LndpZHRoIHx8IGRpbWVuc2lvbnMuaGVpZ2h0IDwgZXhwYW5kZWRSZWN0LmhlaWdodCB8fCB4Q2hhbmdlIHx8IHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoICsgKHhDaGFuZ2UgPyBvcmlnaW5bMF0gKiB4Q2hhbmdlIC0gd2lkdGhDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0ICsgKHlDaGFuZ2UgPyBvcmlnaW5bMV0gKiB5Q2hhbmdlIC0gaGVpZ2h0Q2hhbmdlIDogMCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB6SW5kZXhNb2RlKSB7XG4gICAgY29uc3Qgdmlld3BvcnROb2RlID0gZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnh5Zmxvd19fdmlld3BvcnQnKTtcbiAgICBsZXQgdXBkYXRlZEludGVybmFscyA9IGZhbHNlO1xuICAgIGlmICghdmlld3BvcnROb2RlKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFtdLCB1cGRhdGVkSW50ZXJuYWxzIH07XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0Tm9kZSk7XG4gICAgY29uc3QgeyBtMjI6IHpvb20gfSA9IG5ldyB3aW5kb3cuRE9NTWF0cml4UmVhZE9ubHkoc3R5bGUudHJhbnNmb3JtKTtcbiAgICAvLyBpbiB0aGlzIGFycmF5IHdlIGNvbGxlY3Qgbm9kZXMsIHRoYXQgbWlnaHQgdHJpZ2dlciBjaGFuZ2VzIChsaWtlIGV4cGFuZGluZyBwYXJlbnQpXG4gICAgY29uc3QgcGFyZW50RXhwYW5kQ2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldCh1cGRhdGUuaWQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVkSW50ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKHVwZGF0ZS5ub2RlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZWQgPSBub2RlLm1lYXN1cmVkLndpZHRoICE9PSBkaW1lbnNpb25zLndpZHRoIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ICE9PSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgY29uc3QgZG9VcGRhdGUgPSAhIShkaW1lbnNpb25zLndpZHRoICYmXG4gICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgKGRpbWVuc2lvbkNoYW5nZWQgfHwgIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyB8fCB1cGRhdGUuZm9yY2UpKTtcbiAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQm91bmRzID0gdXBkYXRlLm5vZGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSA/IG5vZGUuZXh0ZW50IDogbm9kZUV4dGVudDtcbiAgICAgICAgICAgIGxldCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb25Ub1BhcmVudChwb3NpdGlvbkFic29sdXRlLCBkaW1lbnNpb25zLCBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbkFic29sdXRlLCBleHRlbnQsIGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGdldEhhbmRsZUJvdW5kcygnc291cmNlJywgdXBkYXRlLm5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZ2V0SGFuZGxlQm91bmRzKCd0YXJnZXQnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwgbmV3Tm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShuZXdOb2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHsgbm9kZU9yaWdpbiwgekluZGV4TW9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEV4cGFuZENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGVUb1JlY3QobmV3Tm9kZSwgbm9kZU9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgfVxuICAgIHJldHVybiB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhbkJ5KHsgZGVsdGEsIHBhblpvb20sIHRyYW5zZm9ybSwgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB9KSB7XG4gICAgaWYgKCFwYW5ab29tIHx8ICghZGVsdGEueCAmJiAhZGVsdGEueSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRWaWV3cG9ydCA9IGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHRyYW5zZm9ybVswXSArIGRlbHRhLngsXG4gICAgICAgIHk6IHRyYW5zZm9ybVsxXSArIGRlbHRhLnksXG4gICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICB9LCBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgdHJhbnNmb3JtQ2hhbmdlZCA9ICEhbmV4dFZpZXdwb3J0ICYmXG4gICAgICAgIChuZXh0Vmlld3BvcnQueCAhPT0gdHJhbnNmb3JtWzBdIHx8IG5leHRWaWV3cG9ydC55ICE9PSB0cmFuc2Zvcm1bMV0gfHwgbmV4dFZpZXdwb3J0LmsgIT09IHRyYW5zZm9ybVsyXSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cmFuc2Zvcm1DaGFuZ2VkKTtcbn1cbi8qKlxuICogdGhpcyBmdW5jdGlvbiBhZGRzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjb25uZWN0aW9uTG9va3VwXG4gKiBhdCB0aGUgZm9sbG93aW5nIGtleXM6IG5vZGVJZC10eXBlLWhhbmRsZUlkLCBub2RlSWQtdHlwZSBhbmQgbm9kZUlkXG4gKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBjb25uZWN0aW9uIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBsb29rdXBcbiAqIEBwYXJhbSBjb25uZWN0aW9uS2V5IGF0IHdoaWNoIGtleSB0aGUgY29ubmVjdGlvbiBzaG91bGQgYmUgYWRkZWRcbiAqIEBwYXJhbSBjb25uZWN0aW9uTG9va3VwIHJlZmVyZW5jZSB0byB0aGUgY29ubmVjdGlvbiBsb29rdXBcbiAqIEBwYXJhbSBub2RlSWQgbm9kZUlkIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gaGFuZGxlSWQgaGFuZGxlSWQgb2YgdGhlIGNvbm5lY2l0b25cbiAqL1xuZnVuY3Rpb24gYWRkQ29ubmVjdGlvblRvTG9va3VwKHR5cGUsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25Mb29rdXAsIG5vZGVJZCwgaGFuZGxlSWQpIHtcbiAgICAvKlxuICAgICAqIFdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgY29ubmVjdGlvbkxvb2t1cCBhdCB0aGUgZm9sbG93aW5nIGtleXNcbiAgICAgKiAxLiBub2RlSWQsIDIuIG5vZGVJZC10eXBlLCAzLiBub2RlSWQtdHlwZS1oYW5kbGVJZFxuICAgICAqIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMsIHdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgZXhpc3RpbmcgbWFwXG4gICAgICovXG4gICAgbGV0IGtleSA9IG5vZGVJZDtcbiAgICBjb25zdCBub2RlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCBub2RlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9YDtcbiAgICBjb25zdCB0eXBlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCB0eXBlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgaWYgKGhhbmRsZUlkKSB7XG4gICAgICAgIGtleSA9IGAke25vZGVJZH0tJHt0eXBlfS0ke2hhbmRsZUlkfWA7XG4gICAgICAgIGNvbnN0IGhhbmRsZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIGhhbmRsZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpIHtcbiAgICBjb25uZWN0aW9uTG9va3VwLmNsZWFyKCk7XG4gICAgZWRnZUxvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCB7IHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUgPSBudWxsLCB0YXJnZXRIYW5kbGUgPSBudWxsIH0gPSBlZGdlO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geyBlZGdlSWQ6IGVkZ2UuaWQsIHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9O1xuICAgICAgICBjb25zdCBzb3VyY2VLZXkgPSBgJHtzb3VyY2VOb2RlfS0ke3NvdXJjZUhhbmRsZX0tLSR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9YDtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gYCR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9LS0ke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfWA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgnc291cmNlJywgY29ubmVjdGlvbiwgdGFyZ2V0S2V5LCBjb25uZWN0aW9uTG9va3VwLCBzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUpO1xuICAgICAgICBhZGRDb25uZWN0aW9uVG9Mb29rdXAoJ3RhcmdldCcsIGNvbm5lY3Rpb24sIHNvdXJjZUtleSwgY29ubmVjdGlvbkxvb2t1cCwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SGFuZGxlKTtcbiAgICAgICAgZWRnZUxvb2t1cC5zZXQoZWRnZS5pZCwgZWRnZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaGFsbG93Tm9kZURhdGEoYSwgYikge1xuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBfYSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdO1xuICAgIGNvbnN0IF9iID0gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBbYl07XG4gICAgaWYgKF9hLmxlbmd0aCAhPT0gX2IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX2FbaV0uaWQgIT09IF9iW2ldLmlkIHx8IF9hW2ldLnR5cGUgIT09IF9iW2ldLnR5cGUgfHwgIU9iamVjdC5pcyhfYVtpXS5kYXRhLCBfYltpXS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1BhcmVudFNlbGVjdGVkKG5vZGUsIG5vZGVMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVMb29rdXApO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3RvciwgZG9tTm9kZSkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXM/LihzZWxlY3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvbU5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnRFbGVtZW50O1xuICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGxvb2tzIGZvciBhbGwgc2VsZWN0ZWQgbm9kZXMgYW5kIGNyZWF0ZWQgYSBOb2RlRHJhZ0l0ZW0gZm9yIGVhY2ggb2YgdGhlbVxuZnVuY3Rpb24gZ2V0RHJhZ0l0ZW1zKG5vZGVMb29rdXAsIG5vZGVzRHJhZ2dhYmxlLCBtb3VzZVBvcywgbm9kZUlkKSB7XG4gICAgY29uc3QgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgIGlmICgobm9kZS5zZWxlY3RlZCB8fCBub2RlLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICAgICAoIW5vZGUucGFyZW50SWQgfHwgIWlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkpICYmXG4gICAgICAgICAgICAobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbnRlcm5hbE5vZGUucG9zaXRpb24gfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZVBvcy55IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudDogaW50ZXJuYWxOb2RlLmV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGludGVybmFsTm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBpbnRlcm5hbE5vZGUub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRQYXJlbnQ6IGludGVybmFsTm9kZS5leHBhbmRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRyYWdJdGVtcztcbn1cbi8qXG4gKiByZXR1cm5zIHR3byBwYXJhbXM6XG4gKiAxLiB0aGUgZHJhZ2dlZCBub2RlIChvciB0aGUgZmlyc3Qgb2YgdGhlIGxpc3QsIGlmIHdlIGFyZSBkcmFnZ2luZyBhIG5vZGUgc2VsZWN0aW9uKVxuICogMi4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZXMgKGZvciBtdWx0aSBzZWxlY3Rpb25zKVxuICovXG5mdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJQYXJhbXMoeyBub2RlSWQsIGRyYWdJdGVtcywgbm9kZUxvb2t1cCwgZHJhZ2dpbmcgPSB0cnVlLCB9KSB7XG4gICAgY29uc3Qgbm9kZXNGcm9tRHJhZ0l0ZW1zID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBkcmFnSXRlbXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZXNGcm9tRHJhZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFtub2Rlc0Zyb21EcmFnSXRlbXNbMF0sIG5vZGVzRnJvbURyYWdJdGVtc107XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgIW5vZGVcbiAgICAgICAgICAgID8gbm9kZXNGcm9tRHJhZ0l0ZW1zWzBdXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkcmFnSXRlbXMuZ2V0KG5vZGVJZCk/LnBvc2l0aW9uIHx8IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMsXG4gICAgXTtcbn1cbi8qKlxuICogSWYgYSBzZWxlY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZCB3ZSB3YW50IHRvIGFwcGx5IHRoZSBzYW1lIHNuYXAgb2Zmc2V0IHRvIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzbmFwIG9mZnNldCBiYXNlZCBvbiB0aGUgZmlyc3Qgbm9kZSBpbiB0aGUgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTbmFwT2Zmc2V0KHsgZHJhZ0l0ZW1zLCBzbmFwR3JpZCwgeCwgeSwgfSkge1xuICAgIGNvbnN0IHJlZkRyYWdJdGVtID0gZHJhZ0l0ZW1zLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBpZiAoIXJlZkRyYWdJdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZQb3MgPSB7XG4gICAgICAgIHg6IHggLSByZWZEcmFnSXRlbS5kaXN0YW5jZS54LFxuICAgICAgICB5OiB5IC0gcmVmRHJhZ0l0ZW0uZGlzdGFuY2UueSxcbiAgICB9O1xuICAgIGNvbnN0IHJlZlBvc1NuYXBwZWQgPSBzbmFwUG9zaXRpb24ocmVmUG9zLCBzbmFwR3JpZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmVmUG9zU25hcHBlZC54IC0gcmVmUG9zLngsXG4gICAgICAgIHk6IHJlZlBvc1NuYXBwZWQueSAtIHJlZlBvcy55LFxuICAgIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBYWURyYWcoeyBvbk5vZGVNb3VzZURvd24sIGdldFN0b3JlSXRlbXMsIG9uRHJhZ1N0YXJ0LCBvbkRyYWcsIG9uRHJhZ1N0b3AsIH0pIHtcbiAgICBsZXQgbGFzdFBvcyA9IHsgeDogbnVsbCwgeTogbnVsbCB9O1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBkcmFnSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG1vdXNlUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICBsZXQgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgZDNTZWxlY3Rpb24gPSBudWxsO1xuICAgIGxldCBhYm9ydERyYWcgPSBmYWxzZTsgLy8gcHJldmVudHMgdW5pbnRlbnRpb25hbCBkcmFnZ2luZyBvbiBtdWx0aXRvdWNoXG4gICAgbGV0IG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgLy8gd2Ugc3RvcmUgdGhlIGxhc3QgZHJhZyBldmVudCB0byBiZSBhYmxlIHRvIHVzZSBpdCBpbiB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAgbGV0IGRyYWdFdmVudCA9IG51bGw7XG4gICAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRvbU5vZGUsIGlzU2VsZWN0YWJsZSwgbm9kZUlkLCBub2RlQ2xpY2tEaXN0YW5jZSA9IDAsIH0pIHtcbiAgICAgICAgZDNTZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHsgeCwgeSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVFeHRlbnQsIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBvbk5vZGVEcmFnLCBvblNlbGVjdGlvbkRyYWcsIG9uRXJyb3IsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBsYXN0UG9zID0geyB4LCB5IH07XG4gICAgICAgICAgICBsZXQgaGFzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBpc011bHRpRHJhZyA9IGRyYWdJdGVtcy5zaXplID4gMTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzQm94ID0gaXNNdWx0aURyYWcgJiYgbm9kZUV4dGVudCA/IHJlY3RUb0JveChnZXRJbnRlcm5hbE5vZGVzQm91bmRzKGRyYWdJdGVtcykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpRHJhZ1NuYXBPZmZzZXQgPSBpc011bHRpRHJhZyAmJiBzbmFwVG9HcmlkXG4gICAgICAgICAgICAgICAgPyBjYWxjdWxhdGVTbmFwT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2YgZHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiB0aGUgbm9kZSBpcyBub3QgaW4gdGhlIG5vZGVMb29rdXAgYW55bW9yZSwgaXQgd2FzIHByb2JhYmx5IGRlbGV0ZWQgd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVMb29rdXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHsgeDogeCAtIGRyYWdJdGVtLmRpc3RhbmNlLngsIHk6IHkgLSBkcmFnSXRlbS5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gbXVsdGlEcmFnU25hcE9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueCArIG11bHRpRHJhZ1NuYXBPZmZzZXQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueSArIG11bHRpRHJhZ1NuYXBPZmZzZXQueSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNuYXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIHNuYXBHcmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFkanVzdGVkTm9kZUV4dGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlEcmFnICYmIG5vZGVFeHRlbnQgJiYgIWRyYWdJdGVtLmV4dGVudCAmJiBub2Rlc0JveCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IGRyYWdJdGVtLmludGVybmFscztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDEgPSBwb3NpdGlvbkFic29sdXRlLnggLSBub2Rlc0JveC54ICsgbm9kZUV4dGVudFswXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDIgPSBwb3NpdGlvbkFic29sdXRlLnggKyBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTEgPSBwb3NpdGlvbkFic29sdXRlLnkgLSBub2Rlc0JveC55ICsgbm9kZUV4dGVudFswXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTIgPSBwb3NpdGlvbkFic29sdXRlLnkgKyBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgLSBub2Rlc0JveC55MiArIG5vZGVFeHRlbnRbMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MSwgeTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3gyLCB5Ml0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUV4dGVudDogYWRqdXN0ZWROb2RlRXh0ZW50ID8gYWRqdXN0ZWROb2RlRXh0ZW50IDogbm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgZmlyZSBhIGNoYW5nZSBldmVudCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IGRyYWdJdGVtLnBvc2l0aW9uLnggIT09IHBvc2l0aW9uLnggfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueSAhPT0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gbm9kZVBvc2l0aW9uc0NoYW5nZWQgfHwgaGFzQ2hhbmdlO1xuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKGRyYWdJdGVtcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50ICYmIChvbkRyYWcgfHwgb25Ob2RlRHJhZyB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWcpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZz8uKGRyYWdFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWc/LihkcmFnRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYW5CeSwgYXV0b1BhblNwZWVkLCBhdXRvUGFuT25Ob2RlRHJhZyB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgaWYgKCFhdXRvUGFuT25Ob2RlRHJhZykge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbiwgY29udGFpbmVyQm91bmRzLCBhdXRvUGFuU3BlZWQpO1xuICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnggPSAobGFzdFBvcy54ID8/IDApIC0geE1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MueSA9IChsYXN0UG9zLnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IHBhbkJ5KHsgeDogeE1vdmVtZW50LCB5OiB5TW92ZW1lbnQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZXMobGFzdFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZXNEcmFnZ2FibGUsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIHNlbGVjdE5vZGVzT25EcmFnLCBvbk5vZGVEcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNTZWxlY3RhYmxlKSAmJiAhbXVsdGlTZWxlY3Rpb25BY3RpdmUgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHNlbGVjdGVkIG5vZGVzIHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZyAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBvbk5vZGVNb3VzZURvd24/Lihub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgIGRyYWdJdGVtcyA9IGdldERyYWdJdGVtcyhub2RlTG9va3VwLCBub2Rlc0RyYWdnYWJsZSwgcG9pbnRlclBvcywgbm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDAgJiYgKG9uRHJhZ1N0YXJ0IHx8IG9uTm9kZURyYWdTdGFydCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZDNEcmFnSW5zdGFuY2UgPSBkcmFnKClcbiAgICAgICAgICAgIC5jbGlja0Rpc3RhbmNlKG5vZGVDbGlja0Rpc3RhbmNlKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb21Ob2RlLCBub2RlRHJhZ1RocmVzaG9sZCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGFib3J0RHJhZyA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgICAgICAgICAgaWYgKG5vZGVEcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBtb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRvUGFuT25Ob2RlRHJhZywgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZURyYWdUaHJlc2hvbGQsIG5vZGVMb29rdXAgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgZHJhZ0V2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIGRlbGV0ZXMgYSBub2RlIHdoaWxlIGRyYWdnaW5nLCB3ZSBuZWVkIHRvIGFib3J0IHRoZSBkcmFnIHRvIHByZXZlbnQgZXJyb3JzXG4gICAgICAgICAgICAgICAgKG5vZGVJZCAmJiAhbm9kZUxvb2t1cC5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgICAgICBhYm9ydERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0RHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXV0b1BhblN0YXJ0ZWQgJiYgYXV0b1Bhbk9uTm9kZURyYWcgJiYgZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBpbiBjbGllbnQgY29vcmRpbmF0ZXMgZm9yIGNvbnNpc3RlbnQgZHJhZyB0aHJlc2hvbGQgYmVoYXZpb3IgYWNyb3NzIHpvb20gbGV2ZWxzXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjdXJyZW50TW91c2VQb3NpdGlvbi54IC0gbW91c2VQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBjdXJyZW50TW91c2VQb3NpdGlvbi55IC0gbW91c2VQb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG5vZGVEcmFnVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBldmVudHMgd2l0aG91dCBtb3ZlbWVudFxuICAgICAgICAgICAgaWYgKChsYXN0UG9zLnggIT09IHBvaW50ZXJQb3MueFNuYXBwZWQgfHwgbGFzdFBvcy55ICE9PSBwb2ludGVyUG9zLnlTbmFwcGVkKSAmJiBkcmFnSXRlbXMgJiYgZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2Rlcyhwb2ludGVyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkIHx8IGFib3J0RHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIG9uTm9kZURyYWdTdG9wLCBvblNlbGVjdGlvbkRyYWdTdG9wIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVQb3NpdGlvbnNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbkRyYWdTdG9wIHx8IG9uTm9kZURyYWdTdG9wIHx8ICghbm9kZUlkICYmIG9uU2VsZWN0aW9uRHJhZ1N0b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBkcmFnSXRlbXMsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBvbk5vZGVEcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICFldmVudC5idXR0b24gJiZcbiAgICAgICAgICAgICAgICAoIW5vRHJhZ0NsYXNzTmFtZSB8fCAhaGFzU2VsZWN0b3IodGFyZ2V0LCBgLiR7bm9EcmFnQ2xhc3NOYW1lfWAsIGRvbU5vZGUpKSAmJlxuICAgICAgICAgICAgICAgICghaGFuZGxlU2VsZWN0b3IgfHwgaGFzU2VsZWN0b3IodGFyZ2V0LCBoYW5kbGVTZWxlY3RvciwgZG9tTm9kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzRHJhZ2dhYmxlO1xuICAgICAgICB9KTtcbiAgICAgICAgZDNTZWxlY3Rpb24uY2FsbChkM0RyYWdJbnN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGQzU2VsZWN0aW9uPy5vbignLmRyYWcnLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVzV2l0aGluRGlzdGFuY2UocG9zaXRpb24sIG5vZGVMb29rdXAsIGRpc3RhbmNlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCByZWN0ID0ge1xuICAgICAgICB4OiBwb3NpdGlvbi54IC0gZGlzdGFuY2UsXG4gICAgICAgIHk6IHBvc2l0aW9uLnkgLSBkaXN0YW5jZSxcbiAgICAgICAgd2lkdGg6IGRpc3RhbmNlICogMixcbiAgICAgICAgaGVpZ2h0OiBkaXN0YW5jZSAqIDIsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxvb2t1cC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZ2V0T3ZlcmxhcHBpbmdBcmVhKHJlY3QsIG5vZGVUb1JlY3Qobm9kZSkpID4gMCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG4vKlxuICogdGhpcyBkaXN0YW5jZSBpcyB1c2VkIGZvciB0aGUgYXJlYSBhcm91bmQgdGhlIHVzZXIgcG9pbnRlclxuICogd2hpbGUgZG9pbmcgYSBjb25uZWN0aW9uIGZvciBmaW5kaW5nIHRoZSBjbG9zZXN0IG5vZGVzXG4gKi9cbmNvbnN0IEFERElUSU9OQUxfRElTVEFOQ0UgPSAyNTA7XG5mdW5jdGlvbiBnZXRDbG9zZXN0SGFuZGxlKHBvc2l0aW9uLCBjb25uZWN0aW9uUmFkaXVzLCBub2RlTG9va3VwLCBmcm9tSGFuZGxlKSB7XG4gICAgbGV0IGNsb3Nlc3RIYW5kbGVzID0gW107XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgY29uc3QgY2xvc2VOb2RlcyA9IGdldE5vZGVzV2l0aGluRGlzdGFuY2UocG9zaXRpb24sIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25SYWRpdXMgKyBBRERJVElPTkFMX0RJU1RBTkNFKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY2xvc2VOb2Rlcykge1xuICAgICAgICBjb25zdCBhbGxIYW5kbGVzID0gWy4uLihub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSksIC4uLihub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LnRhcmdldCA/PyBbXSldO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBhbGxIYW5kbGVzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgaGFuZGxlIGlzIHRoZSBzYW1lIGFzIHRoZSBmcm9tSGFuZGxlIHdlIHNraXAgaXRcbiAgICAgICAgICAgIGlmIChmcm9tSGFuZGxlLm5vZGVJZCA9PT0gaGFuZGxlLm5vZGVJZCAmJiBmcm9tSGFuZGxlLnR5cGUgPT09IGhhbmRsZS50eXBlICYmIGZyb21IYW5kbGUuaWQgPT09IGhhbmRsZS5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGVcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBoYW5kbGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coeSAtIHBvc2l0aW9uLnksIDIpKTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IGNvbm5lY3Rpb25SYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMgPSBbeyAuLi5oYW5kbGUsIHgsIHkgfV07XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gbXVsdGlwbGUgaGFuZGxlcyBhcmUgb24gdGhlIHNhbWUgZGlzdGFuY2Ugd2UgY29sbGVjdCBhbGwgb2YgdGhlbVxuICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzLnB1c2goeyAuLi5oYW5kbGUsIHgsIHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0SGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHdoZW4gbXVsdGlwbGUgaGFuZGxlcyBvdmVybGF5IGVhY2ggb3RoZXIgd2UgcHJlZmVyIHRoZSBvcHBvc2l0ZSBoYW5kbGVcbiAgICBpZiAoY2xvc2VzdEhhbmRsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBvcHBvc2l0ZUhhbmRsZVR5cGUgPSBmcm9tSGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnID8gJ3RhcmdldCcgOiAnc291cmNlJztcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzLmZpbmQoKGhhbmRsZSkgPT4gaGFuZGxlLnR5cGUgPT09IG9wcG9zaXRlSGFuZGxlVHlwZSkgPz8gY2xvc2VzdEhhbmRsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0SGFuZGxlc1swXTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZShub2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSwgd2l0aEFic29sdXRlUG9zaXRpb24gPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcyA9IGNvbm5lY3Rpb25Nb2RlID09PSAnc3RyaWN0J1xuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uW2hhbmRsZVR5cGVdXG4gICAgICAgIDogWy4uLihub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSksIC4uLihub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LnRhcmdldCA/PyBbXSldO1xuICAgIGNvbnN0IGhhbmRsZSA9IChoYW5kbGVJZCA/IGhhbmRsZXM/LmZpbmQoKGgpID0+IGguaWQgPT09IGhhbmRsZUlkKSA6IGhhbmRsZXM/LlswXSkgPz8gbnVsbDtcbiAgICByZXR1cm4gaGFuZGxlICYmIHdpdGhBYnNvbHV0ZVBvc2l0aW9uXG4gICAgICAgID8geyAuLi5oYW5kbGUsIC4uLmdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgaGFuZGxlLnBvc2l0aW9uLCB0cnVlKSB9XG4gICAgICAgIDogaGFuZGxlO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlVHlwZShlZGdlVXBkYXRlclR5cGUsIGhhbmRsZURvbU5vZGUpIHtcbiAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiBlZGdlVXBkYXRlclR5cGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygndGFyZ2V0JykpIHtcbiAgICAgICAgcmV0dXJuICd0YXJnZXQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QuY29udGFpbnMoJ3NvdXJjZScpKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb25WYWxpZChpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMsIGlzSGFuZGxlVmFsaWQpIHtcbiAgICBsZXQgaXNWYWxpZCA9IG51bGw7XG4gICAgaWYgKGlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cyAmJiAhaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkO1xufVxuXG5jb25zdCBhbHdheXNWYWxpZCA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50LCB7IGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uUmFkaXVzLCBoYW5kbGVJZCwgbm9kZUlkLCBlZGdlVXBkYXRlclR5cGUsIGlzVGFyZ2V0LCBkb21Ob2RlLCBub2RlTG9va3VwLCBsaWIsIGF1dG9QYW5PbkNvbm5lY3QsIGZsb3dJZCwgcGFuQnksIGNhbmNlbENvbm5lY3Rpb24sIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3QsIG9uQ29ubmVjdEVuZCwgaXNWYWxpZENvbm5lY3Rpb24gPSBhbHdheXNWYWxpZCwgb25SZWNvbm5lY3RFbmQsIHVwZGF0ZUNvbm5lY3Rpb24sIGdldFRyYW5zZm9ybSwgZ2V0RnJvbUhhbmRsZSwgYXV0b1BhblNwZWVkLCBkcmFnVGhyZXNob2xkID0gMSwgaGFuZGxlRG9tTm9kZSwgfSkge1xuICAgIC8vIHdoZW4geHlmbG93IGlzIHVzZWQgaW5zaWRlIGEgc2hhZG93IHJvb3Qgd2UgY2FuJ3QgdXNlIGRvY3VtZW50XG4gICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGNvbm5lY3Rpb25TdGFydGVkID0gZmFsc2U7XG4gICAgaWYgKCFjb250YWluZXJCb3VuZHMgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSGFuZGxlSW50ZXJuYWwgPSBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUpO1xuICAgIGlmICghZnJvbUhhbmRsZUludGVybmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29ubmVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0SGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgLy8gd2hlbiB0aGUgdXNlciBpcyBtb3ZpbmcgdGhlIG1vdXNlIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXMgd2hpbGUgY29ubmVjdGluZyB3ZSBtb3ZlIHRoZSBjYW52YXNcbiAgICBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICBpZiAoIWF1dG9QYW5PbkNvbm5lY3QgfHwgIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IGNhbGNBdXRvUGFuKHBvc2l0aW9uLCBjb250YWluZXJCb3VuZHMsIGF1dG9QYW5TcGVlZCk7XG4gICAgICAgIHBhbkJ5KHsgeCwgeSB9KTtcbiAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgIH1cbiAgICAvLyBTdGF5cyB0aGUgc2FtZSBmb3IgYWxsIGNvbnNlY3V0aXZlIHBvaW50ZXJtb3ZlIGV2ZW50c1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSB7XG4gICAgICAgIC4uLmZyb21IYW5kbGVJbnRlcm5hbCxcbiAgICAgICAgbm9kZUlkLFxuICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICBwb3NpdGlvbjogZnJvbUhhbmRsZUludGVybmFsLnBvc2l0aW9uLFxuICAgIH07XG4gICAgY29uc3QgZnJvbUludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgY29uc3QgZnJvbSA9IGdldEhhbmRsZVBvc2l0aW9uKGZyb21JbnRlcm5hbE5vZGUsIGZyb21IYW5kbGUsIFBvc2l0aW9uLkxlZnQsIHRydWUpO1xuICAgIGxldCBwcmV2aW91c0Nvbm5lY3Rpb24gPSB7XG4gICAgICAgIGluUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgIGlzVmFsaWQ6IG51bGwsXG4gICAgICAgIGZyb20sXG4gICAgICAgIGZyb21IYW5kbGUsXG4gICAgICAgIGZyb21Qb3NpdGlvbjogZnJvbUhhbmRsZS5wb3NpdGlvbixcbiAgICAgICAgZnJvbU5vZGU6IGZyb21JbnRlcm5hbE5vZGUsXG4gICAgICAgIHRvOiBwb3NpdGlvbixcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgICAgIHRvUG9zaXRpb246IG9wcG9zaXRlUG9zaXRpb25bZnJvbUhhbmRsZS5wb3NpdGlvbl0sXG4gICAgICAgIHRvTm9kZTogbnVsbCxcbiAgICAgICAgcG9pbnRlcjogcG9zaXRpb24sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBzdGFydENvbm5lY3Rpb24oKSB7XG4gICAgICAgIGNvbm5lY3Rpb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbihwcmV2aW91c0Nvbm5lY3Rpb24pO1xuICAgICAgICBvbkNvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChkcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Q29ubmVjdGlvbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghY29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeDogZXZ0WCwgeTogZXZ0WSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgICAgICAgICBjb25zdCBkeCA9IGV2dFggLSB4O1xuICAgICAgICAgICAgY29uc3QgZHkgPSBldnRZIC0geTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDb25uZWN0aW9uU3RhcnRlZCA9IGR4ICogZHggKyBkeSAqIGR5ID4gZHJhZ1RocmVzaG9sZCAqIGRyYWdUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoIW5leHRDb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2V0RnJvbUhhbmRsZSgpIHx8ICFmcm9tSGFuZGxlKSB7XG4gICAgICAgICAgICBvblBvaW50ZXJVcChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgY2xvc2VzdEhhbmRsZSA9IGdldENsb3Nlc3RIYW5kbGUocG9pbnRUb1JlbmRlcmVyUG9pbnQocG9zaXRpb24sIHRyYW5zZm9ybSwgZmFsc2UsIFsxLCAxXSksIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpO1xuICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkKSB7XG4gICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXNWYWxpZEhhbmRsZShldmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiBjbG9zZXN0SGFuZGxlLFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBmcm9tTm9kZUlkOiBub2RlSWQsXG4gICAgICAgICAgICBmcm9tSGFuZGxlSWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGlzVGFyZ2V0ID8gJ3RhcmdldCcgOiAnc291cmNlJyxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdEhhbmRsZURvbU5vZGUgPSByZXN1bHQuaGFuZGxlRG9tTm9kZTtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlc3VsdC5jb25uZWN0aW9uO1xuICAgICAgICBpc1ZhbGlkID0gaXNDb25uZWN0aW9uVmFsaWQoISFjbG9zZXN0SGFuZGxlLCByZXN1bHQuaXNWYWxpZCk7XG4gICAgICAgIGNvbnN0IGZyb21JbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICBjb25zdCBmcm9tID0gZnJvbUludGVybmFsTm9kZVxuICAgICAgICAgICAgPyBnZXRIYW5kbGVQb3NpdGlvbihmcm9tSW50ZXJuYWxOb2RlLCBmcm9tSGFuZGxlLCBQb3NpdGlvbi5MZWZ0LCB0cnVlKVxuICAgICAgICAgICAgOiBwcmV2aW91c0Nvbm5lY3Rpb24uZnJvbTtcbiAgICAgICAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnByZXZpb3VzQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgdG86IHJlc3VsdC50b0hhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IHJlc3VsdC50b0hhbmRsZS54LCB5OiByZXN1bHQudG9IYW5kbGUueSB9LCB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHRvSGFuZGxlOiByZXN1bHQudG9IYW5kbGUsXG4gICAgICAgICAgICB0b1Bvc2l0aW9uOiBpc1ZhbGlkICYmIHJlc3VsdC50b0hhbmRsZSA/IHJlc3VsdC50b0hhbmRsZS5wb3NpdGlvbiA6IG9wcG9zaXRlUG9zaXRpb25bZnJvbUhhbmRsZS5wb3NpdGlvbl0sXG4gICAgICAgICAgICB0b05vZGU6IHJlc3VsdC50b0hhbmRsZSA/IG5vZGVMb29rdXAuZ2V0KHJlc3VsdC50b0hhbmRsZS5ub2RlSWQpIDogbnVsbCxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvc2l0aW9uLFxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKG5ld0Nvbm5lY3Rpb24pO1xuICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICAvLyBQcmV2ZW50IG11bHRpLXRvdWNoIGFib3J0aW5nIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKCd0b3VjaGVzJyBpbiBldmVudCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGlmICgoY2xvc2VzdEhhbmRsZSB8fCByZXN1bHRIYW5kbGVEb21Ob2RlKSAmJiBjb25uZWN0aW9uICYmIGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q/Lihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpdCdzIGltcG9ydGFudCB0byBnZXQgYSBmcmVzaCByZWZlcmVuY2UgZnJvbSB0aGUgc3RvcmUgaGVyZVxuICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gZ2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2Ygb25Db25uZWN0RW5kXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgLi4uY29ubmVjdGlvblN0YXRlIH0gPSBwcmV2aW91c0Nvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBmaW5hbENvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5jb25uZWN0aW9uU3RhdGUsXG4gICAgICAgICAgICAgICAgdG9Qb3NpdGlvbjogcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlID8gcHJldmlvdXNDb25uZWN0aW9uLnRvUG9zaXRpb24gOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uQ29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldmVudCwgZmluYWxDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb24oKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmVzdWx0SGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xuICAgIH1cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbn1cbi8vIGNoZWNrcyBpZiAgYW5kIHJldHVybnMgY29ubmVjdGlvbiBpbiBmb20gb2YgYW4gb2JqZWN0IHsgc291cmNlOiAxMjMsIHRhcmdldDogMzEyIH1cbmZ1bmN0aW9uIGlzVmFsaWRIYW5kbGUoZXZlbnQsIHsgaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgZnJvbU5vZGVJZCwgZnJvbUhhbmRsZUlkLCBmcm9tVHlwZSwgZG9jLCBsaWIsIGZsb3dJZCwgaXNWYWxpZENvbm5lY3Rpb24gPSBhbHdheXNWYWxpZCwgbm9kZUxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZnJvbVR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IGhhbmRsZURvbU5vZGUgPSBoYW5kbGVcbiAgICAgICAgPyBkb2MucXVlcnlTZWxlY3RvcihgLiR7bGlifS1mbG93X19oYW5kbGVbZGF0YS1pZD1cIiR7Zmxvd0lkfS0ke2hhbmRsZT8ubm9kZUlkfS0ke2hhbmRsZT8uaWR9LSR7aGFuZGxlPy50eXBlfVwiXWApXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGhhbmRsZUJlbG93ID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgLypcbiAgICAgKiB3ZSBhbHdheXMgd2FudCB0byBwcmlvcml0aXplIHRoZSBoYW5kbGUgYmVsb3cgdGhlIG1vdXNlIGN1cnNvciBvdmVyIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGhhbmRsZSxcbiAgICAgKiBiZWNhdXNlIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGNlbnRlciBvZiBhbm90aGVyIGhhbmRsZSBpcyBjbG9zZXIgdG8gdGhlIG1vdXNlIHBvaW50ZXIgdGhhbiB0aGUgaGFuZGxlIGJlbG93IHRoZSBjdXJzb3JcbiAgICAgKi9cbiAgICBjb25zdCBoYW5kbGVUb0NoZWNrID0gaGFuZGxlQmVsb3c/LmNsYXNzTGlzdC5jb250YWlucyhgJHtsaWJ9LWZsb3dfX2hhbmRsZWApID8gaGFuZGxlQmVsb3cgOiBoYW5kbGVEb21Ob2RlO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgaGFuZGxlRG9tTm9kZTogaGFuZGxlVG9DaGVjayxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb246IG51bGwsXG4gICAgICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIH07XG4gICAgaWYgKGhhbmRsZVRvQ2hlY2spIHtcbiAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVUb0NoZWNrKTtcbiAgICAgICAgY29uc3QgaGFuZGxlTm9kZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGUgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGUnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGVFbmQgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGVlbmQnKTtcbiAgICAgICAgaWYgKCFoYW5kbGVOb2RlSWQgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogaXNUYXJnZXQgPyBoYW5kbGVOb2RlSWQgOiBmcm9tTm9kZUlkLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBpc1RhcmdldCA/IGhhbmRsZUlkIDogZnJvbUhhbmRsZUlkLFxuICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCA/IGZyb21Ob2RlSWQgOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGlzVGFyZ2V0ID8gZnJvbUhhbmRsZUlkIDogaGFuZGxlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlICYmIGNvbm5lY3RhYmxlRW5kO1xuICAgICAgICAvLyBpbiBzdHJpY3QgbW9kZSB3ZSBkb24ndCBhbGxvdyB0YXJnZXQgdG8gdGFyZ2V0IG9yIHNvdXJjZSB0byBzb3VyY2UgY29ubmVjdGlvbnNcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgIChjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICAgICAgPyAoaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScpIHx8ICghaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3RhcmdldCcpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVOb2RlSWQgIT09IGZyb21Ob2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGVJZCk7XG4gICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gaXNWYWxpZCAmJiBpc1ZhbGlkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgcmVzdWx0LnRvSGFuZGxlID0gZ2V0SGFuZGxlKGhhbmRsZU5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFhZSGFuZGxlID0ge1xuICAgIG9uUG9pbnRlckRvd24sXG4gICAgaXNWYWxpZDogaXNWYWxpZEhhbmRsZSxcbn07XG5cbmZ1bmN0aW9uIFhZTWluaW1hcCh7IGRvbU5vZGUsIHBhblpvb20sIGdldFRyYW5zZm9ybSwgZ2V0Vmlld1NjYWxlIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB6b29tU3RlcCA9IDEsIHBhbm5hYmxlID0gdHJ1ZSwgem9vbWFibGUgPSB0cnVlLCBpbnZlcnNlUGFuID0gZmFsc2UsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgem9vbUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnd2hlZWwnIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPSBldmVudC5zb3VyY2VFdmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAoZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKlxuICAgICAgICAgICAgICAgIHpvb21TdGVwO1xuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0cmFuc2Zvcm1bMl0gKiBNYXRoLnBvdygyLCBwaW5jaERlbHRhICogZmFjdG9yKTtcbiAgICAgICAgICAgIHBhblpvb20uc2NhbGVUbyhuZXh0Wm9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYW5TdGFydCA9IFswLCAwXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFuU3RhcnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgcGFuU3RhcnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3RvdWNobW92ZScpIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFuQ3VycmVudCA9IFtcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRYID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYW5EZWx0YSA9IFtwYW5DdXJyZW50WzBdIC0gcGFuU3RhcnRbMF0sIHBhbkN1cnJlbnRbMV0gLSBwYW5TdGFydFsxXV07XG4gICAgICAgICAgICBwYW5TdGFydCA9IHBhbkN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSBnZXRWaWV3U2NhbGUoKSAqIE1hdGgubWF4KHRyYW5zZm9ybVsyXSwgTWF0aC5sb2codHJhbnNmb3JtWzJdKSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gLSBwYW5EZWx0YVswXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gLSBwYW5EZWx0YVsxXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHpvb21BbmRQYW5IYW5kbGVyID0gem9vbSgpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgcGFuU3RhcnRIYW5kbGVyKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tJywgcGFubmFibGUgPyBwYW5IYW5kbGVyIDogbnVsbClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC5vbignem9vbS53aGVlbCcsIHpvb21hYmxlID8gem9vbUhhbmRsZXIgOiBudWxsKTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoem9vbUFuZFBhbkhhbmRsZXIsIHt9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgcG9pbnRlcixcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0ID0gKHRyYW5zZm9ybSkgPT4gKHtcbiAgICB4OiB0cmFuc2Zvcm0ueCxcbiAgICB5OiB0cmFuc2Zvcm0ueSxcbiAgICB6b29tOiB0cmFuc2Zvcm0uayxcbn0pO1xuY29uc3Qgdmlld3BvcnRUb1RyYW5zZm9ybSA9ICh7IHgsIHksIHpvb20gfSkgPT4gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuLy8gdGFrZW4gZnJvbSBkMy1lYXNlOiBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZWFzZS9ibG9iL21haW4vc3JjL2N1YmljLmpzXG5jb25zdCBkZWZhdWx0RWFzZSA9ICh0KSA9PiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG5jb25zdCBnZXREM1RyYW5zaXRpb24gPSAoc2VsZWN0aW9uLCBkdXJhdGlvbiA9IDAsIGVhc2UgPSBkZWZhdWx0RWFzZSwgb25FbmQgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwO1xuICAgIGlmICghaGFzRHVyYXRpb24pIHtcbiAgICAgICAgb25FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gc2VsZWN0aW9uLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuZWFzZShlYXNlKS5vbignZW5kJywgb25FbmQpIDogc2VsZWN0aW9uO1xufTtcbmNvbnN0IHdoZWVsRGVsdGEgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBmYWN0b3IgPSBldmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIGZhY3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG5vV2hlZWxDbGFzc05hbWUsIGQzU2VsZWN0aW9uLCBkM1pvb20sIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgem9vbU9uUGluY2gsIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb20sIG9uUGFuWm9vbUVuZCwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gc3RvcCBuYXRpdmUgcGFnZSB6b29tIGZvciBwaW5jaCB6b29taW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpLmsgfHwgMTtcbiAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICogZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVsdGFOb3JtYWxpemUgPSBldmVudC5kZWx0YU1vZGUgPT09IDEgPyAyMCA6IDE7XG4gICAgICAgIGxldCBkZWx0YVggPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCA/IDAgOiBldmVudC5kZWx0YVggKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLkhvcml6b250YWwgPyAwIDogZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgIC8vIHRoaXMgZW5hYmxlcyB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2l0aCBzaGlmdCArIHNjcm9sbCBvbiB3aW5kb3dzXG4gICAgICAgIGlmICghaXNNYWNPcygpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykpO1xuICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICogd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICogYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmICghem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZykge1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25QYW5ab29tPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoeyBub1doZWVsQ2xhc3NOYW1lLCBwcmV2ZW50U2Nyb2xsaW5nLCBkM1pvb21IYW5kbGVyIH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBkKSB7XG4gICAgICAgIGNvbnN0IGlzV2hlZWwgPSBldmVudC50eXBlID09PSAnd2hlZWwnO1xuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGVuYWJsZSBwaW5jaCB6b29taW5nIGV2ZW4gaWYgcHJldmVudFNjcm9sbGluZyBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgY29uc3QgcHJldmVudFpvb20gPSAhcHJldmVudFNjcm9sbGluZyAmJiBpc1doZWVsICYmICFldmVudC5jdHJsS2V5O1xuICAgICAgICBjb25zdCBoYXNOb1doZWVsQ2xhc3MgPSBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpO1xuICAgICAgICAvLyBpZiB1c2VyIGlzIHBpbmNoIHpvb21pbmcgYWJvdmUgYSBub3doZWVsIGVsZW1lbnQsIHdlIGRvbid0IHdhbnQgdGhlIGJyb3dzZXIgdG8gem9vbVxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBpc1doZWVsICYmIGhhc05vV2hlZWxDbGFzcykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmVudFpvb20gfHwgaGFzTm9XaGVlbENsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkM1pvb21IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQsIGQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgb25EcmFnZ2luZ0NoYW5nZSwgb25QYW5ab29tU3RhcnQgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGl0IGhlcmUsIGJlY2F1c2UgaXQncyBhbHdheXMgMCBpbiB0aGUgXCJ6b29tXCIgZXZlbnRcbiAgICAgICAgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA9IGV2ZW50LnNvdXJjZUV2ZW50Py5idXR0b24gfHwgMDtcbiAgICAgICAgem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcgPSB0cnVlO1xuICAgICAgICB6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBhblpvb21TdGFydCkge1xuICAgICAgICAgICAgb25QYW5ab29tU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgdmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21IYW5kbGVyKHsgem9vbVBhblZhbHVlcywgcGFuT25EcmFnLCBvblBhbmVDb250ZXh0TWVudSwgb25UcmFuc2Zvcm1DaGFuZ2UsIG9uUGFuWm9vbSwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiA9ICEhKG9uUGFuZUNvbnRleHRNZW51ICYmIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkpO1xuICAgICAgICBpZiAoIWV2ZW50LnNvdXJjZUV2ZW50Py5zeW5jKSB7XG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZShbZXZlbnQudHJhbnNmb3JtLngsIGV2ZW50LnRyYW5zZm9ybS55LCBldmVudC50cmFuc2Zvcm0ua10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBhblpvb20gJiYgIWV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgb25QYW5ab29tPy4oZXZlbnQuc291cmNlRXZlbnQsIHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21FbmQsIG9uUGFuZUNvbnRleHRNZW51LCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9uUGFuZUNvbnRleHRNZW51ICYmXG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID8/IDApICYmXG4gICAgICAgICAgICAhem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiAmJlxuICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51KGV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gZmFsc2U7XG4gICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICBpZiAob25QYW5ab29tRW5kKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy50aW1lcklkKTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzZXRUaW1lb3V0IGZvciBwYW5PblNjcm9sbCB0byBzdXByZXNzIG11bHRpcGxlIGVuZCBldmVudHMgZmlyZWQgZHVyaW5nIHNjcm9sbFxuICAgICAgICAgICAgcGFuT25TY3JvbGwgPyAxNTAgOiAwKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcih7IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25EcmFnLCBwYW5PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHVzZXJTZWxlY3Rpb25BY3RpdmUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBsaWIsIGNvbm5lY3Rpb25JblByb2dyZXNzLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB6b29tU2Nyb2xsID0gem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IHpvb21PblNjcm9sbDtcbiAgICAgICAgY29uc3QgcGluY2hab29tID0gem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleTtcbiAgICAgICAgY29uc3QgaXNXaGVlbEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3doZWVsJztcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSAmJlxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiZcbiAgICAgICAgICAgIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fbm9kZWApIHx8IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19lZGdlYCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhbGwgaW50ZXJhY3Rpb25zIGFyZSBkaXNhYmxlZCwgd2UgcHJldmVudCBhbGwgem9vbSBldmVudHNcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgIXpvb21TY3JvbGwgJiYgIXBhbk9uU2Nyb2xsICYmICF6b29tT25Eb3VibGVDbGljayAmJiAhem9vbU9uUGluY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgYSBzZWxlY3Rpb24gd2UgcHJldmVudCBhbGwgb3RoZXIgaW50ZXJhY3Rpb25zXG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2FudCB0byBkaXNhYmxlIHBpbmNoLXpvb21pbmcgd2hpbGUgbWFraW5nIGEgY29ubmVjdGlvblxuICAgICAgICBpZiAoY29ubmVjdGlvbkluUHJvZ3Jlc3MgJiYgIWlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3doZWVsIGNsYXNzLCB3ZSBwcmV2ZW50IHpvb21pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkgJiYgaXNXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vcGFuIGNsYXNzLCB3ZSBwcmV2ZW50IHBhbm5pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9QYW5DbGFzc05hbWUpICYmXG4gICAgICAgICAgICAoIWlzV2hlZWxFdmVudCB8fCAocGFuT25TY3JvbGwgJiYgaXNXaGVlbEV2ZW50ICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleSAmJiBpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBldmVudC50b3VjaGVzPy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiB5b3UgbWFuYWdlIHRvIHN0YXJ0IHdpdGggMiB0b3VjaGVzLCB3ZSBwcmV2ZW50IG5hdGl2ZSB6b29tXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgIGlmICghem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXBpbmNoWm9vbSAmJiBpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG9ubHkgbW92YWJsZSB1c2luZyBhbGxvd2VkIGNsaWNrc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmICFwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSAmJiBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgcmlnaHQgY2xpY2tzIGlmIHBhbiBvbiBkcmFnIGlzIHNldCB0byByaWdodCBjbGlja1xuICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgLy8gZGVmYXVsdCBmaWx0ZXIgZm9yIGQzLXpvb21cbiAgICAgICAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBpc1doZWVsRXZlbnQpICYmIGJ1dHRvbkFsbG93ZWQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gWFlQYW5ab29tKHsgZG9tTm9kZSwgbWluWm9vbSwgbWF4Wm9vbSwgdHJhbnNsYXRlRXh0ZW50LCB2aWV3cG9ydCwgb25QYW5ab29tLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tRW5kLCBvbkRyYWdnaW5nQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgem9vbVBhblZhbHVlcyA9IHtcbiAgICAgICAgaXNab29taW5nT3JQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlZFJpZ2h0TW91c2VCdXR0b246IGZhbHNlLFxuICAgICAgICBwcmV2Vmlld3BvcnQ6IHsgeDogMCwgeTogMCwgem9vbTogMCB9LFxuICAgICAgICBtb3VzZUJ1dHRvbjogMCxcbiAgICAgICAgdGltZXJJZDogdW5kZWZpbmVkLFxuICAgICAgICBwYW5TY3JvbGxUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIGlzUGFuU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGJib3ggPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGQzWm9vbUluc3RhbmNlID0gem9vbSgpLnNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSkudHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNTZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSkuY2FsbChkM1pvb21JbnN0YW5jZSk7XG4gICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHZpZXdwb3J0LngsXG4gICAgICAgIHk6IHZpZXdwb3J0LnksXG4gICAgICAgIHpvb206IGNsYW1wKHZpZXdwb3J0Lnpvb20sIG1pblpvb20sIG1heFpvb20pLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbYmJveC53aWR0aCwgYmJveC5oZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJyk7XG4gICAgY29uc3QgZDNEYmxDbGlja1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nKTtcbiAgICBkM1pvb21JbnN0YW5jZS53aGVlbERlbHRhKHdoZWVsRGVsdGEpO1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uaW50ZXJwb2xhdGUob3B0aW9ucz8uaW50ZXJwb2xhdGUgPT09ICdsaW5lYXInID8gaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVpvb20pLnRyYW5zZm9ybShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIG9uUGFuZUNvbnRleHRNZW51LCB1c2VyU2VsZWN0aW9uQWN0aXZlLCBwYW5PblNjcm9sbCwgcGFuT25EcmFnLCBwYW5PblNjcm9sbE1vZGUsIHBhbk9uU2Nyb2xsU3BlZWQsIHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblBpbmNoLCB6b29tT25TY3JvbGwsIHpvb21PbkRvdWJsZUNsaWNrLCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsIGxpYiwgb25UcmFuc2Zvcm1DaGFuZ2UsIGNvbm5lY3Rpb25JblByb2dyZXNzLCBwYW5lQ2xpY2tEaXN0YW5jZSwgc2VsZWN0aW9uT25EcmFnLCB9KSB7XG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlICYmICF6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZykge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUGFuT25TY3JvbGwgPSBwYW5PblNjcm9sbCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkICYmICF1c2VyU2VsZWN0aW9uQWN0aXZlO1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5jbGlja0Rpc3RhbmNlKHNlbGVjdGlvbk9uRHJhZyA/IEluZmluaXR5IDogIWlzTnVtZXJpYyhwYW5lQ2xpY2tEaXN0YW5jZSkgfHwgcGFuZUNsaWNrRGlzdGFuY2UgPCAwID8gMCA6IHBhbmVDbGlja0Rpc3RhbmNlKTtcbiAgICAgICAgY29uc3Qgd2hlZWxIYW5kbGVyID0gaXNQYW5PblNjcm9sbFxuICAgICAgICAgICAgPyBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBkM1pvb206IGQzWm9vbUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgICAgICAgICAgZDNab29tSGFuZGxlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIHdoZWVsSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBzdGFydFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignc3RhcnQnLCBzdGFydEhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gcGFuIHpvb21cbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21IYW5kbGVyID0gY3JlYXRlUGFuWm9vbUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51OiAhIW9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3pvb20nLCBwYW5ab29tSGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21FbmRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignZW5kJywgcGFuWm9vbUVuZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNyZWF0ZUZpbHRlcih7XG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgY29ubmVjdGlvbkluUHJvZ3Jlc3MsXG4gICAgICAgIH0pO1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2UgY2Fubm90IGFkZCB6b29tT25Eb3VibGVDbGljayB0byB0aGUgZmlsdGVyIGFib3ZlIGJlY2F1c2VcbiAgICAgICAgICogZG91YmxlIHRhcHBpbmcgb24gdG91Y2ggc2NyZWVucyBjaXJjdW12ZW50cyB0aGUgZmlsdGVyIGFuZFxuICAgICAgICAgKiBkYmxjbGljay56b29tIGlzIGZpcmVkIG9uIHRoZSBzZWxlY3Rpb24gZGlyZWN0bHlcbiAgICAgICAgICovXG4gICAgICAgIGlmICh6b29tT25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBkM0RibENsaWNrWm9vbUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHZpZXdwb3J0LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgIGNvbnN0IGNvbnRyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb21JbnN0YW5jZT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBpZiAoY29udHJhaW5lZFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKGNvbnRyYWluZWRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShjb250cmFpbmVkVHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0KHZpZXdwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKG5leHRUcmFuc2Zvcm0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUobmV4dFRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzeW5jVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0uayAhPT0gdmlld3BvcnQuem9vbSB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueCAhPT0gdmlld3BvcnQueCB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueSAhPT0gdmlld3BvcnQueSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zZm9ybShkM1NlbGVjdGlvbiwgbmV4dFRyYW5zZm9ybSwgbnVsbCwgeyBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0KCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBkM1NlbGVjdGlvbiA/IHpvb21UcmFuc2Zvcm0oZDNTZWxlY3Rpb24ubm9kZSgpKSA6IHsgeDogMCwgeTogMCwgazogMSB9O1xuICAgICAgICByZXR1cm4geyB4OiB0cmFuc2Zvcm0ueCwgeTogdHJhbnNmb3JtLnksIHpvb206IHRyYW5zZm9ybS5rIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8oem9vbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkuc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgem9vbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uaW50ZXJwb2xhdGUob3B0aW9ucz8uaW50ZXJwb2xhdGUgPT09ICdsaW5lYXInID8gaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVpvb20pLnNjYWxlQnkoZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgb3B0aW9ucz8uZWFzZSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIGZhY3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0U2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENsaWNrRGlzdGFuY2UoZGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWREaXN0YW5jZSA9ICFpc051bWVyaWMoZGlzdGFuY2UpIHx8IGRpc3RhbmNlIDwgMCA/IDAgOiBkaXN0YW5jZTtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LmNsaWNrRGlzdGFuY2UodmFsaWREaXN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgc2V0Vmlld3BvcnQsXG4gICAgICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQsXG4gICAgICAgIGdldFZpZXdwb3J0LFxuICAgICAgICBzY2FsZVRvLFxuICAgICAgICBzY2FsZUJ5LFxuICAgICAgICBzZXRTY2FsZUV4dGVudCxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBzeW5jVmlld3BvcnQsXG4gICAgICAgIHNldENsaWNrRGlzdGFuY2UsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGRldGVybWluZSB0aGUgdmFyaWFudCBvZiB0aGUgcmVzaXplIGNvbnRyb2xcbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZXNpemVDb250cm9sVmFyaWFudDtcbihmdW5jdGlvbiAoUmVzaXplQ29udHJvbFZhcmlhbnQpIHtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkhhbmRsZVwiXSA9IFwiaGFuZGxlXCI7XG59KShSZXNpemVDb250cm9sVmFyaWFudCB8fCAoUmVzaXplQ29udHJvbFZhcmlhbnQgPSB7fSkpO1xuY29uc3QgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TID0gWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcblxuLyoqXG4gKiBHZXQgYWxsIGNvbm5lY3RpbmcgZWRnZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIG5vZGVzXG4gKiBAcGFyYW0gd2lkdGggLSBuZXcgd2lkdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2V2lkdGggLSBwcmV2aW91cyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGhlaWdodCAtIG5ldyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2SGVpZ2h0IC0gcHJldmlvdXMgaGVpZ2h0IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gYWZmZWN0c1ggLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHggYXhpc1xuICogQHBhcmFtIGFmZmVjdHNZIC0gd2hldGhlciB0byBpbnZlcnQgdGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoZSB5IGF4aXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIHR3byBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByZXNpemUgZm9yIGVhY2ggYXhpcywgMCA9IG5vIGNoYW5nZSwgMSA9IGluY3JlYXNlLCAtMSA9IGRlY3JlYXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZURpcmVjdGlvbih7IHdpZHRoLCBwcmV2V2lkdGgsIGhlaWdodCwgcHJldkhlaWdodCwgYWZmZWN0c1gsIGFmZmVjdHNZLCB9KSB7XG4gICAgY29uc3QgZGVsdGFXaWR0aCA9IHdpZHRoIC0gcHJldldpZHRoO1xuICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID0gaGVpZ2h0IC0gcHJldkhlaWdodDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBbZGVsdGFXaWR0aCA+IDAgPyAxIDogZGVsdGFXaWR0aCA8IDAgPyAtMSA6IDAsIGRlbHRhSGVpZ2h0ID4gMCA/IDEgOiBkZWx0YUhlaWdodCA8IDAgPyAtMSA6IDBdO1xuICAgIGlmIChkZWx0YVdpZHRoICYmIGFmZmVjdHNYKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IGRpcmVjdGlvblswXSAqIC0xO1xuICAgIH1cbiAgICBpZiAoZGVsdGFIZWlnaHQgJiYgYWZmZWN0c1kpIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gZGlyZWN0aW9uWzFdICogLTE7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgY29udHJvbCBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIGRyYWdnZWQgdG8gZGltZW5zaW9ucyB0aGF0IGFyZSBiZWluZyByZXNpemVkXG4gKiBAcGFyYW0gY29udHJvbFBvc2l0aW9uIC0gcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgdGhhdCBpcyBiZWluZyBkcmFnZ2VkXG4gKiBAcmV0dXJucyBpc0hvcml6b250YWwsIGlzVmVydGljYWwsIGFmZmVjdHNYLCBhZmZlY3RzWSxcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3JpZ2h0JykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICBjb25zdCBhZmZlY3RzWCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIGNvbnN0IGFmZmVjdHNZID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0hvcml6b250YWwsXG4gICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgIGFmZmVjdHNYLFxuICAgICAgICBhZmZlY3RzWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJFeHRlbnRDbGFtcChsb3dlckV4dGVudCwgbG93ZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBsb3dlckJvdW5kIC0gbG93ZXJFeHRlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VXBwZXJFeHRlbnRDbGFtcCh1cHBlckV4dGVudCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCB1cHBlckV4dGVudCAtIHVwcGVyQm91bmQpO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZUNsYW1wKHNpemUsIG1pblNpemUsIG1heFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWluU2l6ZSAtIHNpemUsIHNpemUgLSBtYXhTaXplKTtcbn1cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyAhYiA6IGI7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgbmV3IHdpZHRoICYgaGVpZ2h0IGFuZCB4ICYgeSBvZiBub2RlIGFmdGVyIHJlc2l6ZSBiYXNlZCBvbiBwb2ludGVyIHBvc2l0aW9uXG4gKiBAZGVzY3JpcHRpb24gLSBCdWNrbGUgdXAsIHRoaXMgaXMgYSBjaHVua3kgb25lLi4uIElmIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgbmV3IGRpbWVuc2lvbnMgb2YgYSBub2RlIGFmdGVyIGEgcmVzaXplLFxuICogeW91IGhhdmUgdG8gYWNjb3VudCBmb3IgYWxsIHBvc3NpYmxlIHJlc3RyaWN0aW9uczogbWluL21heCB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUsIHRoZSBtYXhpbXVtIGV4dGVudCB0aGUgbm9kZSBpcyBhbGxvd2VkXG4gKiB0byBtb3ZlIGluIChpbiB0aGlzIGNhc2U6IHJlc2l6ZSBpbnRvKSBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgbm9kZSwgdGhlIG1pbmltYWwgZXh0ZW50IGRldGVybWluZWQgYnkgY2hpbGQgbm9kZXNcbiAqIHdpdGggZXhwYW5kUGFyZW50IG9yIGV4dGVudDogJ3BhcmVudCcgc2V0IGFuZCBvaCB5ZWFoLCB0aGVzZSB0aGluZ3MgYWxzbyBoYXZlIHRvIHdvcmsgd2l0aCBrZWVwQXNwZWN0UmF0aW8hXG4gKiBUaGUgd2F5IHRoaXMgaXMgZG9uZSBpcyBieSBkZXRlcm1pbmluZyBob3cgbXVjaCBlYWNoIG9mIHRoZXNlIHJlc3RyaWN0aW5nIGFjdHVhbGx5IHJlc3RyaWN0cyB0aGUgcmVzaXplIGFuZCB0aGVuIGFwcGx5aW5nIHRoZVxuICogc3Ryb25nZXN0IHJlc3RyaWN0aW9uLiBCZWNhdXNlIHRoZSByZXNpemUgYWZmZWN0cyB4LCB5IGFuZCB3aWR0aCwgaGVpZ2h0IGFuZCB3aWR0aCwgaGVpZ2h0IG9mIGEgb3Bwb3Npbmcgc2lkZSB3aXRoIGtlZXBBc3BlY3RSYXRpbyxcbiAqIHRoZSByZXNpemUgYW1vdW50IGlzIGFsd2F5cyBrZXB0IGluIGRpc3RYICYgZGlzdFkgYW1vdW50ICh0aGUgZGlzdGFuY2UgaW4gbW91c2UgbW92ZW1lbnQpXG4gKiBJbnN0ZWFkIG9mIGNsYW1waW5nIGVhY2ggdmFsdWUsIHdlIGZpcnN0IGNhbGN1bGF0ZSB0aGUgYmlnZ2VzdCAnY2xhbXAnIChmb3IgdGhlIGxhY2sgb2YgYSBiZXR0ZXIgbmFtZSkgYW5kIHRoZW4gYXBwbHkgaXQgdG8gYWxsIHZhbHVlcy5cbiAqIFRvIGNvbXBsaWNhdGUgdGhpbmdzIG5vZGVPcmlnaW4gaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCBhcyB3ZWxsLiBUaGlzIGlzIGRvbmUgYnkgb2Zmc2V0dGluZyB0aGUgbm9kZXMgYXMgaWYgdGhlaXIgb3JpZ2luIGlzIFswLCAwXSxcbiAqIHRoZW4gY2FsY3VsYXRpbmcgdGhlIHJlc3RyaWN0aW9ucyBhcyB1c3VhbFxuICogQHBhcmFtIHN0YXJ0VmFsdWVzIC0gc3RhcnRpbmcgdmFsdWVzIG9mIHJlc2l6ZVxuICogQHBhcmFtIGNvbnRyb2xEaXJlY3Rpb24gLSBkaW1lbnNpb25zIGFmZmVjdGVkIGJ5IHRoZSByZXNpemVcbiAqIEBwYXJhbSBwb2ludGVyUG9zaXRpb24gLSB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGNvcnJlY3RlZCBmb3Igc25hcHBpbmdcbiAqIEBwYXJhbSBib3VuZGFyaWVzIC0gbWluaW11bSBhbmQgbWF4aW11bSBkaW1lbnNpb25zIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ga2VlcEFzcGVjdFJhdGlvIC0gcHJldmVudCBjaGFuZ2VzIG9mIGFzcHJlY3QgcmF0aW9cbiAqIEByZXR1cm5zIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIG5vZGUgYWZ0ZXIgcmVzaXplXG4gKi9cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIGV4dGVudCwgY2hpbGRFeHRlbnQpIHtcbiAgICBsZXQgeyBhZmZlY3RzWCwgYWZmZWN0c1kgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgeyBpc0hvcml6b250YWwsIGlzVmVydGljYWwgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgaXNEaWFnb25hbCA9IGlzSG9yaXpvbnRhbCAmJiBpc1ZlcnRpY2FsO1xuICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBwb2ludGVyUG9zaXRpb247XG4gICAgY29uc3QgeyBtaW5XaWR0aCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWF4SGVpZ2h0IH0gPSBib3VuZGFyaWVzO1xuICAgIGNvbnN0IHsgeDogc3RhcnRYLCB5OiBzdGFydFksIHdpZHRoOiBzdGFydFdpZHRoLCBoZWlnaHQ6IHN0YXJ0SGVpZ2h0LCBhc3BlY3RSYXRpbyB9ID0gc3RhcnRWYWx1ZXM7XG4gICAgbGV0IGRpc3RYID0gTWF0aC5mbG9vcihpc0hvcml6b250YWwgPyB4U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJYIDogMCk7XG4gICAgbGV0IGRpc3RZID0gTWF0aC5mbG9vcihpc1ZlcnRpY2FsID8geVNuYXBwZWQgLSBzdGFydFZhbHVlcy5wb2ludGVyWSA6IDApO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKTtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRYID0gLW5vZGVPcmlnaW5bMF0gKiBzdGFydFdpZHRoO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFkgPSAtbm9kZU9yaWdpblsxXSAqIHN0YXJ0SGVpZ2h0O1xuICAgIC8vIENoZWNrIGlmIG1heFdpZHRoLCBtaW5XV2lkdGgsIG1heEhlaWdodCwgbWluSGVpZ2h0IGFyZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgbGV0IGNsYW1wWCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCwgbWluV2lkdGgsIG1heFdpZHRoKTtcbiAgICBsZXQgY2xhbXBZID0gZ2V0U2l6ZUNsYW1wKG5ld0hlaWdodCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgIC8vIENoZWNrIGlmIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgICBsZXQgeEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgbGV0IHlFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGlmIChhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgZGlzdFggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA+IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA8IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFkgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3SGVpZ2h0ICsgb3JpZ2luT2Zmc2V0WSwgZXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCwgY2hpbGRFeHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGgsIGNoaWxkRXh0ZW50WzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZmZWN0c1kgJiYgZGlzdFkgPiAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIGRpc3RZLCBjaGlsZEV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQsIGNoaWxkRXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFzcGVjdCByYXRpbyByZXNpemluZyBvZiB0aGUgb3RoZXIgc2lkZSBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWF4IGRpbWVuc2lvbnMgbWlnaHQgYmUgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgYXNwZWN0SGVpZ2h0Q2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3V2lkdGggLyBhc3BlY3RSYXRpbywgbWluSGVpZ2h0LCBtYXhIZWlnaHQpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEhlaWdodENsYW1wKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIChhZmZlY3RzWCA/IGRpc3RYIDogLWRpc3RYKSAvIGFzcGVjdFJhdGlvLCBleHRlbnRbMF1bMV0pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzBdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSB0aGluZyBmb3IgdmVydGljYWwgcmVzaXppbmdcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdFdpZHRoQ2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIG1pbldpZHRoLCBtYXhXaWR0aCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0V2lkdGhDbGFtcCk7XG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWSAmJiAhYWZmZWN0c1ggJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgKGFmZmVjdHNZID8gZGlzdFkgOiAtZGlzdFkpICogYXNwZWN0UmF0aW8gKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3RZID0gZGlzdFkgKyAoZGlzdFkgPCAwID8gY2xhbXBZIDogLWNsYW1wWSk7XG4gICAgZGlzdFggPSBkaXN0WCArIChkaXN0WCA8IDAgPyBjbGFtcFggOiAtY2xhbXBYKTtcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RYIDogZGlzdFgpIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9ICh4b3IoYWZmZWN0c1gsIGFmZmVjdHNZKSA/IC1kaXN0WSA6IGRpc3RZKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gZGlzdFggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBhZmZlY3RzWSA9IGFmZmVjdHNYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdFggPSBkaXN0WSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNYID0gYWZmZWN0c1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeCA9IGFmZmVjdHNYID8gc3RhcnRYICsgZGlzdFggOiBzdGFydFg7XG4gICAgY29uc3QgeSA9IGFmZmVjdHNZID8gc3RhcnRZICsgZGlzdFkgOiBzdGFydFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyAoYWZmZWN0c1ggPyAtZGlzdFggOiBkaXN0WCksXG4gICAgICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyAoYWZmZWN0c1kgPyAtZGlzdFkgOiBkaXN0WSksXG4gICAgICAgIHg6IG5vZGVPcmlnaW5bMF0gKiBkaXN0WCAqICghYWZmZWN0c1ggPyAxIDogLTEpICsgeCxcbiAgICAgICAgeTogbm9kZU9yaWdpblsxXSAqIGRpc3RZICogKCFhZmZlY3RzWSA/IDEgOiAtMSkgKyB5LFxuICAgIH07XG59XG5cbmNvbnN0IGluaXRQcmV2VmFsdWVzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB4OiAwLCB5OiAwIH07XG5jb25zdCBpbml0U3RhcnRWYWx1ZXMgPSB7XG4gICAgLi4uaW5pdFByZXZWYWx1ZXMsXG4gICAgcG9pbnRlclg6IDAsXG4gICAgcG9pbnRlclk6IDAsXG4gICAgYXNwZWN0UmF0aW86IDEsXG59O1xuZnVuY3Rpb24gbm9kZVRvUGFyZW50RXh0ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtub2RlLm1lYXN1cmVkLndpZHRoLCBub2RlLm1lYXN1cmVkLmhlaWdodF0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBwYXJlbnQsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCB4ID0gcGFyZW50LnBvc2l0aW9uLnggKyBjaGlsZC5wb3NpdGlvbi54O1xuICAgIGNvbnN0IHkgPSBwYXJlbnQucG9zaXRpb24ueSArIGNoaWxkLnBvc2l0aW9uLnk7XG4gICAgY29uc3Qgd2lkdGggPSBjaGlsZC5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGNoaWxkLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSBub2RlT3JpZ2luWzBdICogd2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IG5vZGVPcmlnaW5bMV0gKiBoZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW3ggLSBvcmlnaW5PZmZzZXRYLCB5IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgICAgIFt4ICsgd2lkdGggLSBvcmlnaW5PZmZzZXRYLCB5ICsgaGVpZ2h0IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIFhZUmVzaXplcih7IGRvbU5vZGUsIG5vZGVJZCwgZ2V0U3RvcmVJdGVtcywgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgbGV0IHBhcmFtcyA9IHtcbiAgICAgICAgY29udHJvbERpcmVjdGlvbjogZ2V0Q29udHJvbERpcmVjdGlvbignYm90dG9tLXJpZ2h0JyksXG4gICAgICAgIGJvdW5kYXJpZXM6IHtcbiAgICAgICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiAwLFxuICAgICAgICAgICAgbWF4V2lkdGg6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc2l6ZURpcmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBrZWVwQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgIH07XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgY29udHJvbFBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIHJlc2l6ZURpcmVjdGlvbiwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCBzaG91bGRSZXNpemUsIH0pIHtcbiAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7IC4uLmluaXRQcmV2VmFsdWVzIH07XG4gICAgICAgIGxldCBzdGFydFZhbHVlcyA9IHsgLi4uaW5pdFN0YXJ0VmFsdWVzIH07XG4gICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXMsXG4gICAgICAgICAgICByZXNpemVEaXJlY3Rpb24sXG4gICAgICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgICAgICBjb250cm9sRGlyZWN0aW9uOiBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7IC8vIE5lZWRlZCB0byBmaXggZXhwYW5kUGFyZW50XG4gICAgICAgIGxldCBwYXJlbnRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHRyaWdnZXIgb25SZXNpemVFbmQgaWYgb25SZXNpemUgd2FzIGFjdHVhbGx5IGNhbGxlZFxuICAgICAgICBsZXQgcmVzaXplRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBkcmFnKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgcGFuZURvbU5vZGUgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gcGFuZURvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHhTbmFwcGVkLCB5U25hcHBlZCB9ID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcmV2VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCA/PyAwLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSA/PyAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIC4uLnByZXZWYWx1ZXMsXG4gICAgICAgICAgICAgICAgcG9pbnRlclg6IHhTbmFwcGVkLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJZOiB5U25hcHBlZCxcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogcHJldlZhbHVlcy53aWR0aCAvIHByZXZWYWx1ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnIHx8IG5vZGUuZXhwYW5kUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRFeHRlbnQgPSBwYXJlbnROb2RlICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyA/IG5vZGVUb1BhcmVudEV4dGVudChwYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBDb2xsZWN0IGFsbCBjaGlsZCBub2RlcyB0byBjb3JyZWN0IHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERldGVybWluZSBsYXJnZXN0IG1pbmltYWwgZXh0ZW50IHRoZSBwYXJlbnQgbm9kZSBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0b1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkSWQsIGNoaWxkXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudElkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4uY2hpbGQucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogY2hpbGQuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgY2hpbGQuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBub2RlVG9DaGlsZEV4dGVudChjaGlsZCwgbm9kZSwgY2hpbGQub3JpZ2luID8/IG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1pbihleHRlbnRbMF1bMF0sIGNoaWxkRXh0ZW50WzBdWzBdKSwgTWF0aC5taW4oZXh0ZW50WzBdWzFdLCBjaGlsZEV4dGVudFswXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5tYXgoZXh0ZW50WzFdWzBdLCBjaGlsZEV4dGVudFsxXVswXSksIE1hdGgubWF4KGV4dGVudFsxXVsxXSwgY2hpbGRFeHRlbnRbMV1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBleHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0Py4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4gfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHg6IHByZXZYLCB5OiBwcmV2WSwgd2lkdGg6IHByZXZXaWR0aCwgaGVpZ2h0OiBwcmV2SGVpZ2h0IH0gPSBwcmV2VmFsdWVzO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge307XG4gICAgICAgICAgICBjb25zdCBub2RlT3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gc3RvcmVOb2RlT3JpZ2luO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXREaW1lbnNpb25zQWZ0ZXJSZXNpemUoc3RhcnRWYWx1ZXMsIHBhcmFtcy5jb250cm9sRGlyZWN0aW9uLCBwb2ludGVyUG9zaXRpb24sIHBhcmFtcy5ib3VuZGFyaWVzLCBwYXJhbXMua2VlcEFzcGVjdFJhdGlvLCBub2RlT3JpZ2luLCBwYXJlbnRFeHRlbnQsIGNoaWxkRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzV2lkdGhDaGFuZ2UgPSB3aWR0aCAhPT0gcHJldldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaXNIZWlnaHRDaGFuZ2UgPSBoZWlnaHQgIT09IHByZXZIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBpc1hQb3NDaGFuZ2UgPSB4ICE9PSBwcmV2WCAmJiBpc1dpZHRoQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgaXNZUG9zQ2hhbmdlID0geSAhPT0gcHJldlkgJiYgaXNIZWlnaHRDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWlzWFBvc0NoYW5nZSAmJiAhaXNZUG9zQ2hhbmdlICYmICFpc1dpZHRoQ2hhbmdlICYmICFpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1hQb3NDaGFuZ2UgfHwgaXNZUG9zQ2hhbmdlIHx8IG5vZGVPcmlnaW5bMF0gPT09IDEgfHwgbm9kZU9yaWdpblsxXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS54ID0gaXNYUG9zQ2hhbmdlID8geCA6IHByZXZWYWx1ZXMueDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueSA9IGlzWVBvc0NoYW5nZSA/IHkgOiBwcmV2VmFsdWVzLnk7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0gY2hhbmdlLng7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0gY2hhbmdlLnk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB3aGVuIHRvcC9sZWZ0IGNoYW5nZXMsIGNvcnJlY3QgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgICAqIHNvIHRoYXQgdGhleSBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0geCAtIHByZXZYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0geSAtIHByZXZZO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgbm9kZU9yaWdpblswXSAqICh3aWR0aCAtIHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgbm9kZU9yaWdpblsxXSAqIChoZWlnaHQgLSBwcmV2SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENoYW5nZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2lkdGhDaGFuZ2UgfHwgaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICBpc1dpZHRoQ2hhbmdlICYmICghcGFyYW1zLnJlc2l6ZURpcmVjdGlvbiB8fCBwYXJhbXMucmVzaXplRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZXZWYWx1ZXMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2hhbmdlLmhlaWdodCA9XG4gICAgICAgICAgICAgICAgICAgIGlzSGVpZ2h0Q2hhbmdlICYmICghcGFyYW1zLnJlc2l6ZURpcmVjdGlvbiB8fCBwYXJhbXMucmVzaXplRGlyZWN0aW9uID09PSAndmVydGljYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJldlZhbHVlcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy53aWR0aCA9IGNoYW5nZS53aWR0aDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLmhlaWdodCA9IGNoYW5nZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXggZXhwYW5kUGFyZW50IHdoZW4gcmVzaXppbmcgZnJvbSB0b3AvbGVmdFxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4TGltaXQgPSBub2RlT3JpZ2luWzBdICogKGNoYW5nZS53aWR0aCA/PyAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnggJiYgY2hhbmdlLnggPCB4TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0geExpbWl0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy54ID0gc3RhcnRWYWx1ZXMueCAtIChjaGFuZ2UueCAtIHhMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHlMaW1pdCA9IG5vZGVPcmlnaW5bMV0gKiAoY2hhbmdlLmhlaWdodCA/PyAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnkgJiYgY2hhbmdlLnkgPCB5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0geUxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy55ID0gc3RhcnRWYWx1ZXMueSAtIChjaGFuZ2UueSAtIHlMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0UmVzaXplRGlyZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHJldlZhbHVlcy53aWR0aCxcbiAgICAgICAgICAgICAgICBwcmV2V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwcmV2VmFsdWVzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBwcmV2SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFmZmVjdHNYOiBwYXJhbXMuY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWTogcGFyYW1zLmNvbnRyb2xEaXJlY3Rpb24uYWZmZWN0c1ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZXMgPSB7IC4uLnByZXZWYWx1ZXMsIGRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbFJlc2l6ZSA9IHNob3VsZFJlc2l6ZT8uKGV2ZW50LCBuZXh0VmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChjYWxsUmVzaXplID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2l6ZURldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgb25DaGFuZ2UoY2hhbmdlLCBjaGlsZENoYW5nZXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzaXplRGV0ZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZUVuZD8uKGV2ZW50LCB7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgICAgICBvbkVuZD8uKHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgICAgIHJlc2l6ZURldGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbChkcmFnSGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHNlbGVjdGlvbi5vbignLmRyYWcnLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBYWURyYWcsIFhZSGFuZGxlLCBYWU1pbmltYXAsIFhZUGFuWm9vbSwgWFlSZXNpemVyLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIGFkZEVkZ2UsIGFkb3B0VXNlck5vZGVzLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBhcmVTZXRzRXF1YWwsIGJveFRvUmVjdCwgY2FsY0F1dG9QYW4sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgY2xhbXAsIGNsYW1wUG9zaXRpb24sIGNsYW1wUG9zaXRpb25Ub1BhcmVudCwgY3JlYXRlTWFya2VySWRzLCBkZWZhdWx0QXJpYUxhYmVsQ29uZmlnLCBkZXZXYXJuLCBlbGVtZW50U2VsZWN0aW9uS2V5cywgZXJyb3JNZXNzYWdlcywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBmaXRWaWV3cG9ydCwgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Qm91bmRzT2ZCb3hlcywgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldENvbm5lY3Rpb25TdGF0dXMsIGdldERpbWVuc2lvbnMsIGdldEVkZ2VDZW50ZXIsIGdldEVkZ2VJZCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFZGdlVG9vbGJhclRyYW5zZm9ybSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRFdmVudFBvc2l0aW9uLCBnZXRIYW5kbGVCb3VuZHMsIGdldEhhbmRsZVBvc2l0aW9uLCBnZXRIb3N0Rm9yRWxlbWVudCwgZ2V0SW5jb21lcnMsIGdldEludGVybmFsTm9kZXNCb3VuZHMsIGdldE1hcmtlcklkLCBnZXROb2RlRGltZW5zaW9ucywgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiwgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0sIGdldE5vZGVzQm91bmRzLCBnZXROb2Rlc0luc2lkZSwgZ2V0T3V0Z29lcnMsIGdldE92ZXJsYXBwaW5nQXJlYSwgZ2V0UG9pbnRlclBvc2l0aW9uLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRWaWV3cG9ydEZvckJvdW5kcywgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgaGFuZGxlRXhwYW5kUGFyZW50LCBpbmZpbml0ZUV4dGVudCwgaW5pdGlhbENvbm5lY3Rpb24sIGlzQ29vcmRpbmF0ZUV4dGVudCwgaXNFZGdlQmFzZSwgaXNFZGdlVmlzaWJsZSwgaXNJbnB1dERPTU5vZGUsIGlzSW50ZXJuYWxOb2RlQmFzZSwgaXNNYWNPcywgaXNNYW51YWxaSW5kZXhNb2RlLCBpc01vdXNlRXZlbnQsIGlzTm9kZUJhc2UsIGlzTnVtZXJpYywgaXNSZWN0T2JqZWN0LCBtZXJnZUFyaWFMYWJlbENvbmZpZywgbm9kZUhhc0RpbWVuc2lvbnMsIG5vZGVUb0JveCwgbm9kZVRvUmVjdCwgb3Bwb3NpdGVQb3NpdGlvbiwgcGFuQnksIHBvaW50VG9SZW5kZXJlclBvaW50LCByZWNvbm5lY3RFZGdlLCByZWN0VG9Cb3gsIHJlbmRlcmVyUG9pbnRUb1BvaW50LCBzaGFsbG93Tm9kZURhdGEsIHNuYXBQb3NpdGlvbiwgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHdpdGhSZXNvbHZlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@xyflow+system@0.0.74/node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ })

};
;